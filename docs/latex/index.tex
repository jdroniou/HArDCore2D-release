\label{index_md_docs_MAINPAGE}%
\Hypertarget{index_md_docs_MAINPAGE}%
 HAr\+D\+::\+Core (sources\+: \href{https://github.com/jdroniou/HArDCore}{\texttt{ https\+://github.\+com/jdroniou/\+HAr\+DCore}}) provides a suite of C++ tools to implement numerical schemes whose unknowns are polynomials in the cells, on the edges, and on the faces. The focus is on dealing on generic polytopal meshes. This document addresses the 2D version of HAr\+D\+::\+Core. The tools are similar in 2D and 3D, and we refer to the main page of documentation of the 3D version for a more thorough introduction to the library. We only present here the specific way of loading a 2D mesh structure (which differs from the 3D version), and a brief description of the schemes available in this 2D library.

Transferring a scheme\textquotesingle{}s implementation from 3D to 2D or vice-\/versa is very straightforward, provided that the scheme\textquotesingle{}s mathematical definition does not depend on the dimension and that the generic types provided in {\ttfamily \mbox{\hyperlink{basis_8hpp}{basis.\+hpp}}} are used; see README file of the HAr\+D\+::\+Core github depository \href{https://github.com/jdroniou/HArDCore}{\texttt{ https\+://github.\+com/jdroniou/\+HAr\+DCore}}.


\begin{DoxyItemize}
\item \href{\#mesh}{\texttt{ Loading a 2D mesh}} -- How to load a mesh.
\item \href{\#schemes}{\texttt{ Schemes}} -- The list of schemes currently implemented in HAr\+D\+::\+Core2D, and scripts to run them.
\end{DoxyItemize}

\label{_mesh}%
 \hypertarget{index_loading_mesh}{}\doxysection{Loading a mesh}\label{index_loading_mesh}
\mbox{\hyperlink{namespaceHArDCore2D}{HAr\+DCore2D}} currently reads meshes in the {\ttfamily typ2} format designed for the \href{https://www.i2m.univ-amu.fr/fvca5/benchmark/index.html}{\texttt{ FVCA5 Benchmark}}. A short documentation describing this format is provided in the {\ttfamily typ2\+\_\+meshes} directory (see README.\+pdf therein). Several meshes can also be found in this directory.

A mesh file must be read using an instance of the {\ttfamily Mesh\+Reader\+Typ2} class, and then built using {\ttfamily Mesh\+Builder}. A working example is given below (assuming the executable will be in {\ttfamily build/\+Schemes} for example).


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "{}\mbox{\hyperlink{mesh_8hpp}{mesh.hpp}}"{}}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "{}import\_mesh.hpp"{}}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "{}mesh\_builder.hpp"{}}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{using namespace }\mbox{\hyperlink{namespaceHArDCore2D}{HArDCore2D}};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int} \mbox{\hyperlink{CMakeCCompilerId_8c_a0ddf1224851353fc92bfbff6f499fa97}{main}}() \{}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// Build mesh}}
\DoxyCodeLine{  MeshBuilder builder = MeshBuilder(mesh\_file);}
\DoxyCodeLine{  std::unique\_ptr<Mesh> mesh\_ptr = builder.build\_the\_mesh();}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// Get the BC and re-\/order the edges (useful to set BC for hybrid schemes)}}
\DoxyCodeLine{  std::string \mbox{\hyperlink{group__HHO__DiffAdvecReac_ga13b5a180bd74bcc66c3e5429b4171d33}{bc\_id}} = vm[\textcolor{stringliteral}{"{}bc\_id"{}}].as<std::string>();}
\DoxyCodeLine{  \mbox{\hyperlink{classBoundaryConditions}{BoundaryConditions}} BC(\mbox{\hyperlink{group__HHO__DiffAdvecReac_ga13b5a180bd74bcc66c3e5429b4171d33}{bc\_id}}, *mesh\_ptr.get());}
\DoxyCodeLine{  BC.reorder\_edges();}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// Create an HybridCore instance}}
\DoxyCodeLine{  HybridCore hho(mesh\_ptr.get(), \mbox{\hyperlink{group__HHO__DiffAdvecReac_gaf169764abf85f85bec428e43dc60274b}{K}}+1, \mbox{\hyperlink{group__HHO__DiffAdvecReac_gaf169764abf85f85bec428e43dc60274b}{K}}, \mbox{\hyperlink{group__HHO__DiffAdvecReac_ga61c147fa3e7a4b2f35ba838ce26aa026}{use\_threads}}, output);}
\DoxyCodeLine{\}}

\end{DoxyCode}


{\itshape Note}\+: the {\ttfamily typ2} format allows for meshes with very generic polygonal cells, including non-\/convex cells. However, the builder assumes that each cell is star-\/shaped with respect to the isobarycenter of its vertices -- otherwise, the calculation of the center of mass may be incorrect. Similarly, the quadrature rules assume that each cell is star-\/shaped with respect to its center of mass.

\label{_schemes}%
 \hypertarget{index_schemes}{}\doxysection{Schemes}\label{index_schemes}
The following schemes are currently available in HAr\+D\+::\+Core2D. The Hybrid High-\/\+Order schemes follow the implementation principles described in Appendix B of the book available at \href{https://hal.archives-ouvertes.fr/hal-02151813}{\texttt{ https\+://hal.\+archives-\/ouvertes.\+fr/hal-\/02151813}}.


\begin{DoxyItemize}
\item \mbox{\hyperlink{group__HHO__Diffusion}{HHO\+\_\+diffusion}}\+: Hybrid High-\/\+Order (HHO) for $-\mathrm{div}(K\nabla u)=f$, for Dirichlet, Neumann or mixed boundary conditions, with $K$ a diffusion tensor that is piecewise constant on the mesh.
\item \mbox{\hyperlink{group__HHO__LocVarDiff}{HHO\+\_\+locvardiff}}\+: HHO for $-\mathrm{div}(K\nabla u)=f$, for Dirichlet, Neumann or mixed boundary conditions, with $K$ a diffusion tensor that can vary in each cell.
\item \mbox{\hyperlink{group__HHO__DiffAdvecReac}{HHO\+\_\+diffadvecreac}}\+: Hybrid High-\/\+Order (HHO) for $-\mathrm{div}(K\nabla u+\beta u)+\mu u=f$, for Dirichlet or mixed boundary conditions, with $K$ a diffusion tensor that is piecewise constant on the mesh.
\item \mbox{\hyperlink{classHArDCore2D_1_1LEPNC__diffusion}{LEPNC\+\_\+diffusion}}, in module \mbox{\hyperlink{group__LEPNC}{LEPNC}}\+: Locally Enriched Polytopal Non-\/\+Conforming (LEPNC) method for the pure diffusion problem $-\mathrm{div}(K\nabla\zeta(u))=f$.
\item \mbox{\hyperlink{classHArDCore2D_1_1LEPNC__StefanPME}{LEPNC\+\_\+\+Stefan\+PME}}, in module \mbox{\hyperlink{group__LEPNC}{LEPNC}}\+: Locally Enriched Polytopal Non-\/\+Conforming (LEPNC) method for the stationnary Stefan/\+PME problem $u-\mathrm{div}(K\nabla\zeta(u))=f$.
\item \mbox{\hyperlink{classHArDCore2D_1_1LEPNC__StefanPME__Transient}{LEPNC\+\_\+\+Stefan\+PME\+\_\+\+Transient}}, in module \mbox{\hyperlink{group__LEPNC}{LEPNC}}\+: LEPNC for the transient Stefan/\+PME problem $\partial_t u-\mathrm{div}(K\nabla\zeta(u))=f$ {\itshape (may not be working any longer due to changes in the management of quadrature rules)}
\item \mbox{\hyperlink{classHArDCore2D_1_1HMM__StefanPME__Transient}{HMM\+\_\+\+Stefan\+PME\+\_\+\+Transient}}, in module \mbox{\hyperlink{group__HMM}{HMM}}\+: Hybrid Mimetic Mixed (HMM) method for the transient Stefan/\+PME problem $\partial_t u-\mathrm{div}(K\nabla\zeta(u))=f$.
\item \mbox{\hyperlink{group__DDR__rmplate}{DDR\+\_\+rmplate}}\+: Discrete de Rham (DDR) scheme for the Reissner-\/\+Mindlin plate bending problem.
\item \mbox{\hyperlink{group__DDR__klplate}{DDR\+\_\+klplate}}\+: Scheme for the Kirchhoff-\/\+Love plate problem based on the DDR principles (with design of a specific complex for plates).
\item \mbox{\hyperlink{group__HHO__fullgradientdiff}{HHO\+\_\+fullgradientdiff}}\+: HHO scheme with full gradient; similar to HHO\+\_\+locvardiff but implemented using the HHOSpace module instead of the Hybrid\+Core module.
\end{DoxyItemize}

The directory {\ttfamily runs} contains BASH to run series of tests on families of meshes. The files {\ttfamily data.\+sh} describe the parameters of the test cases (polynomial degrees, boundary conditions, mesh families, etc.). The script produces results in the {\ttfamily output} directory, including a pdf file {\ttfamily rate.\+pdf} describing the rates of convergence in various energy norms.

To run the scripts as they are, you will need {\ttfamily pdflatex} and (for the LEPNC and HMM schemes) a FORTRAN compiler (adjust the {\ttfamily Makefile} to your compiler). 