<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HArD::Core2D: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HArD::Core2D
   </div>
   <div id="projectbrief">Hybrid Arbitrary Degree::Core 2D - Library to implement 2D schemes with edge and cell polynomials as unknowns</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">HArD::Core2D Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#build">Build instructions</a><ul><li class="level2"><a href="#buildlib">Building the libraries and the schemes</a></li>
<li class="level2"><a href="#doco">Building the Documentation</a></li>
</ul>
</li>
<li class="level1"><a href="#mesh">The mesh</a><ul><li class="level2"><a href="#meshpple">Principles</a></li>
<li class="level2"><a href="#loading_mesh">Loading a mesh</a></li>
</ul>
</li>
<li class="level1"><a href="#hybridcore">The HybridCore structure</a><ul><li class="level2"><a href="#init_core">Initialising the HybridCore structure</a></li>
<li class="level2"><a href="#basis">Polynomial basis functions</a></li>
<li class="level2"><a href="#integrate_mesh">Integration over cells and edges</a></li>
<li class="level2"><a href="#quad_rules">Quadrature rules</a></li>
</ul>
</li>
<li class="level1"><a href="#schemes">Schemes</a></li>
</ul>
</div>
<div class="textblock"><p>HArD::Core (sources: <a href="http://users.monash.edu/~jdroniou/releases/">http://users.monash.edu/~jdroniou/releases/</a>) provides a suite of tools, in C++, to implement numerical schemes whose unknowns are polynomials in the cells and on the edges (in 2D) or faces (in 3D). The focus is on dealing on generic polytopal meshes. This documentation addresses the 2D version of HArD::Core, but similar principles are valid for the 3D version.</p>
<ul>
<li><a href="#build">Build instructions</a> &ndash; How to build the libraries and the schemes.</li>
<li><a href="#mesh">The mesh structure</a> &ndash; The principles of the data structure representing the mesh, and how to load a mesh.</li>
<li><a href="#hybridcore">The HybridCore structure</a> &ndash; How to use the <a class="el" href="classHArDCore2D_1_1HybridCore.html">HybridCore</a> structure to compute integrals on the cells and faces of the mesh, and how to use the polynomial basis functions.</li>
<li><a href="#schemes">Schemes</a> &ndash; The list of schemes currently implemented in HArD::Core2D, and scripts to run them.</li>
</ul>
<p><a class="anchor" id="build"></a> </p>
<h1><a class="anchor" id="build"></a>
Build instructions</h1>
<h2><a class="anchor" id="buildlib"></a>
Building the libraries and the schemes</h2>
<p>To build the libraries and implemented schemes, the minimal requirements are:</p>
<ul>
<li>CMake version 2.6 or above (<a href="https://cmake.org/">https://cmake.org/</a>)</li>
<li>A C++ compiler that supports the C++14 standard, eg. GCC (<a href="https://gcc.gnu.org/">https://gcc.gnu.org/</a>) or Clang (<a href="https://clang.llvm.org/">https://clang.llvm.org/</a>)</li>
<li>Eigen C++ library, version 3.3 or above (<a href="http://eigen.tuxfamily.org/">http://eigen.tuxfamily.org/</a>)</li>
<li>The follwing Boost C++ libraries (<a href="http://www.boost.org/">http://www.boost.org/</a>): filesystem, program options, timer, chrono.</li>
</ul>
<p>Make sure that you have the development version of boost installed. On Linux, install <code>libboost-dev</code>, <code>libboost-filesystem-dev</code>, <code>libboost-program-options-dev</code>, <code>libboost-chrono-dev</code> and <code>libboost-timer-dev</code> from your package manager.</p>
<p>The linear systems resulting from the assembled scheme are solved using the BiCGStab implementation of Eigen. An alternative (currently commented out in the schemes' implementations) is to use the MA41 solver of the HSL library. To use this alternative you will need:</p>
<ul>
<li>BLAS (<a href="http://www.netlib.org/blas/">http://www.netlib.org/blas/</a>) and LAPACK (<a href="http://www.netlib.org/lapack/">http://www.netlib.org/lapack/</a>)</li>
<li>GFortran (<a href="https://gcc.gnu.org/wiki/GFortran">https://gcc.gnu.org/wiki/GFortran</a>)</li>
<li>HSL MA41 linear solver (<a href="http://www.hsl.rl.ac.uk/catalogue/ma41.html">http://www.hsl.rl.ac.uk/catalogue/ma41.html</a>)</li>
</ul>
<p>Once you have installed all of the required dependencies, set up the build directory and generate the build files by running the following from the repository root:</p>
<div class="fragment"><div class="line">mkdir build</div><div class="line">cd build</div><div class="line">cmake ..</div><div class="line">make</div></div><!-- fragment --><p>After this, <code>build/Schemes</code> will contain the executables (e.g. <code>hho-diffusion</code>) to run the schemes. These executable need to access the typ2 meshes, which they should naturally find if you put the <code>typ2_meshes</code> directory at the root of the project's files.</p>
<h2><a class="anchor" id="doco"></a>
Building the Documentation</h2>
<p>The mesh documentation is built with Doxygen (<a href="http://www.stack.nl/~dimitri/doxygen/">http://www.stack.nl/~dimitri/doxygen/</a>). If you are reading this then somebody has already built it for you. If you modify the code and wish to rebuild the documentation, simply run <code>doxygen</code> from the root directory. The HTML version of the documentation is generated inside <code>documentation/html</code> and the LaTeX version is generated inside <code>documentation/latex</code> and can be compiled using the generated Makefile.</p>
<p><a class="anchor" id="mesh"></a> </p>
<h1><a class="anchor" id="mesh"></a>
The mesh</h1>
<h2><a class="anchor" id="meshpple"></a>
Principles</h2>
<p>After it is loaded, the mesh is represented by classes describing a vertex, an edge, and a cell: <a class="el" href="classHArDCore2D_1_1Vertex.html">Vertex</a>, <a class="el" href="classHArDCore2D_1_1Edge.html">Edge</a>, and <a class="el" href="classHArDCore2D_1_1Cell.html">Cell</a>. Each of these classes contains methods to access useful information for the corresponding element, including other geometrical quantities it is related to. The mesh itself is represented by an element of the <a class="el" href="classHArDCore2D_1_1Mesh.html">Mesh</a> class with methods to access all the vertices, edges and cells (or a particular vertex, edge or cell). In this class, each cell has a unique identifier, numbered from 0.</p>
<p>For example, if <code>mesh_ptr</code> is a pointer to a Mesh class, the lines </p><div class="fragment"><div class="line">Vertex* vertex = mesh_ptr-&gt;vertex(5);</div><div class="line"></div><div class="line">Eigen::Vector2d vert_coord = vertex-&gt;coords()</div></div><!-- fragment --><p> store the coordinates of the fifth vertex into the Eigen vector vert_coord. As a generic rule, all geometrical vectors are <code>Eigen::Vector2d</code>. We also use <code>Eigen::Vector{2,X}d</code> and <code>Eigen::Matrix{2,X}d</code> for objects on which linear algebraic operations are performed. Lists (e.g. of cells, of functions...) are instances of <code>std::vector&lt;...&gt;</code>. Finally, <code>Eigen::Array</code> is used for lists on which component-wise operators are performed (typically, values of some functions at the quadrature nodes, that will be multiplied component-wise by the corresponding quadrature weights and then summed together).</p>
<p>Here is an example that loops over all cells, grabs all the edges of the cell, and loops over these edges to output their length. Here, <code>mesh_ptr</code> is a pointer to the mesh.</p>
<div class="fragment"><div class="line"><span class="comment">// Loop over all cells of the mesh</span></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> iC = 0; iC &lt; mesh_ptr-&gt;n_cells() iC++) {</div><div class="line"></div><div class="line">    <span class="comment">// We grab the edges of the iC-th cell</span></div><div class="line">    std::vector&lt;Edge *&gt; edges = mesh_ptr-&gt;cell(iC)-&gt;get_edges();</div><div class="line"></div><div class="line">    <span class="comment">// Loop over the edges of the cell</span></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> ilE = 0; ilE &lt; cell-&gt;n_edges(); ilE++) {</div><div class="line"></div><div class="line">        <span class="comment">// Write the edge length on the standard output</span></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;The length of edge &quot;</span> &lt;&lt; ilE+1 &lt;&lt; <span class="stringliteral">&quot; in cell &quot;</span> &lt;&lt; iC+1 &lt;&lt; <span class="stringliteral">&quot; is: &quot;</span> &lt;&lt; edges(ilE)-&gt;measure() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p>The mesh classes and other auxilliary classes are located inside the namespace HArDCore2D.</p>
<p>There is no direct access from a high-level geometrical entity to elements purely associated with lower-level entities. For example, if <code>mesh_ptr</code> is a pointer to the mesh, there is no direct method to access the coordinates of the i-th vertex of the mesh (no <code>mesh_ptr-&gt;coords_vertex()</code> exists). Instead, this is done through <code>mesh_ptr-&gt;vertex(i)-&gt;coords()</code>. This choice is deliberate as it preserves the logical organisation of the data structure, and facilitates the memorisation of the various methods. Of course, writing a wrapper providing a direct access is easy...</p>
<h2><a class="anchor" id="loading_mesh"></a>
Loading a mesh</h2>
<p>HArDCore2D can currently read meshes in the <code>typ2</code> format designed for the FVCA5 Benchmark. A short documentation describing this format is provided in the <code>typ2_meshes</code> directory (see README.pdf there). Several meshes can also be found in this directory.</p>
<p>A mesh file must be read using an instance of the <code>MeshReaderTyp2</code> class, and then built using <code>MeshBuilder</code>. A working example is given below (assuming the executable will be in <code>build/Schemes</code> for example).</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;mesh.hpp&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;import_mesh.hpp&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;mesh_builder.hpp&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceHArDCore2D.html">HArDCore2D</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line"></div><div class="line">    <span class="comment">// Mesh file to read</span></div><div class="line">    std::string mesh_file = <span class="stringliteral">&quot;../../typ2_meshes/cart5x5.typ2&quot;</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Read the mesh file</span></div><div class="line">    <a class="code" href="classHArDCore2D_1_1MeshReaderTyp2.html">MeshReaderTyp2</a> mesh(mesh_file);</div><div class="line">    std::vector&lt;std::vector&lt;double&gt; &gt; vertices;</div><div class="line">    std::vector&lt;std::vector&lt;size_t&gt; &gt; cells;</div><div class="line">    std::vector&lt;std::vector&lt;double&gt; &gt; centers;</div><div class="line">    <span class="keywordflow">if</span> (mesh.read_mesh(vertices, cells, centers) == <span class="keyword">false</span>) {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Could not open file&quot;</span> &lt;&lt; std::endl;</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">    };</div><div class="line">    <span class="comment">// Build the mesh</span></div><div class="line">    <a class="code" href="classHArDCore2D_1_1MeshBuilder.html">MeshBuilder</a>* builder = <span class="keyword">new</span> <a class="code" href="classHArDCore2D_1_1MeshBuilder.html">MeshBuilder</a>();</div><div class="line">    std::unique_ptr&lt;Mesh&gt; mesh_ptr = builder-&gt;<a class="code" href="classHArDCore2D_1_1MeshBuilder.html#a0ef4a78ac64d1bcb6380317ea866758d">build_the_mesh</a>(vertices, cells);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;There are &quot;</span> &lt;&lt; mesh_ptr-&gt;n_cells() &lt;&lt; <span class="stringliteral">&quot; cells in the mesh.\n&quot;</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Create an HybridCore instance</span></div><div class="line">    <a class="code" href="classHArDCore2D_1_1HybridCore.html">HybridCore</a> hho(mesh_ptr.get(), 1, 1);</div><div class="line">}</div></div><!-- fragment --><p>Note that the builder returns a <code>unique_ptr</code> for the mesh. This ensures that, at the end of the code, the mesh destructor is called (which destroys all cells, edges, vertices...). Classes and functions use a raw pointer to the mesh, so the <code>.get()</code> method should be used when passing the mesh as argument to the class constructors or functions (see the <code>HybridCore</code> example above).</p>
<p><em>Note</em>: the <code>typ2</code> format allows for meshes with very generic polygonal cells, including non-convex cells. However, the builder assumes that each cell is star-shaped with respect to the isobarycenter of its vertices &ndash; otherwise, the calculation of the center of mass may be incorrect. Similarly, the quadrature rules (see <a href="#quad_rules">Quadrature rules</a>) assume that each cell is star-shaped with respect to its center of mass.</p>
<p><a class="anchor" id="hybridcore"></a> </p>
<h1><a class="anchor" id="hybridcore"></a>
The HybridCore structure</h1>
<p>The <a class="el" href="classHArDCore2D_1_1HybridCore.html">HybridCore</a> structure encapsulates routines to create bases of polynomial spaces in each cell and on each edge, to integrate functions on these mesh entities, and to evaluate functions defined through their coefficients on the cell and edge basis functions. Start by including the structure as follows:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;hybridcore.hpp&quot;</span></div></div><!-- fragment --><h2><a class="anchor" id="init_core"></a>
Initialising the HybridCore structure</h2>
<p>To initialise a <a class="el" href="classHArDCore2D_1_1HybridCore.html">HybridCore</a> structure, we must first have a mesh loaded as a pointer (see <a href="#loading_mesh">loading a mesh</a>). The structure is then created by specifying the desired degree of the polynomial spaces on the edges and in the cells.</p>
<div class="fragment"><div class="line"><span class="comment">// Create the HybridCore structure with polynomial degree K on the edges, and L in the cells</span></div><div class="line">  HybridCore hho(mesh_ptr, K, L);</div></div><!-- fragment --><p><a class="anchor" id="basis"></a> </p>
<h2><a class="anchor" id="basis"></a>
Polynomial basis functions</h2>
<p>Initialising the <a class="el" href="classHArDCore2D_1_1HybridCore.html">HybridCore</a> structure constructs basis functions for the polynomial spaces on the edges (up to degree <img class="formulaInl" alt="$K$" src="form_0.png"/>) and in the cells (up to degree <img class="formulaInl" alt="$(K+1)$" src="form_1.png"/>). The choice of the degree in the cells corresponds to the needs of certain high-order methods, such as the HHO method that requires the reconstruction of a polynomial of degree <img class="formulaInl" alt="$(K+1)$" src="form_1.png"/> in each cell. It is also assumed that <img class="formulaInl" alt="$L\le K+1$" src="form_2.png"/>.</p>
<p>The basis functions are accessed through the methods <a class="el" href="classHArDCore2D_1_1HybridCore.html#a34242db07cc2b3c3b867d9e4580b634d">cell_basis(iT,i)</a> and <a class="el" href="classHArDCore2D_1_1HybridCore.html#a6b4feaeef7739a2e30fcf6c601fcf721">edge_basis(iE,i)</a> which return the i-th basis function on the iT-th cell or iE-th edge. The cell gradients are available from <a class="el" href="classHArDCore2D_1_1HybridCore.html#a710fc23b914623b90a2699ab4291e539">cell_gradient(iT,i)</a>; these gradients are indexed to correspond with their basis functions, which means that the first gradient will always identically be the zero vector, since it corresponds to the constant basis function.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> &amp;phi_i = cell_basis(iT, i);</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> &amp;dphi_i = cell_gradient(iT, i);  <span class="comment">// dphi_i is the gradient of phi_i</span></div></div><!-- fragment --><p>The basis functions are hierarchical, which means that they are constructed by increasing degree. A basis of the space of polynomials of degree <img class="formulaInl" alt="$K$" src="form_0.png"/> in the cell is thus obtained by selecting the first <img class="formulaInl" alt="$(K+1)(K+2)/2$" src="form_3.png"/> cell basis functions.</p>
<p>When a scheme has polynomial unknowns of degree <img class="formulaInl" alt="$K$" src="form_0.png"/> on the edges and <img class="formulaInl" alt="$L$" src="form_4.png"/> in the cells, these unknowns can be represented as vectors of coefficients on the basis functions, for example by listing all the coefficients on the basis functions in the first cell, then all the coefficients on the basis functions in the second cell, etc., and then listing all the coefficients on the basis functions in the first edge, etc. This is the choice adopted in HHO-diffusion.</p>
<p>A number of convenient quantities relating to the basis functions are available in the <a class="el" href="classHArDCore2D_1_1HybridCore.html">HybridCore</a> structure follows.</p>
<table class="doxtable">
<tr>
<th>Symbol name </th><th>Meaning  </th></tr>
<tr>
<td><a class="el" href="group__HybridCore.html#gab698480a3a9e9339d5c191549b817501">nlocal_cell_dofs</a> </td><td>The number of degrees of freedom of a cell polynomial (ie. the dimension of the space of polynomials of degree <img class="formulaInl" alt="$\le L$" src="form_5.png"/> in two variables) </td></tr>
<tr>
<td><a class="el" href="group__HybridCore.html#ga41f1294e34e4daade19ad16981eaac15">nlocal_face_dofs</a> </td><td>The number of degrees of freedom of a face polynomial (ie. the dimension of the space of polynomials of degree <img class="formulaInl" alt="$\le K$" src="form_6.png"/> in one variable) </td></tr>
<tr>
<td><a class="el" href="group__HybridCore.html#ga57c23358c4ca7e485e8382c6b2761ad5">nhighorder_dofs</a> </td><td>The number of degrees of freedom of a degree <img class="formulaInl" alt="$(K+1)$" src="form_1.png"/> cell polynomial (ie. the dimension of the space of polynomials of degree <img class="formulaInl" alt="$\le K+1$" src="form_7.png"/> in two variables) </td></tr>
<tr>
<td><a class="el" href="group__HybridCore.html#gaffe520cbcf3d8212a503d51f11c13e5f">ngradient_dofs</a> </td><td>The dimension of the gradient space of degree <img class="formulaInl" alt="$(K+1)$" src="form_1.png"/> cell polynomials </td></tr>
<tr>
<td><a class="el" href="group__HybridCore.html#ga86e6a3566cf506821606c8802a5f2364">ntotal_cell_dofs</a> </td><td>The total number of degrees of freedom over all cell polynomials over the entire mesh (i.e. the number of cells times the dimension of the space of polynomials of degree <img class="formulaInl" alt="$\le L$" src="form_5.png"/> in two variables) </td></tr>
<tr>
<td><a class="el" href="group__HybridCore.html#gac0af0b8fa9bea07b9cfba8cbb1b50bed">ntotal_face_dofs</a> </td><td>The total number of degrees of freedom over all face polynomials over the entire mesh (i.e. the number of edges times the dimension of the space of polynomials of degree <img class="formulaInl" alt="$\le K$" src="form_6.png"/> in one variables) </td></tr>
<tr>
<td><a class="el" href="group__HybridCore.html#ga95c76303ee1dabc5c78f0bdd7a2c6aaa">ninternal_face_dofs</a> </td><td>The total number of degrees of freedom over all internal faces over the entire mesh </td></tr>
<tr>
<td><a class="el" href="group__HybridCore.html#gaf887b486ad0eea60382e306f1487b44a">ntotal_dofs</a> </td><td>The total number of cell and face degrees of freedom over the entire mesh </td></tr>
</table>
<h2><a class="anchor" id="integrate_mesh"></a>
Integration over cells and edges</h2>
<p>The <a class="el" href="classHArDCore2D_1_1HybridCore.html">HybridCore</a> structure provides routines to integrate generic functions on the cells and the edges. These routines are however expensive as they re-compute the quadrature nodes and weights every time they are called. They should therefore only be used with parsimony; computing quadrature nodes and values of basis functions at these nodes is more efficient, see <a href="#quad_rules">Quadratures rules</a>.</p>
<p>For example, to integrate <img class="formulaInl" alt="$f(x,y) = x^2 + y^2 $" src="form_8.png"/> over the cell number iT:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> integral = integrate_over_cell(iT, [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) {</div><div class="line">        <span class="keywordflow">return</span> x*x+y*y;</div><div class="line">      });</div></div><!-- fragment --><p>Basis functions can also be integrated:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; phi_i = edge_basis(iT, i);</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; phi_j = cell_basis(iT, j);</div><div class="line"><span class="keyword">auto</span> integral = hho.integrate_over_face(iT, [&amp;phi_i, &amp;phi_j](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y, <span class="keyword">auto</span> z) {</div><div class="line">  <span class="keywordflow">return</span> phi_i(x,y) * phi_j(x,y);</div><div class="line">});</div></div><!-- fragment --><h2><a class="anchor" id="quad_rules"></a>
Quadrature rules</h2>
<p>HArD::Core deals with quite arbitrary cell geometries. As a consequence, no reference element can be used, and the quadrature rules have to be adjusted to each particular cell. This is done by partitioning each cell into triangles and by using <a href="https://people.sc.fsu.edu/~jburkardt/cpp_src/triangle_dunavant_rule/triangle_dunavant_rule.html">John Burkardt's implementation of the Dunavant rules</a>. The choice was also made not to pre-compute all quadrature rules for all cells and edges, but rather to compute them &ndash; with a locally chosen degree of exactness &ndash; when needed in the code. To reduce the computational cost, quadrature rules &ndash; and the values of basis functions at quadrature nodes &ndash; should only be computed once when looping over each cell, before being used, e.g., to form mass matrices.</p>
<p>The <a class="el" href="classHArDCore2D_1_1HybridCore.html">HybridCore</a> structure provides routines to do that. The method <a class="el" href="classHArDCore2D_1_1HybridCore.html#a5d70dcda8d8a56311b2d1eac4f7d306c">cell_qrule(iT,doe)</a> calculates quadrature nodes and weights, exact up to the polynomial degree <code>doe</code> for an integration over cell number <code>iT</code>; see <a class="el" href="classHArDCore2D_1_1HybridCore.html#a4158e234143fd956fd4038adf9097bc2">edge_qrule(iE,doe)</a> for the equivalent over an edge. At present, the quadrature rules available in the code support a total degree of exactness in the cells or on the edges up to 20. This quadrature rule, stored for example in <code>quadTE</code>, is then be provided to <a class="el" href="classHArDCore2D_1_1HybridCore.html#acf453b4f239a76fe7f21b02ac91e127c">basis_quad(type,i,quadTE,deg)</a> which computes the values of the basis functions in cell/edge (depending on <code>type</code>=T or some other character) number <code>i</code> up to the specified degree <code>deg</code>; see also <a class="el" href="classHArDCore2D_1_1HybridCore.html#add794287f4bb49157a7b5f94a5ecb200">grad_basis_quad(i,quadTE,deg)</a> to compute the gradients of the basis functions at the quadrature nodes.</p>
<p>Typically, these values are then passed on to <a class="el" href="classHArDCore2D_1_1HybridCore.html#aa5c203c11a661933930a33335b0e2479">gram_matrix(f_quad,g_quad,Nf,Ng,quadTE,sym,weight)</a> which computes a ``generalised'' Gram matrix <img class="formulaInl" alt="$(\int weight*f_i*g_j)_{ij}$" src="form_9.png"/> of the families of functions <img class="formulaInl" alt="$(f_1,\ldots,f_{Nf})$" src="form_10.png"/> and <img class="formulaInl" alt="$(g_1,\ldots,g_{Ng})$" src="form_11.png"/>, provided at the quadrature notes by <code>f_quad</code> and <code>g_quad</code> (here, <code>sym</code> is a boolean indicating if the matrix is expected to be symmetric). This Gram matrix method is useful to compute mass and stiffness matrices.</p>
<p>Here is an example.</p>
<div class="fragment"><div class="line"><span class="comment">// Create quadrature rule on cell `iT`. Here, `hho` is an instance of the `HybridCore` class. The degree of </span></div><div class="line"><span class="comment">// exactness ensures that the rule will be exact for polynomial functions up to degree \f$K+L+1\f$</span></div><div class="line">std::vector&lt;HybridCore::qrule&gt; quadT = hho.cell_qrule(iT, hho.Ldeg()+hho.K()+1);</div><div class="line"></div><div class="line"><span class="comment">// Compute values of basis functions, up to degree \f$(K+1)\$, at the quadrature nodes</span></div><div class="line">std::vector&lt;Eigen::ArrayXd&gt; phi_quadT = hho.basis_quad(<span class="charliteral">&#39;T&#39;</span>, iT, quadT, hho.nhighorder_dofs());</div><div class="line"></div><div class="line"><span class="comment">// Compute values of gradients of basis functions, as well as `diff` times these gradients, at the quadrature nodes</span></div><div class="line">std::vector&lt;Eigen::ArrayXXd&gt; dphiT_quadT = hho.grad_basis_quad(iT, quadT, hho.nhighorder_dofs());</div><div class="line"></div><div class="line"><span class="comment">// Create the mass matrix of basis functions up to degree \f$L\f$ and the stiffness matrix of the gradients</span></div><div class="line"><span class="comment">// kappa is a function that returns the diffusion tensor at the considered location</span></div><div class="line">Eigen::MatrixXd MTT = hho.gram_matrix(phi_quadT, phi_quadT, hho.nlocal_cell_dofs(), hho.nhighorder_dofs(), quadT, <span class="keyword">true</span>);</div><div class="line">Eigen::MatrixXd StiffT = hho.gram_matrix(dphiT_quadT, dphiT_quadT, hho.nhighorder_dofs(), hho.nhighorder_dofs(), quadT, <span class="keyword">true</span>, kappa);</div><div class="line"></div><div class="line"><span class="comment">// Grab the global index of the first edge of cell iT, compute quadrature nodes on this edge</span></div><div class="line"><span class="keywordtype">size_t</span> iF = mesh-&gt;cell(iT)-&gt;edge(0)-&gt;global_index();</div><div class="line">std::vector&lt;HybridCore::qrule&gt; quadF = hho.edge_qrule(iF, 2*hho.K()+2);</div><div class="line"></div><div class="line"><span class="comment">// Compute the values of the cell basis function, and the edge basis function, at the quadrature nodes</span></div><div class="line"><span class="comment">// on the edge, and create the &#39;mass matrix&#39; of cell-edge basis functions on the edge</span></div><div class="line">std::vector&lt;Eigen::ArrayXd&gt; phiT_quadF = hho.basis_quad(<span class="charliteral">&#39;T&#39;</span>, iT, quadF, hho.nhighorder_dofs());</div><div class="line">std::vector&lt;Eigen::ArrayXd&gt; phiF_quadF = hho.basis_quad(<span class="charliteral">&#39;F&#39;</span>, iF, quadF, hho.nlocal_edge_dofs());</div><div class="line">Eigen::MatrixXd MFT = hho.gram_matrix(phiF_quadF, phiT_quadF, hho.nlocal_edge_dofs(), hho.nhighorder_dofs(), quadF, <span class="keyword">false</span>);</div></div><!-- fragment --><p>The quadrature rules and values of basis functions (and gradients) at the quadrature nodes can be conveniently computed and stored using the CellEdgeQuad class. Instantiating an element of this class on a cell loads these rules and values once, that can then be passed to several functions in charge of various calculations (e.g. one function computes the local cell contribution to the diffusion term, another function is in charge of computing the load term associated to the cell, etc.). This prevents recomputing these rules and values when needed by various functions. It works the following way:</p>
<div class="fragment"><div class="line"><span class="keywordtype">size_t</span> doeT = hho.Ldeg()+hho.K()+1;         <span class="comment">// degree of exactness for cell quadrature rules</span></div><div class="line"><span class="keywordtype">size_t</span> doeF = 2*hho.K()+1;                          <span class="comment">// degree of exactness for edge quadrature rules</span></div><div class="line">CellEdgeQuad celledgequad(hho, iT, doeT, doeF);     <span class="comment">// compute local quadrature rules at quadrature points in cell iT</span></div><div class="line">Eigen::MatrixXd aT = diffusion_operator(hho, iT, celledgequad);     <span class="comment">// compute local contribution to diffusion term</span></div><div class="line">Eigen::VectorXd bT = load_operator(hho, iT, celledgequad);      <span class="comment">//  compute local loading term</span></div><div class="line"></div><div class="line">(...)</div><div class="line"><span class="comment">// Function to compute local contribution to diffusion term</span></div><div class="line">Eigen::MatrixXd HHO_Diffusion::diffusion_operator(HybridCore &amp;hho, <span class="keyword">const</span> <span class="keywordtype">size_t</span> iT, <span class="keyword">const</span> CellEdgeQuad &amp;celledgequad)<span class="keyword"> const </span>{</div><div class="line"></div><div class="line">(... initialise/<span class="keywordflow">do</span> stuff ...)</div><div class="line"><span class="comment">// Cell quadrature rules and values at nodes are needed, we grab them</span></div><div class="line">std::vector&lt;HybridCore::qrule&gt; quadT = celledgequad.get_quadT();</div><div class="line">std::vector&lt;Eigen::ArrayXd&gt; phiT_quadT = celledgequad.get_phiT_quadT();</div><div class="line">std::vector&lt;Eigen::ArrayXXd&gt; dphiT_quadT = celledgequad.get_dphiT_quadT();</div><div class="line"></div><div class="line">(... the rest as in the previous example: create mass matrices, etc. ...)</div></div><!-- fragment --><p><a class="anchor" id="schemes"></a> </p>
<h1><a class="anchor" id="schemes"></a>
Schemes</h1>
<p>The following schemes are currently available in HArD::Core2D. The Hybrid High-Order schemes follow the implementation principles described in Appendix B of the book available at <a href="https://hal.archives-ouvertes.fr/hal-02151813">https://hal.archives-ouvertes.fr/hal-02151813</a>.</p>
<ul>
<li><a class="el" href="classHArDCore2D_1_1HHO__Diffusion.html">HHO_diffusion</a>: Hybrid High-Order for <img class="formulaInl" alt="$-\mathrm{div}(K\nabla u)=f$" src="form_12.png"/>, for Dirichlet or Neumann boundary conditions, with <img class="formulaInl" alt="$K$" src="form_0.png"/> a diffusion tensor that is piecewise constant on the mesh.</li>
<li><a class="el" href="classHArDCore2D_1_1HHO__LocVarDiff.html">HHO_locvardiff</a>: Hybrid High-Order for <img class="formulaInl" alt="$-\mathrm{div}(K\nabla u)=f$" src="form_12.png"/>, for Dirichlet or Neumann boundary conditions, with <img class="formulaInl" alt="$K$" src="form_0.png"/> a diffusion tensor that can vary in each cell.</li>
</ul>
<p>The directory <code>runs</code> contains BASH to run series of tests on families of meshes. The files <code>data.sh</code> describe the parameters of the test cases (polynomial degrees, boundary conditions, mesh families, etc.). The script produces results in the <code>output</code> directory, including a pdf file <code>rate.pdf</code> describing the rates of convergence in various energy norms.</p>
<p>To run the scripts as they are, you will need <code>pdflatex</code> and a FORTRAN compiler, and to adjust the <code>Makefile</code> to your compiler, to run <code>compute_rates.f90</code> and compute the rates of convergence in the various norms. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
