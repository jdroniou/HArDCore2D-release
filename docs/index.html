<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HArD::Core2D: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HArD::Core2D
   </div>
   <div id="projectbrief">Hybrid Arbitrary Degree::Core 2D - Library to implement 2D schemes with edge and cell polynomials as unknowns</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">HArD::Core2D Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#loading_mesh">Loading a mesh</a></li>
<li class="level1"><a href="#schemes">Schemes</a></li>
</ul>
</div>
<div class="textblock"><p>HArD::Core (sources: <a href="https://github.com/jdroniou/HArDCore">https://github.com/jdroniou/HArDCore</a>) provides a suite of C++ tools to implement numerical schemes whose unknowns are polynomials in the cells, on the edges, and on the faces. The focus is on dealing on generic polytopal meshes. This document addresses the 2D version of HArD::Core. The tools are similar in 2D and 3D, and we refer to the main page of documentation of the 3D version for a more thorough introduction to the library. We only present here the specific way of loading a 2D mesh structure (which differs from the 3D version), and a brief description of the schemes available in this 2D library.</p>
<p>Transferring a scheme's implementation from 3D to 2D or vice-versa is very straightforward, provided that the scheme's mathematical definition does not depend on the dimension and that the generic types provided in <code><a class="el" href="basis_8hpp_source.html">basis.hpp</a></code> are used; see README file of the HArD::Core github depository <a href="https://github.com/jdroniou/HArDCore">https://github.com/jdroniou/HArDCore</a>.</p>
<ul>
<li><a href="#mesh">Loading a 2D mesh</a> &ndash; How to load a mesh.</li>
<li><a href="#schemes">Schemes</a> &ndash; The list of schemes currently implemented in HArD::Core2D, and scripts to run them.</li>
</ul>
<p><a class="anchor" id="mesh"></a> </p>
<h1><a class="anchor" id="loading_mesh"></a>
Loading a mesh</h1>
<p>HArDCore2D currently reads meshes in the <code>typ2</code> format designed for the <a href="https://www.i2m.univ-amu.fr/fvca5/benchmark/index.html">FVCA5 Benchmark</a>. A short documentation describing this format is provided in the <code>typ2_meshes</code> directory (see README.pdf therein). Several meshes can also be found in this directory.</p>
<p>A mesh file must be read using an instance of the <code>MeshReaderTyp2</code> class, and then built using <code>MeshBuilder</code>. A working example is given below (assuming the executable will be in <code>build/Schemes</code> for example).</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;mesh.hpp&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;import_mesh.hpp&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;mesh_builder.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>HArDCore2D;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Build mesh</span></div>
<div class="line">  <a class="code" href="classHArDCore2D_1_1MeshBuilder.html">MeshBuilder</a> builder = <a class="code" href="classHArDCore2D_1_1MeshBuilder.html">MeshBuilder</a>(mesh_file);</div>
<div class="line">  std::unique_ptr&lt;Mesh&gt; mesh_ptr = builder.<a class="code" href="group__Mesh.html#ga0ef4a78ac64d1bcb6380317ea866758d">build_the_mesh</a>();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Get the BC and re-order the edges (useful to set BC for hybrid schemes)</span></div>
<div class="line">  std::string bc_id = vm[<span class="stringliteral">&quot;bc_id&quot;</span>].as&lt;std::string&gt;();</div>
<div class="line">  <a class="code" href="classBoundaryConditions.html">BoundaryConditions</a> BC(bc_id, *mesh_ptr.get());</div>
<div class="line">  BC.reorder_edges();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create an HybridCore instance</span></div>
<div class="line">  <a class="code" href="classHArDCore2D_1_1HybridCore.html">HybridCore</a> hho(mesh_ptr.get(), K+1, K, use_threads, output);</div>
<div class="line">}</div>
</div><!-- fragment --><p><em>Note</em>: the <code>typ2</code> format allows for meshes with very generic polygonal cells, including non-convex cells. However, the builder assumes that each cell is star-shaped with respect to the isobarycenter of its vertices &ndash; otherwise, the calculation of the center of mass may be incorrect. Similarly, the quadrature rules assume that each cell is star-shaped with respect to its center of mass.</p>
<p><a class="anchor" id="schemes"></a> </p>
<h1><a class="anchor" id="schemes"></a>
Schemes</h1>
<p>The following schemes are currently available in HArD::Core2D. The Hybrid High-Order schemes follow the implementation principles described in Appendix B of the book available at <a href="https://hal.archives-ouvertes.fr/hal-02151813">https://hal.archives-ouvertes.fr/hal-02151813</a>.</p>
<ul>
<li><a class="el" href="group__HHO__Diffusion.html">HHO_diffusion</a>: Hybrid High-Order (HHO) for <img class="formulaInl" alt="$-\mathrm{div}(K\nabla u)=f$" src="form_0.png"/>, for Dirichlet, Neumann or mixed boundary conditions, with <img class="formulaInl" alt="$K$" src="form_1.png"/> a diffusion tensor that is piecewise constant on the mesh.</li>
<li><a class="el" href="group__HHO__LocVarDiff.html">HHO_locvardiff</a>: HHO for <img class="formulaInl" alt="$-\mathrm{div}(K\nabla u)=f$" src="form_0.png"/>, for Dirichlet, Neumann or mixed boundary conditions, with <img class="formulaInl" alt="$K$" src="form_1.png"/> a diffusion tensor that can vary in each cell.</li>
<li><a class="el" href="group__HHO__DiffAdvecReac.html">HHO_diffadvecreac</a>: Hybrid High-Order (HHO) for <img class="formulaInl" alt="$-\mathrm{div}(K\nabla u+\beta u)+\mu u=f$" src="form_2.png"/>, for Dirichlet or mixed boundary conditions, with <img class="formulaInl" alt="$K$" src="form_1.png"/> a diffusion tensor that is piecewise constant on the mesh.</li>
<li><a class="el" href="classHArDCore2D_1_1LEPNC__StefanPME.html">LEPNC_StefanPME</a>, in module <a class="el" href="group__LEPNC.html">LEPNC</a>: Locally Enriched Polytopal Non-Conforming (LEPNC) method for the stationnary Stefan/PME problem <img class="formulaInl" alt="$u-\mathrm{div}(K\nabla\zeta(u))=f$" src="form_3.png"/>.</li>
<li><a class="el" href="classHArDCore2D_1_1LEPNC__StefanPME__Transient.html">LEPNC_StefanPME_Transient</a>, in module <a class="el" href="group__LEPNC.html">LEPNC</a>: LEPNC for the transient Stefan/PME problem <img class="formulaInl" alt="$\partial_t u-\mathrm{div}(K\nabla\zeta(u))=f$" src="form_4.png"/>.</li>
<li><a class="el" href="classHArDCore2D_1_1HMM__StefanPME__Transient.html">HMM_StefanPME_Transient</a>, in module <a class="el" href="group__HMM.html">HMM</a>: Hybrid Mimetic Mixed (HMM) method for the transient Stefan/PME problem <img class="formulaInl" alt="$\partial_t u-\mathrm{div}(K\nabla\zeta(u))=f$" src="form_4.png"/>.</li>
</ul>
<p>The directory <code>runs</code> contains BASH to run series of tests on families of meshes. The files <code>data.sh</code> describe the parameters of the test cases (polynomial degrees, boundary conditions, mesh families, etc.). The script produces results in the <code>output</code> directory, including a pdf file <code>rate.pdf</code> describing the rates of convergence in various energy norms.</p>
<p>To run the scripts as they are, you will need <code>pdflatex</code> and (for the LEPNC and HMM schemes) a FORTRAN compiler (adjust the <code>Makefile</code> to your compiler). </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<div class="ttc" id="agroup__Mesh_html_ga0ef4a78ac64d1bcb6380317ea866758d"><div class="ttname"><a href="group__Mesh.html#ga0ef4a78ac64d1bcb6380317ea866758d">HArDCore2D::MeshBuilder::build_the_mesh</a></div><div class="ttdeci">std::unique_ptr&lt; Mesh &gt; build_the_mesh(std::vector&lt; std::vector&lt; double &gt; &gt; vertices, std::vector&lt; std::vector&lt; size_t &gt; &gt; cells)</div><div class="ttdoc">construct the connectivity in the mesh</div><div class="ttdef"><b>Definition:</b> mesh_builder.cpp:14</div></div>
<div class="ttc" id="aclassHArDCore2D_1_1HybridCore_html"><div class="ttname"><a href="classHArDCore2D_1_1HybridCore.html">HArDCore2D::HybridCore</a></div><div class="ttdef"><b>Definition:</b> hybridcore.hpp:167</div></div>
<div class="ttc" id="aclassHArDCore2D_1_1MeshBuilder_html"><div class="ttname"><a href="classHArDCore2D_1_1MeshBuilder.html">HArDCore2D::MeshBuilder</a></div><div class="ttdoc">The MeshBuilder class provides build tools to create a full mesh with all connectivities.</div><div class="ttdef"><b>Definition:</b> mesh_builder.hpp:32</div></div>
<div class="ttc" id="aclassBoundaryConditions_html"><div class="ttname"><a href="classBoundaryConditions.html">BoundaryConditions</a></div><div class="ttdoc">The BoundaryConditions class provides definition of boundary conditions.</div><div class="ttdef"><b>Definition:</b> BoundaryConditions.hpp:43</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
