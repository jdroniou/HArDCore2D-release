<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HArD::Core2D: Basis</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HArD::Core2D
   </div>
   <div id="projectbrief">Hybrid Arbitrary Degree::Core 2D - Library to implement 2D schemes with edge and cell polynomials as unknowns</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#enumval-members">Enumerator</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Basis</div>  </div>
</div><!--header-->
<div class="contents">

<p>Classes and functions for polynomial basis creation and manipulation.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHArDCore2D_1_1MonomialPowers.html">HArDCore2D::MonomialPowers&lt; GeometricSupport &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute vectors listing the powers of monomial basis functions (for a cell, only this specialization is relevant) up to a certain degree.  <a href="structHArDCore2D_1_1MonomialPowers.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHArDCore2D_1_1MonomialPowers_3_01Cell_01_4.html">HArDCore2D::MonomialPowers&lt; Cell &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1MonomialScalarBasisCell.html">HArDCore2D::MonomialScalarBasisCell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar monomial basis on a cell.  <a href="classHArDCore2D_1_1MonomialScalarBasisCell.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1MonomialScalarBasisEdge.html">HArDCore2D::MonomialScalarBasisEdge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar monomial basis on an edge.  <a href="classHArDCore2D_1_1MonomialScalarBasisEdge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1Family.html">HArDCore2D::Family&lt; BasisType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1TensorizedVectorFamily.html">HArDCore2D::TensorizedVectorFamily&lt; ScalarFamilyType, N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector family obtained by tensorization of a scalar family.  <a href="classHArDCore2D_1_1TensorizedVectorFamily.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1MatrixFamily.html">HArDCore2D::MatrixFamily&lt; ScalarFamilyType, N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix family obtained from a scalar family.  <a href="classHArDCore2D_1_1MatrixFamily.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1TangentFamily.html">HArDCore2D::TangentFamily&lt; ScalarFamilyType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector family for polynomial functions that are tangent to an edge (determined by the generator)  <a href="classHArDCore2D_1_1TangentFamily.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1ShiftedBasis.html">HArDCore2D::ShiftedBasis&lt; BasisType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a basis where the function indices are shifted.  <a href="classHArDCore2D_1_1ShiftedBasis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1RestrictedBasis.html">HArDCore2D::RestrictedBasis&lt; BasisType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a basis restricted to the first "dimension" functions.  <a href="classHArDCore2D_1_1RestrictedBasis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1GradientBasis.html">HArDCore2D::GradientBasis&lt; BasisType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basis for the space of gradients of polynomials.  <a href="classHArDCore2D_1_1GradientBasis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1CurlBasis.html">HArDCore2D::CurlBasis&lt; BasisType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basis for the space of curls (vectorial rot) of polynomials.  <a href="classHArDCore2D_1_1CurlBasis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1RolyComplBasisCell.html">HArDCore2D::RolyComplBasisCell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basis for the complement R^{c,k}(T) in P^k(T)^2 of the range of the vectorial rotational on a face.  <a href="classHArDCore2D_1_1RolyComplBasisCell.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1GolyComplBasisCell.html">HArDCore2D::GolyComplBasisCell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basis for the complement G^{c,k}(T) in P^k(F)^2 of the range of the gradient on a face.  <a href="classHArDCore2D_1_1GolyComplBasisCell.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHArDCore2D_1_1detail_1_1basis__evaluation__traits.html">HArDCore2D::detail::basis_evaluation_traits&lt; BasisType, BasisFunction &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basis evaluation traits. Only specialization of 'BasisFunction' (=Function, Gradient, Curl or Divergence) are relevant, and determines what kind of value we want to evaluate.  <a href="structHArDCore2D_1_1detail_1_1basis__evaluation__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHArDCore2D_1_1detail_1_1basis__evaluation__traits_3_01BasisType_00_01Function_01_4.html">HArDCore2D::detail::basis_evaluation_traits&lt; BasisType, Function &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHArDCore2D_1_1detail_1_1basis__evaluation__traits_3_01BasisType_00_01Gradient_01_4.html">HArDCore2D::detail::basis_evaluation_traits&lt; BasisType, Gradient &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHArDCore2D_1_1detail_1_1basis__evaluation__traits_3_01BasisType_00_01Curl_01_4.html">HArDCore2D::detail::basis_evaluation_traits&lt; BasisType, Curl &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHArDCore2D_1_1detail_1_1basis__evaluation__traits_3_01BasisType_00_01Divergence_01_4.html">HArDCore2D::detail::basis_evaluation_traits&lt; BasisType, Divergence &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHArDCore2D_1_1detail_1_1basis__evaluation__traits_3_01TensorizedVectorFamily_3_01ScalarBas627650c20ab630e5c0556c2092847348.html">HArDCore2D::detail::basis_evaluation_traits&lt; TensorizedVectorFamily&lt; ScalarBasisType, N &gt;, Function &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHArDCore2D_1_1detail_1_1basis__evaluation__traits_3_01TensorizedVectorFamily_3_01ScalarBas69e65344def2843597d7b9dee040221a.html">HArDCore2D::detail::basis_evaluation_traits&lt; TensorizedVectorFamily&lt; ScalarBasisType, N &gt;, Gradient &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHArDCore2D_1_1detail_1_1basis__evaluation__traits_3_01TensorizedVectorFamily_3_01ScalarBasd31a2a2e033dc1a2d8bfb1bebdbae788.html">HArDCore2D::detail::basis_evaluation_traits&lt; TensorizedVectorFamily&lt; ScalarBasisType, N &gt;, Curl &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHArDCore2D_1_1detail_1_1basis__evaluation__traits_3_01TensorizedVectorFamily_3_01ScalarBase4be975204623d9c87fef8e9fa91274e.html">HArDCore2D::detail::basis_evaluation_traits&lt; TensorizedVectorFamily&lt; ScalarBasisType, N &gt;, Divergence &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHArDCore2D_1_1detail_1_1basis__evaluation__traits_3_01MatrixFamily_3_01ScalarBasisType_00_01N_01_4_00_01Function_01_4.html">HArDCore2D::detail::basis_evaluation_traits&lt; MatrixFamily&lt; ScalarBasisType, N &gt;, Function &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHArDCore2D_1_1detail_1_1basis__evaluation__traits_3_01MatrixFamily_3_01ScalarBasisType_00_01N_01_4_00_01Divergence_01_4.html">HArDCore2D::detail::basis_evaluation_traits&lt; MatrixFamily&lt; ScalarBasisType, N &gt;, Divergence &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHArDCore2D_1_1evaluate__quad.html">HArDCore2D::evaluate_quad&lt; BasisFunction &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a basis at quadrature nodes. 'BasisFunction' (=Function, Gradient, Curl or Divergence) determines what kind of value we want to evaluate.  <a href="structHArDCore2D_1_1evaluate__quad.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga7f900870c2d2fad52b58a784576b2bfc"><td class="memItemLeft" align="right" valign="top"><a id="ga7f900870c2d2fad52b58a784576b2bfc"></a>
typedef Eigen::Matrix2d&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::MatrixRd</b></td></tr>
<tr class="separator:ga7f900870c2d2fad52b58a784576b2bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b59ab7a013fef73321867484e13e2f3"><td class="memItemLeft" align="right" valign="top"><a id="ga2b59ab7a013fef73321867484e13e2f3"></a>
typedef Eigen::Vector2d&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::VectorRd</b></td></tr>
<tr class="separator:ga2b59ab7a013fef73321867484e13e2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bc880baa1a6163014c7f37345bf8ac6"><td class="memItemLeft" align="right" valign="top"><a id="ga2bc880baa1a6163014c7f37345bf8ac6"></a>
typedef Eigen::Vector2i&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::VectorZd</b></td></tr>
<tr class="separator:ga2bc880baa1a6163014c7f37345bf8ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41970d25ff5ffdc77e1368ee5ce03bd4"><td class="memTemplParams" colspan="2"><a id="ga41970d25ff5ffdc77e1368ee5ce03bd4"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga41970d25ff5ffdc77e1368ee5ce03bd4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga41970d25ff5ffdc77e1368ee5ce03bd4">HArDCore2D::BasisQuad</a> = boost::multi_array&lt; T, 2 &gt;</td></tr>
<tr class="memdesc:ga41970d25ff5ffdc77e1368ee5ce03bd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">type for a family of basis functions evaluated on quadrature nodes <br /></td></tr>
<tr class="separator:ga41970d25ff5ffdc77e1368ee5ce03bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1e36fbf129c707351e533ee43579432"><td class="memTemplParams" colspan="2"><a id="gab1e36fbf129c707351e533ee43579432"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab1e36fbf129c707351e533ee43579432"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Basis.html#gab1e36fbf129c707351e533ee43579432">HArDCore2D::FType</a> = std::function&lt; T(const VectorRd &amp;)&gt;</td></tr>
<tr class="memdesc:gab1e36fbf129c707351e533ee43579432"><td class="mdescLeft">&#160;</td><td class="mdescRight">type for function of point. T is the type of value of the function <br /></td></tr>
<tr class="separator:gab1e36fbf129c707351e533ee43579432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a3ca323e3bd9968a90e8e3f9a3a6863"><td class="memItemLeft" align="right" valign="top"><a id="ga9a3ca323e3bd9968a90e8e3f9a3a6863"></a>
typedef double&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::MonomialScalarBasisCell::FunctionValue</b></td></tr>
<tr class="separator:ga9a3ca323e3bd9968a90e8e3f9a3a6863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad052f1f44cea110341eb1f86c2b732a9"><td class="memItemLeft" align="right" valign="top"><a id="gad052f1f44cea110341eb1f86c2b732a9"></a>
typedef VectorRd&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::MonomialScalarBasisCell::GradientValue</b></td></tr>
<tr class="separator:gad052f1f44cea110341eb1f86c2b732a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffa9f1b9379558ebef24a3a0d99ef3fd"><td class="memItemLeft" align="right" valign="top"><a id="gaffa9f1b9379558ebef24a3a0d99ef3fd"></a>
typedef VectorRd&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::MonomialScalarBasisCell::CurlValue</b></td></tr>
<tr class="separator:gaffa9f1b9379558ebef24a3a0d99ef3fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b25ab56ff038e78ea0f27fb1b1082f2"><td class="memItemLeft" align="right" valign="top"><a id="ga1b25ab56ff038e78ea0f27fb1b1082f2"></a>
typedef double&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::MonomialScalarBasisCell::DivergenceValue</b></td></tr>
<tr class="separator:ga1b25ab56ff038e78ea0f27fb1b1082f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga524ce4487f4f5163950b88a63d8e4025"><td class="memItemLeft" align="right" valign="top"><a id="ga524ce4487f4f5163950b88a63d8e4025"></a>
typedef <a class="el" href="classHArDCore2D_1_1Cell.html">Cell</a>&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::MonomialScalarBasisCell::GeometricSupport</b></td></tr>
<tr class="separator:ga524ce4487f4f5163950b88a63d8e4025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf889760ab19dd5bd19e8780fe4378d25"><td class="memItemLeft" align="right" valign="top"><a id="gaf889760ab19dd5bd19e8780fe4378d25"></a>
typedef double&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::MonomialScalarBasisEdge::FunctionValue</b></td></tr>
<tr class="separator:gaf889760ab19dd5bd19e8780fe4378d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac660ec4df6c23e7d383d2ccc5f06935b"><td class="memItemLeft" align="right" valign="top"><a id="gac660ec4df6c23e7d383d2ccc5f06935b"></a>
typedef VectorRd&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::MonomialScalarBasisEdge::GradientValue</b></td></tr>
<tr class="separator:gac660ec4df6c23e7d383d2ccc5f06935b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e51387f5ec1db65ed5f6a744026a6a2"><td class="memItemLeft" align="right" valign="top"><a id="ga0e51387f5ec1db65ed5f6a744026a6a2"></a>
typedef VectorRd&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::MonomialScalarBasisEdge::CurlValue</b></td></tr>
<tr class="separator:ga0e51387f5ec1db65ed5f6a744026a6a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ddce9d9620387e1273d1f71f7cd4f8f"><td class="memItemLeft" align="right" valign="top"><a id="ga9ddce9d9620387e1273d1f71f7cd4f8f"></a>
typedef double&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::MonomialScalarBasisEdge::DivergenceValue</b></td></tr>
<tr class="separator:ga9ddce9d9620387e1273d1f71f7cd4f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf296f0d9a155a2d4599512f96b3967cf"><td class="memItemLeft" align="right" valign="top"><a id="gaf296f0d9a155a2d4599512f96b3967cf"></a>
typedef <a class="el" href="classHArDCore2D_1_1Edge.html">Edge</a>&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::MonomialScalarBasisEdge::GeometricSupport</b></td></tr>
<tr class="separator:gaf296f0d9a155a2d4599512f96b3967cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga152a59e1b0aa753e65bb6553be665bdd"><td class="memItemLeft" align="right" valign="top"><a id="ga152a59e1b0aa753e65bb6553be665bdd"></a>
typedef BasisType::FunctionValue&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::Family&lt; BasisType &gt;::FunctionValue</b></td></tr>
<tr class="separator:ga152a59e1b0aa753e65bb6553be665bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga063c30fe4fcd2174052072b1e255e7b3"><td class="memItemLeft" align="right" valign="top"><a id="ga063c30fe4fcd2174052072b1e255e7b3"></a>
typedef BasisType::GradientValue&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::Family&lt; BasisType &gt;::GradientValue</b></td></tr>
<tr class="separator:ga063c30fe4fcd2174052072b1e255e7b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabeb4fac2009a5491c66a9f426b372b32"><td class="memItemLeft" align="right" valign="top"><a id="gabeb4fac2009a5491c66a9f426b372b32"></a>
typedef VectorRd&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::Family&lt; BasisType &gt;::CurlValue</b></td></tr>
<tr class="separator:gabeb4fac2009a5491c66a9f426b372b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26b41c8bd34a7bbd4543f931c27d7115"><td class="memItemLeft" align="right" valign="top"><a id="ga26b41c8bd34a7bbd4543f931c27d7115"></a>
typedef double&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::Family&lt; BasisType &gt;::DivergenceValue</b></td></tr>
<tr class="separator:ga26b41c8bd34a7bbd4543f931c27d7115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25780d2074b4184b02f14aed12cb7bd1"><td class="memItemLeft" align="right" valign="top"><a id="ga25780d2074b4184b02f14aed12cb7bd1"></a>
typedef BasisType::GeometricSupport&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::Family&lt; BasisType &gt;::GeometricSupport</b></td></tr>
<tr class="separator:ga25780d2074b4184b02f14aed12cb7bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55ec3e0805c4dd4a6758a94d04924520"><td class="memItemLeft" align="right" valign="top"><a id="ga55ec3e0805c4dd4a6758a94d04924520"></a>
typedef Eigen::Matrix&lt; double, N, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::TensorizedVectorFamily&lt; ScalarFamilyType, N &gt;::FunctionValue</b></td></tr>
<tr class="separator:ga55ec3e0805c4dd4a6758a94d04924520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03e55037df352b512c181687d4526b11"><td class="memItemLeft" align="right" valign="top"><a id="ga03e55037df352b512c181687d4526b11"></a>
typedef Eigen::Matrix&lt; double, N, dimspace &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::TensorizedVectorFamily&lt; ScalarFamilyType, N &gt;::GradientValue</b></td></tr>
<tr class="separator:ga03e55037df352b512c181687d4526b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88c7890d4b589d1e2cbe582445e638bb"><td class="memItemLeft" align="right" valign="top"><a id="ga88c7890d4b589d1e2cbe582445e638bb"></a>
typedef VectorRd&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::TensorizedVectorFamily&lt; ScalarFamilyType, N &gt;::CurlValue</b></td></tr>
<tr class="separator:ga88c7890d4b589d1e2cbe582445e638bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1dda1064d631768943c7658d2e69edd"><td class="memItemLeft" align="right" valign="top"><a id="gab1dda1064d631768943c7658d2e69edd"></a>
typedef double&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::TensorizedVectorFamily&lt; ScalarFamilyType, N &gt;::DivergenceValue</b></td></tr>
<tr class="separator:gab1dda1064d631768943c7658d2e69edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1c8c80da131a654a1a91a43e379cc57"><td class="memItemLeft" align="right" valign="top"><a id="gad1c8c80da131a654a1a91a43e379cc57"></a>
typedef ScalarFamilyType::GeometricSupport&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::TensorizedVectorFamily&lt; ScalarFamilyType, N &gt;::GeometricSupport</b></td></tr>
<tr class="separator:gad1c8c80da131a654a1a91a43e379cc57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabacacf4726893d73cd761a25b99e163a"><td class="memItemLeft" align="right" valign="top"><a id="gabacacf4726893d73cd761a25b99e163a"></a>
typedef Eigen::Matrix&lt; double, N, N &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::MatrixFamily&lt; ScalarFamilyType, N &gt;::FunctionValue</b></td></tr>
<tr class="separator:gabacacf4726893d73cd761a25b99e163a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga441e6bba24d66ea1bef6dcba8c563ba7"><td class="memItemLeft" align="right" valign="top"><a id="ga441e6bba24d66ea1bef6dcba8c563ba7"></a>
typedef Eigen::Matrix&lt; double, N, N *dimspace &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::MatrixFamily&lt; ScalarFamilyType, N &gt;::GradientValue</b></td></tr>
<tr class="separator:ga441e6bba24d66ea1bef6dcba8c563ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0850c534992d381353a08ce60f46299"><td class="memItemLeft" align="right" valign="top"><a id="gaa0850c534992d381353a08ce60f46299"></a>
typedef VectorRd&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::MatrixFamily&lt; ScalarFamilyType, N &gt;::CurlValue</b></td></tr>
<tr class="separator:gaa0850c534992d381353a08ce60f46299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5ff33a66c54b1590e6d6d2f7c57a60e"><td class="memItemLeft" align="right" valign="top"><a id="gaf5ff33a66c54b1590e6d6d2f7c57a60e"></a>
typedef Eigen::Matrix&lt; double, N, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::MatrixFamily&lt; ScalarFamilyType, N &gt;::DivergenceValue</b></td></tr>
<tr class="separator:gaf5ff33a66c54b1590e6d6d2f7c57a60e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c0a0cf49808e9429cb3893764f33289"><td class="memItemLeft" align="right" valign="top"><a id="ga7c0a0cf49808e9429cb3893764f33289"></a>
typedef ScalarFamilyType::GeometricSupport&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::MatrixFamily&lt; ScalarFamilyType, N &gt;::GeometricSupport</b></td></tr>
<tr class="separator:ga7c0a0cf49808e9429cb3893764f33289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7577afe21686e8161aba7003863b07e7"><td class="memItemLeft" align="right" valign="top"><a id="ga7577afe21686e8161aba7003863b07e7"></a>
typedef VectorRd&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::TangentFamily&lt; ScalarFamilyType &gt;::FunctionValue</b></td></tr>
<tr class="separator:ga7577afe21686e8161aba7003863b07e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f46ceba9b7132c3df0c5277fe045d08"><td class="memItemLeft" align="right" valign="top"><a id="ga8f46ceba9b7132c3df0c5277fe045d08"></a>
typedef VectorRd&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::TangentFamily&lt; ScalarFamilyType &gt;::GradientValue</b></td></tr>
<tr class="separator:ga8f46ceba9b7132c3df0c5277fe045d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28edbb2171a9f19d54d651d72ca52d43"><td class="memItemLeft" align="right" valign="top"><a id="ga28edbb2171a9f19d54d651d72ca52d43"></a>
typedef VectorRd&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::TangentFamily&lt; ScalarFamilyType &gt;::CurlValue</b></td></tr>
<tr class="separator:ga28edbb2171a9f19d54d651d72ca52d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c6e2ee0d7420c48bcf6194b8bcba615"><td class="memItemLeft" align="right" valign="top"><a id="ga3c6e2ee0d7420c48bcf6194b8bcba615"></a>
typedef double&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::TangentFamily&lt; ScalarFamilyType &gt;::DivergenceValue</b></td></tr>
<tr class="separator:ga3c6e2ee0d7420c48bcf6194b8bcba615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40743f46b74fc3a37455f3e0968d0156"><td class="memItemLeft" align="right" valign="top"><a id="ga40743f46b74fc3a37455f3e0968d0156"></a>
typedef <a class="el" href="classHArDCore2D_1_1Edge.html">Edge</a>&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::TangentFamily&lt; ScalarFamilyType &gt;::GeometricSupport</b></td></tr>
<tr class="separator:ga40743f46b74fc3a37455f3e0968d0156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga723910be19a99d8ce0273b83b8f5e867"><td class="memItemLeft" align="right" valign="top"><a id="ga723910be19a99d8ce0273b83b8f5e867"></a>
typedef BasisType::FunctionValue&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::ShiftedBasis&lt; BasisType &gt;::FunctionValue</b></td></tr>
<tr class="separator:ga723910be19a99d8ce0273b83b8f5e867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c735f6905189f7c0e959a4758d9ff4b"><td class="memItemLeft" align="right" valign="top"><a id="ga8c735f6905189f7c0e959a4758d9ff4b"></a>
typedef BasisType::GradientValue&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::ShiftedBasis&lt; BasisType &gt;::GradientValue</b></td></tr>
<tr class="separator:ga8c735f6905189f7c0e959a4758d9ff4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga406ca8b5e2b929b24a7ac1f0f717ff4a"><td class="memItemLeft" align="right" valign="top"><a id="ga406ca8b5e2b929b24a7ac1f0f717ff4a"></a>
typedef VectorRd&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::ShiftedBasis&lt; BasisType &gt;::CurlValue</b></td></tr>
<tr class="separator:ga406ca8b5e2b929b24a7ac1f0f717ff4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9555eb384f91b5a68a871632c839d9e3"><td class="memItemLeft" align="right" valign="top"><a id="ga9555eb384f91b5a68a871632c839d9e3"></a>
typedef double&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::ShiftedBasis&lt; BasisType &gt;::DivergenceValue</b></td></tr>
<tr class="separator:ga9555eb384f91b5a68a871632c839d9e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga677eacf2bedba936109ffd1f43593a7b"><td class="memItemLeft" align="right" valign="top"><a id="ga677eacf2bedba936109ffd1f43593a7b"></a>
typedef BasisType::GeometricSupport&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::ShiftedBasis&lt; BasisType &gt;::GeometricSupport</b></td></tr>
<tr class="separator:ga677eacf2bedba936109ffd1f43593a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5772db07ac87c68788744dc652317540"><td class="memItemLeft" align="right" valign="top"><a id="ga5772db07ac87c68788744dc652317540"></a>
typedef BasisType::FunctionValue&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::RestrictedBasis&lt; BasisType &gt;::FunctionValue</b></td></tr>
<tr class="separator:ga5772db07ac87c68788744dc652317540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fd05335aff5beae7d23d274ccf95496"><td class="memItemLeft" align="right" valign="top"><a id="ga2fd05335aff5beae7d23d274ccf95496"></a>
typedef BasisType::GradientValue&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::RestrictedBasis&lt; BasisType &gt;::GradientValue</b></td></tr>
<tr class="separator:ga2fd05335aff5beae7d23d274ccf95496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76c22157064e9c58e0e45c3dfcfc8e19"><td class="memItemLeft" align="right" valign="top"><a id="ga76c22157064e9c58e0e45c3dfcfc8e19"></a>
typedef VectorRd&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::RestrictedBasis&lt; BasisType &gt;::CurlValue</b></td></tr>
<tr class="separator:ga76c22157064e9c58e0e45c3dfcfc8e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga841d7df7cd3379bd3f774206dd1009d1"><td class="memItemLeft" align="right" valign="top"><a id="ga841d7df7cd3379bd3f774206dd1009d1"></a>
typedef double&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::RestrictedBasis&lt; BasisType &gt;::DivergenceValue</b></td></tr>
<tr class="separator:ga841d7df7cd3379bd3f774206dd1009d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1568c98b6dcfe1198d237669218e85c"><td class="memItemLeft" align="right" valign="top"><a id="gac1568c98b6dcfe1198d237669218e85c"></a>
typedef BasisType::GeometricSupport&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::RestrictedBasis&lt; BasisType &gt;::GeometricSupport</b></td></tr>
<tr class="separator:gac1568c98b6dcfe1198d237669218e85c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88eba0d5ce79a279b6577d119c88442a"><td class="memItemLeft" align="right" valign="top"><a id="ga88eba0d5ce79a279b6577d119c88442a"></a>
typedef VectorRd&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::GradientBasis&lt; BasisType &gt;::FunctionValue</b></td></tr>
<tr class="separator:ga88eba0d5ce79a279b6577d119c88442a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ebfddada3978c4b571e667b939496c6"><td class="memItemLeft" align="right" valign="top"><a id="ga5ebfddada3978c4b571e667b939496c6"></a>
typedef Eigen::Matrix&lt; double, dimspace, dimspace &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::GradientBasis&lt; BasisType &gt;::GradientValue</b></td></tr>
<tr class="separator:ga5ebfddada3978c4b571e667b939496c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2c823452962577abcb6f9176f1554fe"><td class="memItemLeft" align="right" valign="top"><a id="gac2c823452962577abcb6f9176f1554fe"></a>
typedef VectorRd&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::GradientBasis&lt; BasisType &gt;::CurlValue</b></td></tr>
<tr class="separator:gac2c823452962577abcb6f9176f1554fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga639a17eae62656583350d42bba42773c"><td class="memItemLeft" align="right" valign="top"><a id="ga639a17eae62656583350d42bba42773c"></a>
typedef double&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::GradientBasis&lt; BasisType &gt;::DivergenceValue</b></td></tr>
<tr class="separator:ga639a17eae62656583350d42bba42773c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7aeabadc1694d72f9a7ec37924b86b7"><td class="memItemLeft" align="right" valign="top"><a id="gad7aeabadc1694d72f9a7ec37924b86b7"></a>
typedef BasisType::GeometricSupport&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::GradientBasis&lt; BasisType &gt;::GeometricSupport</b></td></tr>
<tr class="separator:gad7aeabadc1694d72f9a7ec37924b86b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8954d1fe222ab25708605f1939a85260"><td class="memItemLeft" align="right" valign="top"><a id="ga8954d1fe222ab25708605f1939a85260"></a>
typedef VectorRd&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::CurlBasis&lt; BasisType &gt;::FunctionValue</b></td></tr>
<tr class="separator:ga8954d1fe222ab25708605f1939a85260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2dd0ffc5ec9759fe76baccc17364ff94"><td class="memItemLeft" align="right" valign="top"><a id="ga2dd0ffc5ec9759fe76baccc17364ff94"></a>
typedef Eigen::Matrix&lt; double, dimspace, dimspace &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::CurlBasis&lt; BasisType &gt;::GradientValue</b></td></tr>
<tr class="separator:ga2dd0ffc5ec9759fe76baccc17364ff94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cb7793ae3fc65142f3d0f4bc9e8eb6a"><td class="memItemLeft" align="right" valign="top"><a id="ga2cb7793ae3fc65142f3d0f4bc9e8eb6a"></a>
typedef Eigen::Matrix&lt; double, dimspace, dimspace &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::CurlBasis&lt; BasisType &gt;::CurlValue</b></td></tr>
<tr class="separator:ga2cb7793ae3fc65142f3d0f4bc9e8eb6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc0c2ec9740feae9684f010d2ff723de"><td class="memItemLeft" align="right" valign="top"><a id="gacc0c2ec9740feae9684f010d2ff723de"></a>
typedef double&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::CurlBasis&lt; BasisType &gt;::DivergenceValue</b></td></tr>
<tr class="separator:gacc0c2ec9740feae9684f010d2ff723de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b4cf4e9972b888848398dd5535f94b9"><td class="memItemLeft" align="right" valign="top"><a id="ga1b4cf4e9972b888848398dd5535f94b9"></a>
typedef BasisType::GeometricSupport&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::CurlBasis&lt; BasisType &gt;::GeometricSupport</b></td></tr>
<tr class="separator:ga1b4cf4e9972b888848398dd5535f94b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c75ea7c7dba0a1a4421436a6d6cc4ac"><td class="memItemLeft" align="right" valign="top"><a id="ga0c75ea7c7dba0a1a4421436a6d6cc4ac"></a>
typedef VectorRd&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::RolyComplBasisCell::FunctionValue</b></td></tr>
<tr class="separator:ga0c75ea7c7dba0a1a4421436a6d6cc4ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab475dfeb91197d5b5b758126089b8c97"><td class="memItemLeft" align="right" valign="top"><a id="gab475dfeb91197d5b5b758126089b8c97"></a>
typedef Eigen::Matrix&lt; double, dimspace, dimspace &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::RolyComplBasisCell::GradientValue</b></td></tr>
<tr class="separator:gab475dfeb91197d5b5b758126089b8c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcfe1adb4d84e18dbb366fa040d7e5d3"><td class="memItemLeft" align="right" valign="top"><a id="gafcfe1adb4d84e18dbb366fa040d7e5d3"></a>
typedef Eigen::Matrix&lt; double, dimspace, dimspace &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::RolyComplBasisCell::CurlValue</b></td></tr>
<tr class="separator:gafcfe1adb4d84e18dbb366fa040d7e5d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e7d9d1ff3483325b2a1f45a4dd6bda8"><td class="memItemLeft" align="right" valign="top"><a id="ga8e7d9d1ff3483325b2a1f45a4dd6bda8"></a>
typedef double&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::RolyComplBasisCell::DivergenceValue</b></td></tr>
<tr class="separator:ga8e7d9d1ff3483325b2a1f45a4dd6bda8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga991edabe23e5d73c4b543f9e7c2e92c9"><td class="memItemLeft" align="right" valign="top"><a id="ga991edabe23e5d73c4b543f9e7c2e92c9"></a>
typedef <a class="el" href="classHArDCore2D_1_1Cell.html">Cell</a>&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::RolyComplBasisCell::GeometricSupport</b></td></tr>
<tr class="separator:ga991edabe23e5d73c4b543f9e7c2e92c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga492fb49f04bb76c93a89fa1b801dfa97"><td class="memItemLeft" align="right" valign="top"><a id="ga492fb49f04bb76c93a89fa1b801dfa97"></a>
typedef VectorRd&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::GolyComplBasisCell::FunctionValue</b></td></tr>
<tr class="separator:ga492fb49f04bb76c93a89fa1b801dfa97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac648600c31d099b3d4eea3436f2e5dc9"><td class="memItemLeft" align="right" valign="top"><a id="gac648600c31d099b3d4eea3436f2e5dc9"></a>
typedef Eigen::Matrix&lt; double, dimspace, dimspace &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::GolyComplBasisCell::GradientValue</b></td></tr>
<tr class="separator:gac648600c31d099b3d4eea3436f2e5dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga884a0d375cbf0fd26a976aecf6dc66a7"><td class="memItemLeft" align="right" valign="top"><a id="ga884a0d375cbf0fd26a976aecf6dc66a7"></a>
typedef Eigen::Matrix&lt; double, dimspace, dimspace &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::GolyComplBasisCell::CurlValue</b></td></tr>
<tr class="separator:ga884a0d375cbf0fd26a976aecf6dc66a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b8fc6f6a7bbcc502a2bea1c7ae1be4e"><td class="memItemLeft" align="right" valign="top"><a id="ga6b8fc6f6a7bbcc502a2bea1c7ae1be4e"></a>
typedef double&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::GolyComplBasisCell::DivergenceValue</b></td></tr>
<tr class="separator:ga6b8fc6f6a7bbcc502a2bea1c7ae1be4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b95ed339d886310f0082adcfd502d5d"><td class="memItemLeft" align="right" valign="top"><a id="ga4b95ed339d886310f0082adcfd502d5d"></a>
typedef <a class="el" href="classHArDCore2D_1_1Cell.html">Cell</a>&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::GolyComplBasisCell::GeometricSupport</b></td></tr>
<tr class="separator:ga4b95ed339d886310f0082adcfd502d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga169e5809bf5bdd0b38087e155398861e"><td class="memItemLeft" align="right" valign="top"><a id="ga169e5809bf5bdd0b38087e155398861e"></a>
typedef BasisType::FunctionValue&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::detail::basis_evaluation_traits&lt; BasisType, Function &gt;::ReturnValue</b></td></tr>
<tr class="separator:ga169e5809bf5bdd0b38087e155398861e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b10153f3e7e528d4e6508694d4bbea7"><td class="memItemLeft" align="right" valign="top"><a id="ga5b10153f3e7e528d4e6508694d4bbea7"></a>
typedef BasisType::GradientValue&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::detail::basis_evaluation_traits&lt; BasisType, Gradient &gt;::ReturnValue</b></td></tr>
<tr class="separator:ga5b10153f3e7e528d4e6508694d4bbea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80ce0c225d00d0530e83daa716962e26"><td class="memItemLeft" align="right" valign="top"><a id="ga80ce0c225d00d0530e83daa716962e26"></a>
typedef BasisType::CurlValue&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::detail::basis_evaluation_traits&lt; BasisType, Curl &gt;::ReturnValue</b></td></tr>
<tr class="separator:ga80ce0c225d00d0530e83daa716962e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga629fb65115831ee4fec373cac0698337"><td class="memItemLeft" align="right" valign="top"><a id="ga629fb65115831ee4fec373cac0698337"></a>
typedef BasisType::DivergenceValue&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::detail::basis_evaluation_traits&lt; BasisType, Divergence &gt;::ReturnValue</b></td></tr>
<tr class="separator:ga629fb65115831ee4fec373cac0698337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90c6822e492637cd8fef5974bd9b97b4"><td class="memItemLeft" align="right" valign="top"><a id="ga90c6822e492637cd8fef5974bd9b97b4"></a>
typedef <a class="el" href="classHArDCore2D_1_1TensorizedVectorFamily.html">TensorizedVectorFamily</a>&lt; ScalarBasisType, N &gt;::FunctionValue&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::detail::basis_evaluation_traits&lt; TensorizedVectorFamily&lt; ScalarBasisType, N &gt;, Function &gt;::ReturnValue</b></td></tr>
<tr class="separator:ga90c6822e492637cd8fef5974bd9b97b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad54e03607d8e42f7d80cad107e168675"><td class="memItemLeft" align="right" valign="top"><a id="gad54e03607d8e42f7d80cad107e168675"></a>
typedef double&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::detail::basis_evaluation_traits&lt; TensorizedVectorFamily&lt; ScalarBasisType, N &gt;, Function &gt;::AncestorBasisFunctionValue</b></td></tr>
<tr class="separator:gad54e03607d8e42f7d80cad107e168675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae881fc01578d22d3aa3bc2fd3fe46239"><td class="memItemLeft" align="right" valign="top"><a id="gae881fc01578d22d3aa3bc2fd3fe46239"></a>
typedef <a class="el" href="classHArDCore2D_1_1TensorizedVectorFamily.html">TensorizedVectorFamily</a>&lt; ScalarBasisType, N &gt;::GradientValue&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::detail::basis_evaluation_traits&lt; TensorizedVectorFamily&lt; ScalarBasisType, N &gt;, Gradient &gt;::ReturnValue</b></td></tr>
<tr class="separator:gae881fc01578d22d3aa3bc2fd3fe46239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga868d3a49f1fdd72b05abd1d2a3c85ea5"><td class="memItemLeft" align="right" valign="top"><a id="ga868d3a49f1fdd72b05abd1d2a3c85ea5"></a>
typedef VectorRd&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::detail::basis_evaluation_traits&lt; TensorizedVectorFamily&lt; ScalarBasisType, N &gt;, Gradient &gt;::AncestorBasisFunctionValue</b></td></tr>
<tr class="separator:ga868d3a49f1fdd72b05abd1d2a3c85ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27ca67e4e712e4770d94f6b9307c2517"><td class="memItemLeft" align="right" valign="top"><a id="ga27ca67e4e712e4770d94f6b9307c2517"></a>
typedef <a class="el" href="classHArDCore2D_1_1TensorizedVectorFamily.html">TensorizedVectorFamily</a>&lt; ScalarBasisType, N &gt;::CurlValue&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::detail::basis_evaluation_traits&lt; TensorizedVectorFamily&lt; ScalarBasisType, N &gt;, Curl &gt;::ReturnValue</b></td></tr>
<tr class="separator:ga27ca67e4e712e4770d94f6b9307c2517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1316e371be4206dbcdb95a0dc3bb7e3"><td class="memItemLeft" align="right" valign="top"><a id="gaa1316e371be4206dbcdb95a0dc3bb7e3"></a>
typedef VectorRd&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::detail::basis_evaluation_traits&lt; TensorizedVectorFamily&lt; ScalarBasisType, N &gt;, Curl &gt;::AncestorBasisFunctionValue</b></td></tr>
<tr class="separator:gaa1316e371be4206dbcdb95a0dc3bb7e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b279a6fb0d5b01fd53ff2cdf3e613e3"><td class="memItemLeft" align="right" valign="top"><a id="ga3b279a6fb0d5b01fd53ff2cdf3e613e3"></a>
typedef <a class="el" href="classHArDCore2D_1_1TensorizedVectorFamily.html">TensorizedVectorFamily</a>&lt; ScalarBasisType, N &gt;::DivergenceValue&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::detail::basis_evaluation_traits&lt; TensorizedVectorFamily&lt; ScalarBasisType, N &gt;, Divergence &gt;::ReturnValue</b></td></tr>
<tr class="separator:ga3b279a6fb0d5b01fd53ff2cdf3e613e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e3bcb767e26265ce0c703d6d45a50e0"><td class="memItemLeft" align="right" valign="top"><a id="ga8e3bcb767e26265ce0c703d6d45a50e0"></a>
typedef VectorRd&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::detail::basis_evaluation_traits&lt; TensorizedVectorFamily&lt; ScalarBasisType, N &gt;, Divergence &gt;::AncestorBasisFunctionValue</b></td></tr>
<tr class="separator:ga8e3bcb767e26265ce0c703d6d45a50e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6abce82facf70745d61f3de925f55ce"><td class="memItemLeft" align="right" valign="top"><a id="gab6abce82facf70745d61f3de925f55ce"></a>
typedef <a class="el" href="classHArDCore2D_1_1MatrixFamily.html">MatrixFamily</a>&lt; ScalarBasisType, N &gt;::FunctionValue&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::detail::basis_evaluation_traits&lt; MatrixFamily&lt; ScalarBasisType, N &gt;, Function &gt;::ReturnValue</b></td></tr>
<tr class="separator:gab6abce82facf70745d61f3de925f55ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ddbfcbca5b6e1c6b85f87b50477d4ae"><td class="memItemLeft" align="right" valign="top"><a id="ga7ddbfcbca5b6e1c6b85f87b50477d4ae"></a>
typedef double&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::detail::basis_evaluation_traits&lt; MatrixFamily&lt; ScalarBasisType, N &gt;, Function &gt;::AncestorBasisFunctionValue</b></td></tr>
<tr class="separator:ga7ddbfcbca5b6e1c6b85f87b50477d4ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75f2ffc4c5b7c4a2f70db20d4acc9e16"><td class="memItemLeft" align="right" valign="top"><a id="ga75f2ffc4c5b7c4a2f70db20d4acc9e16"></a>
typedef <a class="el" href="classHArDCore2D_1_1MatrixFamily.html">MatrixFamily</a>&lt; ScalarBasisType, N &gt;::DivergenceValue&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::detail::basis_evaluation_traits&lt; MatrixFamily&lt; ScalarBasisType, N &gt;, Divergence &gt;::ReturnValue</b></td></tr>
<tr class="separator:ga75f2ffc4c5b7c4a2f70db20d4acc9e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee83448214d082e4ebf52bedbae71ab8"><td class="memItemLeft" align="right" valign="top"><a id="gaee83448214d082e4ebf52bedbae71ab8"></a>
typedef VectorRd&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::detail::basis_evaluation_traits&lt; MatrixFamily&lt; ScalarBasisType, N &gt;, Divergence &gt;::AncestorBasisFunctionValue</b></td></tr>
<tr class="separator:gaee83448214d082e4ebf52bedbae71ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga99c0a4ae66e5304b0bb7500c00f6e397"><td class="memItemLeft" align="right" valign="top"><a id="ga99c0a4ae66e5304b0bb7500c00f6e397"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>TensorRankE</b> { <b>Scalar</b> = 0, 
<b>Vector</b> = 1, 
<b>Matrix</b> = 2
 }</td></tr>
<tr class="separator:ga99c0a4ae66e5304b0bb7500c00f6e397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21912c7c8daa962296cd7f608150d525"><td class="memItemLeft" align="right" valign="top"><a id="ga21912c7c8daa962296cd7f608150d525"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>BasisFunctionE</b> { <b>Function</b>, 
<b>Gradient</b>, 
<b>Curl</b>, 
<b>Divergence</b>
 }</td></tr>
<tr class="separator:ga21912c7c8daa962296cd7f608150d525"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga603c7e69393f4cc4f0a378e08273785d"><td class="memItemLeft" align="right" valign="top"><a id="ga603c7e69393f4cc4f0a378e08273785d"></a>
static std::vector&lt; VectorZd &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::MonomialPowers&lt; Cell &gt;::compute</b> (size_t degree)</td></tr>
<tr class="separator:ga603c7e69393f4cc4f0a378e08273785d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga077d11dc2b2d74d11b72f165dc8d033a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga077d11dc2b2d74d11b72f165dc8d033a">HArDCore2D::MonomialScalarBasisCell::MonomialScalarBasisCell</a> (const <a class="el" href="classHArDCore2D_1_1Cell.html">Cell</a> &amp;T, size_t degree)</td></tr>
<tr class="memdesc:ga077d11dc2b2d74d11b72f165dc8d033a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="group__Basis.html#ga077d11dc2b2d74d11b72f165dc8d033a">More...</a><br /></td></tr>
<tr class="separator:ga077d11dc2b2d74d11b72f165dc8d033a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79a3220472fbc88d100be37ea1503d3e"><td class="memItemLeft" align="right" valign="top"><a id="ga79a3220472fbc88d100be37ea1503d3e"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga79a3220472fbc88d100be37ea1503d3e">HArDCore2D::MonomialScalarBasisCell::dimension</a> () const</td></tr>
<tr class="memdesc:ga79a3220472fbc88d100be37ea1503d3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the dimension of the basis. <br /></td></tr>
<tr class="separator:ga79a3220472fbc88d100be37ea1503d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82562e20ba49b9e72e04c6a7660b1d3c"><td class="memItemLeft" align="right" valign="top"><a id="ga82562e20ba49b9e72e04c6a7660b1d3c"></a>
FunctionValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga82562e20ba49b9e72e04c6a7660b1d3c">HArDCore2D::MonomialScalarBasisCell::function</a> (size_t i, const VectorRd &amp;x) const</td></tr>
<tr class="memdesc:ga82562e20ba49b9e72e04c6a7660b1d3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the i-th basis function at point x. <br /></td></tr>
<tr class="separator:ga82562e20ba49b9e72e04c6a7660b1d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34784e2233789bed6214488ff9e4166d"><td class="memItemLeft" align="right" valign="top"><a id="ga34784e2233789bed6214488ff9e4166d"></a>
GradientValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga34784e2233789bed6214488ff9e4166d">HArDCore2D::MonomialScalarBasisCell::gradient</a> (size_t i, const VectorRd &amp;x) const</td></tr>
<tr class="memdesc:ga34784e2233789bed6214488ff9e4166d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the gradient of the i-th basis function at point x. <br /></td></tr>
<tr class="separator:ga34784e2233789bed6214488ff9e4166d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga962166d89641683136654a3e27773c1c"><td class="memItemLeft" align="right" valign="top"><a id="ga962166d89641683136654a3e27773c1c"></a>
CurlValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga962166d89641683136654a3e27773c1c">HArDCore2D::MonomialScalarBasisCell::curl</a> (size_t i, const VectorRd &amp;x) const</td></tr>
<tr class="memdesc:ga962166d89641683136654a3e27773c1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the curl (vector rot) of the i-th basis function at point x. <br /></td></tr>
<tr class="separator:ga962166d89641683136654a3e27773c1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1794a48fbd89584ed844950e0057f513"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga1794a48fbd89584ed844950e0057f513">HArDCore2D::MonomialScalarBasisEdge::MonomialScalarBasisEdge</a> (const <a class="el" href="classHArDCore2D_1_1Edge.html">Edge</a> &amp;E, size_t degree)</td></tr>
<tr class="memdesc:ga1794a48fbd89584ed844950e0057f513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="group__Basis.html#ga1794a48fbd89584ed844950e0057f513">More...</a><br /></td></tr>
<tr class="separator:ga1794a48fbd89584ed844950e0057f513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae546ece15c11ddb4382aa47c50fdd53c"><td class="memItemLeft" align="right" valign="top"><a id="gae546ece15c11ddb4382aa47c50fdd53c"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#gae546ece15c11ddb4382aa47c50fdd53c">HArDCore2D::MonomialScalarBasisEdge::dimension</a> () const</td></tr>
<tr class="memdesc:gae546ece15c11ddb4382aa47c50fdd53c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dimension of the basis. <br /></td></tr>
<tr class="separator:gae546ece15c11ddb4382aa47c50fdd53c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3ea5893997d96a77ea5a22d80777360"><td class="memItemLeft" align="right" valign="top"><a id="gaf3ea5893997d96a77ea5a22d80777360"></a>
FunctionValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#gaf3ea5893997d96a77ea5a22d80777360">HArDCore2D::MonomialScalarBasisEdge::function</a> (size_t i, const VectorRd &amp;x) const</td></tr>
<tr class="memdesc:gaf3ea5893997d96a77ea5a22d80777360"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the i-th basis function at point x. <br /></td></tr>
<tr class="separator:gaf3ea5893997d96a77ea5a22d80777360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46fbc56b645a745e1ffef6995decc5cd"><td class="memItemLeft" align="right" valign="top"><a id="ga46fbc56b645a745e1ffef6995decc5cd"></a>
GradientValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga46fbc56b645a745e1ffef6995decc5cd">HArDCore2D::MonomialScalarBasisEdge::gradient</a> (size_t i, const VectorRd &amp;x) const</td></tr>
<tr class="memdesc:ga46fbc56b645a745e1ffef6995decc5cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the gradient of the i-th basis function at point x. <br /></td></tr>
<tr class="separator:ga46fbc56b645a745e1ffef6995decc5cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e8f09ecc2cfd226ebb6539b34934d6a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga2e8f09ecc2cfd226ebb6539b34934d6a">HArDCore2D::Family&lt; BasisType &gt;::Family</a> (const BasisType &amp;basis, const Eigen::MatrixXd &amp;<a class="el" href="group__Basis.html#gaaf8f501609f30a03b0b167e381f6ac23">matrix</a>)</td></tr>
<tr class="memdesc:ga2e8f09ecc2cfd226ebb6539b34934d6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="group__Basis.html#ga2e8f09ecc2cfd226ebb6539b34934d6a">More...</a><br /></td></tr>
<tr class="separator:ga2e8f09ecc2cfd226ebb6539b34934d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga385bf99cf8c3888a150ed53f410ae39f"><td class="memItemLeft" align="right" valign="top"><a id="ga385bf99cf8c3888a150ed53f410ae39f"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga385bf99cf8c3888a150ed53f410ae39f">HArDCore2D::Family&lt; BasisType &gt;::dimension</a> () const</td></tr>
<tr class="memdesc:ga385bf99cf8c3888a150ed53f410ae39f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dimension of the family. This is actually the number of functions in the family, not necessarily linearly independent. <br /></td></tr>
<tr class="separator:ga385bf99cf8c3888a150ed53f410ae39f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15a1f56b9bb54f849ebaf4a66f75907d"><td class="memItemLeft" align="right" valign="top"><a id="ga15a1f56b9bb54f849ebaf4a66f75907d"></a>
FunctionValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga15a1f56b9bb54f849ebaf4a66f75907d">HArDCore2D::Family&lt; BasisType &gt;::function</a> (size_t i, const VectorRd &amp;x) const</td></tr>
<tr class="memdesc:ga15a1f56b9bb54f849ebaf4a66f75907d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the i-th function at point x. <br /></td></tr>
<tr class="separator:ga15a1f56b9bb54f849ebaf4a66f75907d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac54950ab44f2fbd6e95a6f1e196fcf53"><td class="memItemLeft" align="right" valign="top"><a id="gac54950ab44f2fbd6e95a6f1e196fcf53"></a>
FunctionValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#gac54950ab44f2fbd6e95a6f1e196fcf53">HArDCore2D::Family&lt; BasisType &gt;::function</a> (size_t i, size_t iqn, const boost::multi_array&lt; FunctionValue, 2 &gt; &amp;ancestor_value_quad) const</td></tr>
<tr class="memdesc:gac54950ab44f2fbd6e95a6f1e196fcf53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the i-th function at a quadrature point iqn, knowing all the values of ancestor basis functions at the quadrature nodes (provided by eval_quad) <br /></td></tr>
<tr class="separator:gac54950ab44f2fbd6e95a6f1e196fcf53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05b9845ad5b44a743ae7e8223a897447"><td class="memItemLeft" align="right" valign="top"><a id="ga05b9845ad5b44a743ae7e8223a897447"></a>
GradientValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga05b9845ad5b44a743ae7e8223a897447">HArDCore2D::Family&lt; BasisType &gt;::gradient</a> (size_t i, const VectorRd &amp;x) const</td></tr>
<tr class="memdesc:ga05b9845ad5b44a743ae7e8223a897447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the gradient of the i-th function at point x. <br /></td></tr>
<tr class="separator:ga05b9845ad5b44a743ae7e8223a897447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga525278d350aa0742fef160f3592b5de6"><td class="memItemLeft" align="right" valign="top"><a id="ga525278d350aa0742fef160f3592b5de6"></a>
GradientValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga525278d350aa0742fef160f3592b5de6">HArDCore2D::Family&lt; BasisType &gt;::gradient</a> (size_t i, size_t iqn, const boost::multi_array&lt; GradientValue, 2 &gt; &amp;ancestor_gradient_quad) const</td></tr>
<tr class="memdesc:ga525278d350aa0742fef160f3592b5de6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the gradient of the i-th function at a quadrature point iqn, knowing all the gradients of ancestor basis functions at the quadrature nodes (provided by eval_quad) <br /></td></tr>
<tr class="separator:ga525278d350aa0742fef160f3592b5de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f44b487b46df0e9cf83b175ae0ae3b3"><td class="memItemLeft" align="right" valign="top"><a id="ga9f44b487b46df0e9cf83b175ae0ae3b3"></a>
CurlValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga9f44b487b46df0e9cf83b175ae0ae3b3">HArDCore2D::Family&lt; BasisType &gt;::curl</a> (size_t i, const VectorRd &amp;x) const</td></tr>
<tr class="memdesc:ga9f44b487b46df0e9cf83b175ae0ae3b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the curl of the i-th function at point x. <br /></td></tr>
<tr class="separator:ga9f44b487b46df0e9cf83b175ae0ae3b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3e001e54bd8f3b2d272ceefeb4f23b6"><td class="memItemLeft" align="right" valign="top"><a id="gab3e001e54bd8f3b2d272ceefeb4f23b6"></a>
CurlValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#gab3e001e54bd8f3b2d272ceefeb4f23b6">HArDCore2D::Family&lt; BasisType &gt;::curl</a> (size_t i, size_t iqn, const boost::multi_array&lt; CurlValue, 2 &gt; &amp;ancestor_curl_quad) const</td></tr>
<tr class="memdesc:gab3e001e54bd8f3b2d272ceefeb4f23b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the curl of the i-th function at a quadrature point iqn, knowing all the curls of ancestor basis functions at the quadrature nodes (provided by eval_quad) <br /></td></tr>
<tr class="separator:gab3e001e54bd8f3b2d272ceefeb4f23b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86a0fd0d5391607f156b3c27be6d7164"><td class="memItemLeft" align="right" valign="top"><a id="ga86a0fd0d5391607f156b3c27be6d7164"></a>
DivergenceValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga86a0fd0d5391607f156b3c27be6d7164">HArDCore2D::Family&lt; BasisType &gt;::divergence</a> (size_t i, const VectorRd &amp;x) const</td></tr>
<tr class="memdesc:ga86a0fd0d5391607f156b3c27be6d7164"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the divergence of the i-th function at point x. <br /></td></tr>
<tr class="separator:ga86a0fd0d5391607f156b3c27be6d7164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0744d69d4277d2251248d9bbfe5ae97"><td class="memItemLeft" align="right" valign="top"><a id="gab0744d69d4277d2251248d9bbfe5ae97"></a>
DivergenceValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#gab0744d69d4277d2251248d9bbfe5ae97">HArDCore2D::Family&lt; BasisType &gt;::divergence</a> (size_t i, size_t iqn, const boost::multi_array&lt; DivergenceValue, 2 &gt; &amp;ancestor_divergence_quad) const</td></tr>
<tr class="memdesc:gab0744d69d4277d2251248d9bbfe5ae97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the divergence of the i-th function at a quadrature point iqn, knowing all the divergences of ancestor basis functions at the quadrature nodes (provided by eval_quad) <br /></td></tr>
<tr class="separator:gab0744d69d4277d2251248d9bbfe5ae97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf8f501609f30a03b0b167e381f6ac23"><td class="memItemLeft" align="right" valign="top"><a id="gaaf8f501609f30a03b0b167e381f6ac23"></a>
const Eigen::MatrixXd &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#gaaf8f501609f30a03b0b167e381f6ac23">HArDCore2D::Family&lt; BasisType &gt;::matrix</a> () const</td></tr>
<tr class="memdesc:gaaf8f501609f30a03b0b167e381f6ac23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the coefficient matrix. <br /></td></tr>
<tr class="separator:gaaf8f501609f30a03b0b167e381f6ac23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f618ff125041ebcfb88db2f4373d37e"><td class="memItemLeft" align="right" valign="top"><a id="ga1f618ff125041ebcfb88db2f4373d37e"></a>
const BasisType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga1f618ff125041ebcfb88db2f4373d37e">HArDCore2D::Family&lt; BasisType &gt;::ancestor</a> () const</td></tr>
<tr class="memdesc:ga1f618ff125041ebcfb88db2f4373d37e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the ancestor. <br /></td></tr>
<tr class="separator:ga1f618ff125041ebcfb88db2f4373d37e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbbde5d4b671418870cbbd903a0a409b"><td class="memItemLeft" align="right" valign="top"><a id="gafbbde5d4b671418870cbbd903a0a409b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::TensorizedVectorFamily&lt; ScalarFamilyType, N &gt;::TensorizedVectorFamily</b> (const ScalarFamilyType &amp;scalar_family)</td></tr>
<tr class="separator:gafbbde5d4b671418870cbbd903a0a409b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdcbe0043887c0aa46065409f1731a83"><td class="memItemLeft" align="right" valign="top"><a id="gabdcbe0043887c0aa46065409f1731a83"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#gabdcbe0043887c0aa46065409f1731a83">HArDCore2D::TensorizedVectorFamily&lt; ScalarFamilyType, N &gt;::dimension</a> () const</td></tr>
<tr class="memdesc:gabdcbe0043887c0aa46065409f1731a83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the dimension of the family. <br /></td></tr>
<tr class="separator:gabdcbe0043887c0aa46065409f1731a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52d9aaac677abb3a81b32c5542e55ea4"><td class="memItemLeft" align="right" valign="top"><a id="ga52d9aaac677abb3a81b32c5542e55ea4"></a>
FunctionValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga52d9aaac677abb3a81b32c5542e55ea4">HArDCore2D::TensorizedVectorFamily&lt; ScalarFamilyType, N &gt;::function</a> (size_t i, const VectorRd &amp;x) const</td></tr>
<tr class="memdesc:ga52d9aaac677abb3a81b32c5542e55ea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the i-th basis function at point x. <br /></td></tr>
<tr class="separator:ga52d9aaac677abb3a81b32c5542e55ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56bd4a69ff41c065b5b0a9ec5b4457be"><td class="memItemLeft" align="right" valign="top"><a id="ga56bd4a69ff41c065b5b0a9ec5b4457be"></a>
FunctionValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga56bd4a69ff41c065b5b0a9ec5b4457be">HArDCore2D::TensorizedVectorFamily&lt; ScalarFamilyType, N &gt;::function</a> (size_t i, size_t iqn, const boost::multi_array&lt; double, 2 &gt; &amp;ancestor_value_quad) const</td></tr>
<tr class="memdesc:ga56bd4a69ff41c065b5b0a9ec5b4457be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the i-th basis function at a quadrature point iqn, knowing all the values of ancestor basis functions at the quadrature nodes (provided by eval_quad) <br /></td></tr>
<tr class="separator:ga56bd4a69ff41c065b5b0a9ec5b4457be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46500da07e2cb4cfe8ead5ffe8dbc586"><td class="memItemLeft" align="right" valign="top"><a id="ga46500da07e2cb4cfe8ead5ffe8dbc586"></a>
GradientValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga46500da07e2cb4cfe8ead5ffe8dbc586">HArDCore2D::TensorizedVectorFamily&lt; ScalarFamilyType, N &gt;::gradient</a> (size_t i, const VectorRd &amp;x) const</td></tr>
<tr class="memdesc:ga46500da07e2cb4cfe8ead5ffe8dbc586"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the gradient of the i-th basis function at point x. <br /></td></tr>
<tr class="separator:ga46500da07e2cb4cfe8ead5ffe8dbc586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga523305be1bbffd1a6bf90b51646f9b47"><td class="memItemLeft" align="right" valign="top"><a id="ga523305be1bbffd1a6bf90b51646f9b47"></a>
GradientValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga523305be1bbffd1a6bf90b51646f9b47">HArDCore2D::TensorizedVectorFamily&lt; ScalarFamilyType, N &gt;::gradient</a> (size_t i, size_t iqn, const boost::multi_array&lt; VectorRd, 2 &gt; &amp;ancestor_gradient_quad) const</td></tr>
<tr class="memdesc:ga523305be1bbffd1a6bf90b51646f9b47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the gradient of the i-th basis function at a quadrature point iqn, knowing all the gradients of ancestor basis functions at the quadrature nodes (provided by eval_quad) <br /></td></tr>
<tr class="separator:ga523305be1bbffd1a6bf90b51646f9b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga187befd7daa85ec049e41706ea1d5de2"><td class="memItemLeft" align="right" valign="top"><a id="ga187befd7daa85ec049e41706ea1d5de2"></a>
CurlValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga187befd7daa85ec049e41706ea1d5de2">HArDCore2D::TensorizedVectorFamily&lt; ScalarFamilyType, N &gt;::curl</a> (size_t i, const VectorRd &amp;x) const</td></tr>
<tr class="memdesc:ga187befd7daa85ec049e41706ea1d5de2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the curl of the i-th basis function at point x. <br /></td></tr>
<tr class="separator:ga187befd7daa85ec049e41706ea1d5de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae373e3441fd48abe9ff957b9e2d0503f"><td class="memItemLeft" align="right" valign="top"><a id="gae373e3441fd48abe9ff957b9e2d0503f"></a>
CurlValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#gae373e3441fd48abe9ff957b9e2d0503f">HArDCore2D::TensorizedVectorFamily&lt; ScalarFamilyType, N &gt;::curl</a> (size_t i, size_t iqn, const boost::multi_array&lt; VectorRd, 2 &gt; &amp;ancestor_gradient_quad) const</td></tr>
<tr class="memdesc:gae373e3441fd48abe9ff957b9e2d0503f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the curl of the i-th basis function at a quadrature point iqn, knowing all the gradients of ancestor basis functions at the quadrature nodes (provided by eval_quad) <br /></td></tr>
<tr class="separator:gae373e3441fd48abe9ff957b9e2d0503f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e852fda44755e4ca0a8ffac94d97d16"><td class="memItemLeft" align="right" valign="top"><a id="ga6e852fda44755e4ca0a8ffac94d97d16"></a>
DivergenceValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga6e852fda44755e4ca0a8ffac94d97d16">HArDCore2D::TensorizedVectorFamily&lt; ScalarFamilyType, N &gt;::divergence</a> (size_t i, const VectorRd &amp;x) const</td></tr>
<tr class="memdesc:ga6e852fda44755e4ca0a8ffac94d97d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the divergence of the i-th basis function at point x. <br /></td></tr>
<tr class="separator:ga6e852fda44755e4ca0a8ffac94d97d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1357e7679d97f88adb2c0aebe882c8e0"><td class="memItemLeft" align="right" valign="top"><a id="ga1357e7679d97f88adb2c0aebe882c8e0"></a>
DivergenceValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga1357e7679d97f88adb2c0aebe882c8e0">HArDCore2D::TensorizedVectorFamily&lt; ScalarFamilyType, N &gt;::divergence</a> (size_t i, size_t iqn, const boost::multi_array&lt; VectorRd, 2 &gt; &amp;ancestor_gradient_quad) const</td></tr>
<tr class="memdesc:ga1357e7679d97f88adb2c0aebe882c8e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the divergence of the i-th basis function at a quadrature point iqn, knowing all the gradients of ancestor basis functions at the quadrature nodes (provided by eval_quad) <br /></td></tr>
<tr class="separator:ga1357e7679d97f88adb2c0aebe882c8e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacde0742ba8202c8303151e37cd4212d2"><td class="memItemLeft" align="right" valign="top"><a id="gacde0742ba8202c8303151e37cd4212d2"></a>
const ScalarFamilyType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#gacde0742ba8202c8303151e37cd4212d2">HArDCore2D::TensorizedVectorFamily&lt; ScalarFamilyType, N &gt;::ancestor</a> () const</td></tr>
<tr class="memdesc:gacde0742ba8202c8303151e37cd4212d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the ancestor (family that has been tensorized) <br /></td></tr>
<tr class="separator:gacde0742ba8202c8303151e37cd4212d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99a8fcb66e357e174c6c65f19395f497"><td class="memItemLeft" align="right" valign="top"><a id="ga99a8fcb66e357e174c6c65f19395f497"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::MatrixFamily&lt; ScalarFamilyType, N &gt;::MatrixFamily</b> (const ScalarFamilyType &amp;scalar_family)</td></tr>
<tr class="separator:ga99a8fcb66e357e174c6c65f19395f497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18ef022103db3d80a1d39684e3242877"><td class="memItemLeft" align="right" valign="top"><a id="ga18ef022103db3d80a1d39684e3242877"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga18ef022103db3d80a1d39684e3242877">HArDCore2D::MatrixFamily&lt; ScalarFamilyType, N &gt;::dimension</a> () const</td></tr>
<tr class="memdesc:ga18ef022103db3d80a1d39684e3242877"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the dimension of the family. <br /></td></tr>
<tr class="separator:ga18ef022103db3d80a1d39684e3242877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e4a38cfabb6e1301d8c9241cc54e0c8"><td class="memItemLeft" align="right" valign="top"><a id="ga7e4a38cfabb6e1301d8c9241cc54e0c8"></a>
FunctionValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga7e4a38cfabb6e1301d8c9241cc54e0c8">HArDCore2D::MatrixFamily&lt; ScalarFamilyType, N &gt;::function</a> (size_t i, const VectorRd &amp;x) const</td></tr>
<tr class="memdesc:ga7e4a38cfabb6e1301d8c9241cc54e0c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the i-th basis function at point x. <br /></td></tr>
<tr class="separator:ga7e4a38cfabb6e1301d8c9241cc54e0c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97e08484cdfdf79eb3486f2bf36d41fa"><td class="memItemLeft" align="right" valign="top"><a id="ga97e08484cdfdf79eb3486f2bf36d41fa"></a>
FunctionValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga97e08484cdfdf79eb3486f2bf36d41fa">HArDCore2D::MatrixFamily&lt; ScalarFamilyType, N &gt;::function</a> (size_t i, size_t iqn, const boost::multi_array&lt; double, 2 &gt; &amp;ancestor_value_quad) const</td></tr>
<tr class="memdesc:ga97e08484cdfdf79eb3486f2bf36d41fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the i-th basis function at a quadrature point iqn, knowing all the values of ancestor basis functions at the quadrature nodes (provided by eval_quad) <br /></td></tr>
<tr class="separator:ga97e08484cdfdf79eb3486f2bf36d41fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2df4ed5712456cdb4b95898dec32921"><td class="memItemLeft" align="right" valign="top"><a id="gab2df4ed5712456cdb4b95898dec32921"></a>
DivergenceValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#gab2df4ed5712456cdb4b95898dec32921">HArDCore2D::MatrixFamily&lt; ScalarFamilyType, N &gt;::divergence</a> (size_t i, const VectorRd &amp;x) const</td></tr>
<tr class="memdesc:gab2df4ed5712456cdb4b95898dec32921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the divergence of the i-th basis function at point x. <br /></td></tr>
<tr class="separator:gab2df4ed5712456cdb4b95898dec32921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga422fbebf3d2c594f579e5cb4be4d5cf0"><td class="memItemLeft" align="right" valign="top"><a id="ga422fbebf3d2c594f579e5cb4be4d5cf0"></a>
DivergenceValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga422fbebf3d2c594f579e5cb4be4d5cf0">HArDCore2D::MatrixFamily&lt; ScalarFamilyType, N &gt;::divergence</a> (size_t i, size_t iqn, const boost::multi_array&lt; VectorRd, 2 &gt; &amp;ancestor_gradient_quad) const</td></tr>
<tr class="memdesc:ga422fbebf3d2c594f579e5cb4be4d5cf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the divergence of the i-th basis function at a quadrature point iqn, knowing all the gradients of ancestor basis functions at the quadrature nodes (provided by eval_quad) <br /></td></tr>
<tr class="separator:ga422fbebf3d2c594f579e5cb4be4d5cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f42eedda4151c70b63b234d64383de0"><td class="memItemLeft" align="right" valign="top"><a id="ga1f42eedda4151c70b63b234d64383de0"></a>
const ScalarFamilyType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga1f42eedda4151c70b63b234d64383de0">HArDCore2D::MatrixFamily&lt; ScalarFamilyType, N &gt;::ancestor</a> () const</td></tr>
<tr class="memdesc:ga1f42eedda4151c70b63b234d64383de0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the ancestor (family that has been tensorized) <br /></td></tr>
<tr class="separator:ga1f42eedda4151c70b63b234d64383de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga122dd6f2961cc930054d97b9f9d1474c"><td class="memItemLeft" align="right" valign="top"><a id="ga122dd6f2961cc930054d97b9f9d1474c"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga122dd6f2961cc930054d97b9f9d1474c">HArDCore2D::MatrixFamily&lt; ScalarFamilyType, N &gt;::matrixSize</a> () const</td></tr>
<tr class="memdesc:ga122dd6f2961cc930054d97b9f9d1474c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the dimension of the matrices in the family. <br /></td></tr>
<tr class="separator:ga122dd6f2961cc930054d97b9f9d1474c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bfc1eb9f0a137b88637cd8f7d9d506b"><td class="memItemLeft" align="right" valign="top"><a id="ga4bfc1eb9f0a137b88637cd8f7d9d506b"></a>
const Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga4bfc1eb9f0a137b88637cd8f7d9d506b">HArDCore2D::MatrixFamily&lt; ScalarFamilyType, N &gt;::transposeOperator</a> () const</td></tr>
<tr class="memdesc:ga4bfc1eb9f0a137b88637cd8f7d9d506b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the transpose operator, the rN^2 square matrix that to a given vector of coefficients on the Matrix family associate the vector of coefficients corresponding to the transpose. <br /></td></tr>
<tr class="separator:ga4bfc1eb9f0a137b88637cd8f7d9d506b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga408bbdd71b59bb9c1a09da8d240f346d"><td class="memItemLeft" align="right" valign="top"><a id="ga408bbdd71b59bb9c1a09da8d240f346d"></a>
const Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga408bbdd71b59bb9c1a09da8d240f346d">HArDCore2D::MatrixFamily&lt; ScalarFamilyType, N &gt;::symmetriseOperator</a> () const</td></tr>
<tr class="memdesc:ga408bbdd71b59bb9c1a09da8d240f346d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the symmetrisation operator, the rN^2 square matrix that to a given vector of coefficients on the Matrix family associate the vector of coefficients corresponding to the symmetrised matrix. <br /></td></tr>
<tr class="separator:ga408bbdd71b59bb9c1a09da8d240f346d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cc5c5f1642d42f7479ba5907961811c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga6cc5c5f1642d42f7479ba5907961811c">HArDCore2D::TangentFamily&lt; ScalarFamilyType &gt;::TangentFamily</a> (const ScalarFamilyType &amp;scalar_family, const VectorRd &amp;generator)</td></tr>
<tr class="memdesc:ga6cc5c5f1642d42f7479ba5907961811c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="group__Basis.html#ga6cc5c5f1642d42f7479ba5907961811c">More...</a><br /></td></tr>
<tr class="separator:ga6cc5c5f1642d42f7479ba5907961811c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d1966f512373c5dafb83eaaa863e780"><td class="memItemLeft" align="right" valign="top"><a id="ga0d1966f512373c5dafb83eaaa863e780"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga0d1966f512373c5dafb83eaaa863e780">HArDCore2D::TangentFamily&lt; ScalarFamilyType &gt;::dimension</a> () const</td></tr>
<tr class="memdesc:ga0d1966f512373c5dafb83eaaa863e780"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the dimension of the family. <br /></td></tr>
<tr class="separator:ga0d1966f512373c5dafb83eaaa863e780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d7faeb3a4b06a79f495202fc9dbf4c2"><td class="memItemLeft" align="right" valign="top"><a id="ga6d7faeb3a4b06a79f495202fc9dbf4c2"></a>
FunctionValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga6d7faeb3a4b06a79f495202fc9dbf4c2">HArDCore2D::TangentFamily&lt; ScalarFamilyType &gt;::function</a> (size_t i, const VectorRd &amp;x) const</td></tr>
<tr class="memdesc:ga6d7faeb3a4b06a79f495202fc9dbf4c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the i-th basis function at point x. <br /></td></tr>
<tr class="separator:ga6d7faeb3a4b06a79f495202fc9dbf4c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb935c3f74623dbd29c124c0c6dc605e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#gadb935c3f74623dbd29c124c0c6dc605e">HArDCore2D::ShiftedBasis&lt; BasisType &gt;::ShiftedBasis</a> (const BasisType &amp;basis, const int shift)</td></tr>
<tr class="memdesc:gadb935c3f74623dbd29c124c0c6dc605e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="group__Basis.html#gadb935c3f74623dbd29c124c0c6dc605e">More...</a><br /></td></tr>
<tr class="separator:gadb935c3f74623dbd29c124c0c6dc605e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74ebe98de6bd42447c4743c784e8c601"><td class="memItemLeft" align="right" valign="top"><a id="ga74ebe98de6bd42447c4743c784e8c601"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga74ebe98de6bd42447c4743c784e8c601">HArDCore2D::ShiftedBasis&lt; BasisType &gt;::dimension</a> () const</td></tr>
<tr class="memdesc:ga74ebe98de6bd42447c4743c784e8c601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the dimension of the basis. <br /></td></tr>
<tr class="separator:ga74ebe98de6bd42447c4743c784e8c601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73529b85e8d087fdeee582e0744bf49a"><td class="memItemLeft" align="right" valign="top"><a id="ga73529b85e8d087fdeee582e0744bf49a"></a>
FunctionValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga73529b85e8d087fdeee582e0744bf49a">HArDCore2D::ShiftedBasis&lt; BasisType &gt;::function</a> (size_t i, const VectorRd &amp;x) const</td></tr>
<tr class="memdesc:ga73529b85e8d087fdeee582e0744bf49a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the i-th basis function at point x. <br /></td></tr>
<tr class="separator:ga73529b85e8d087fdeee582e0744bf49a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c06ac1c5648d70651308067df98c4c8"><td class="memItemLeft" align="right" valign="top"><a id="ga7c06ac1c5648d70651308067df98c4c8"></a>
GradientValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga7c06ac1c5648d70651308067df98c4c8">HArDCore2D::ShiftedBasis&lt; BasisType &gt;::gradient</a> (size_t i, const VectorRd &amp;x) const</td></tr>
<tr class="memdesc:ga7c06ac1c5648d70651308067df98c4c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the gradient of the i-th basis function at point x. <br /></td></tr>
<tr class="separator:ga7c06ac1c5648d70651308067df98c4c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cb372f9d9384f30cecd1beb4b5d62b7"><td class="memItemLeft" align="right" valign="top"><a id="ga7cb372f9d9384f30cecd1beb4b5d62b7"></a>
CurlValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga7cb372f9d9384f30cecd1beb4b5d62b7">HArDCore2D::ShiftedBasis&lt; BasisType &gt;::curl</a> (size_t i, const VectorRd &amp;x) const</td></tr>
<tr class="memdesc:ga7cb372f9d9384f30cecd1beb4b5d62b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the curl of the i-th basis function at point x. <br /></td></tr>
<tr class="separator:ga7cb372f9d9384f30cecd1beb4b5d62b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84d8719be3260330c3c2e80dbf1b4eed"><td class="memItemLeft" align="right" valign="top"><a id="ga84d8719be3260330c3c2e80dbf1b4eed"></a>
DivergenceValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga84d8719be3260330c3c2e80dbf1b4eed">HArDCore2D::ShiftedBasis&lt; BasisType &gt;::divergence</a> (size_t i, const VectorRd &amp;x) const</td></tr>
<tr class="memdesc:ga84d8719be3260330c3c2e80dbf1b4eed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the divergence of the i-th basis function at point x. <br /></td></tr>
<tr class="separator:ga84d8719be3260330c3c2e80dbf1b4eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c6a0bd9f6d2d6411762613b363f1716"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga3c6a0bd9f6d2d6411762613b363f1716">HArDCore2D::RestrictedBasis&lt; BasisType &gt;::RestrictedBasis</a> (const BasisType &amp;basis, const size_t &amp;<a class="el" href="group__Basis.html#ga5128f2da3cb58784d6ee7f4dffcacb90">dimension</a>)</td></tr>
<tr class="memdesc:ga3c6a0bd9f6d2d6411762613b363f1716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="group__Basis.html#ga3c6a0bd9f6d2d6411762613b363f1716">More...</a><br /></td></tr>
<tr class="separator:ga3c6a0bd9f6d2d6411762613b363f1716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5128f2da3cb58784d6ee7f4dffcacb90"><td class="memItemLeft" align="right" valign="top"><a id="ga5128f2da3cb58784d6ee7f4dffcacb90"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga5128f2da3cb58784d6ee7f4dffcacb90">HArDCore2D::RestrictedBasis&lt; BasisType &gt;::dimension</a> () const</td></tr>
<tr class="memdesc:ga5128f2da3cb58784d6ee7f4dffcacb90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the dimension of the basis. <br /></td></tr>
<tr class="separator:ga5128f2da3cb58784d6ee7f4dffcacb90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2c3c2be0cc528838e96a09ff1c0fe8d"><td class="memItemLeft" align="right" valign="top"><a id="gaf2c3c2be0cc528838e96a09ff1c0fe8d"></a>
const BasisType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#gaf2c3c2be0cc528838e96a09ff1c0fe8d">HArDCore2D::RestrictedBasis&lt; BasisType &gt;::ancestor</a> () const</td></tr>
<tr class="memdesc:gaf2c3c2be0cc528838e96a09ff1c0fe8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the underlying complete basis. <br /></td></tr>
<tr class="separator:gaf2c3c2be0cc528838e96a09ff1c0fe8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d2d6afdd27878c524490c2e4a9f0bc7"><td class="memItemLeft" align="right" valign="top"><a id="ga1d2d6afdd27878c524490c2e4a9f0bc7"></a>
FunctionValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga1d2d6afdd27878c524490c2e4a9f0bc7">HArDCore2D::RestrictedBasis&lt; BasisType &gt;::function</a> (size_t i, const VectorRd &amp;x) const</td></tr>
<tr class="memdesc:ga1d2d6afdd27878c524490c2e4a9f0bc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the i-th basis function at point x. <br /></td></tr>
<tr class="separator:ga1d2d6afdd27878c524490c2e4a9f0bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e3093c0bd8ca48ef8d37d8f7d302fed"><td class="memItemLeft" align="right" valign="top"><a id="ga8e3093c0bd8ca48ef8d37d8f7d302fed"></a>
GradientValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga8e3093c0bd8ca48ef8d37d8f7d302fed">HArDCore2D::RestrictedBasis&lt; BasisType &gt;::gradient</a> (size_t i, const VectorRd &amp;x) const</td></tr>
<tr class="memdesc:ga8e3093c0bd8ca48ef8d37d8f7d302fed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the gradient of the i-th basis function at point x. <br /></td></tr>
<tr class="separator:ga8e3093c0bd8ca48ef8d37d8f7d302fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81e5a6c78223c5fe9a1e05d47a7798f1"><td class="memItemLeft" align="right" valign="top"><a id="ga81e5a6c78223c5fe9a1e05d47a7798f1"></a>
CurlValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga81e5a6c78223c5fe9a1e05d47a7798f1">HArDCore2D::RestrictedBasis&lt; BasisType &gt;::curl</a> (size_t i, const VectorRd &amp;x) const</td></tr>
<tr class="memdesc:ga81e5a6c78223c5fe9a1e05d47a7798f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the curl of the i-th basis function at point x. <br /></td></tr>
<tr class="separator:ga81e5a6c78223c5fe9a1e05d47a7798f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa273301688a05d4f7e38cda0d1277212"><td class="memItemLeft" align="right" valign="top"><a id="gaa273301688a05d4f7e38cda0d1277212"></a>
DivergenceValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#gaa273301688a05d4f7e38cda0d1277212">HArDCore2D::RestrictedBasis&lt; BasisType &gt;::divergence</a> (size_t i, const VectorRd &amp;x) const</td></tr>
<tr class="memdesc:gaa273301688a05d4f7e38cda0d1277212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the divergence of the i-th basis function at point x. <br /></td></tr>
<tr class="separator:gaa273301688a05d4f7e38cda0d1277212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4177dd42cb8ac5499f6eae33965c0e69"><td class="memItemLeft" align="right" valign="top"><a id="ga4177dd42cb8ac5499f6eae33965c0e69"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga4177dd42cb8ac5499f6eae33965c0e69">HArDCore2D::GradientBasis&lt; BasisType &gt;::GradientBasis</a> (const BasisType &amp;basis)</td></tr>
<tr class="memdesc:ga4177dd42cb8ac5499f6eae33965c0e69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:ga4177dd42cb8ac5499f6eae33965c0e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga013a7a8c18e05623b1c9f6562f80c9e6"><td class="memItemLeft" align="right" valign="top"><a id="ga013a7a8c18e05623b1c9f6562f80c9e6"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga013a7a8c18e05623b1c9f6562f80c9e6">HArDCore2D::GradientBasis&lt; BasisType &gt;::dimension</a> () const</td></tr>
<tr class="memdesc:ga013a7a8c18e05623b1c9f6562f80c9e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the dimension of the basis. <br /></td></tr>
<tr class="separator:ga013a7a8c18e05623b1c9f6562f80c9e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e054975f7e1247ba66f08fa159dcf84"><td class="memItemLeft" align="right" valign="top"><a id="ga5e054975f7e1247ba66f08fa159dcf84"></a>
FunctionValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga5e054975f7e1247ba66f08fa159dcf84">HArDCore2D::GradientBasis&lt; BasisType &gt;::function</a> (size_t i, const VectorRd &amp;x) const</td></tr>
<tr class="memdesc:ga5e054975f7e1247ba66f08fa159dcf84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the i-th basis function at point x. <br /></td></tr>
<tr class="separator:ga5e054975f7e1247ba66f08fa159dcf84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ee54a87a2ae24213f0362fb673aeb65"><td class="memItemLeft" align="right" valign="top"><a id="ga1ee54a87a2ae24213f0362fb673aeb65"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga1ee54a87a2ae24213f0362fb673aeb65">HArDCore2D::CurlBasis&lt; BasisType &gt;::CurlBasis</a> (const BasisType &amp;basis)</td></tr>
<tr class="memdesc:ga1ee54a87a2ae24213f0362fb673aeb65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:ga1ee54a87a2ae24213f0362fb673aeb65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcda5adad24a9e075e75817a1f9726d6"><td class="memItemLeft" align="right" valign="top"><a id="gabcda5adad24a9e075e75817a1f9726d6"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#gabcda5adad24a9e075e75817a1f9726d6">HArDCore2D::CurlBasis&lt; BasisType &gt;::dimension</a> () const</td></tr>
<tr class="memdesc:gabcda5adad24a9e075e75817a1f9726d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the dimension of the basis. <br /></td></tr>
<tr class="separator:gabcda5adad24a9e075e75817a1f9726d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40093b82cad53b9e0c03b405ae2b90df"><td class="memItemLeft" align="right" valign="top"><a id="ga40093b82cad53b9e0c03b405ae2b90df"></a>
FunctionValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga40093b82cad53b9e0c03b405ae2b90df">HArDCore2D::CurlBasis&lt; BasisType &gt;::function</a> (size_t i, const VectorRd &amp;x) const</td></tr>
<tr class="memdesc:ga40093b82cad53b9e0c03b405ae2b90df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the i-th basis function at point x. <br /></td></tr>
<tr class="separator:ga40093b82cad53b9e0c03b405ae2b90df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef4345fecb3ca455b8d489b7ba52a1bd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#gaef4345fecb3ca455b8d489b7ba52a1bd">HArDCore2D::RolyComplBasisCell::RolyComplBasisCell</a> (const <a class="el" href="classHArDCore2D_1_1Cell.html">Cell</a> &amp;T, size_t degree)</td></tr>
<tr class="memdesc:gaef4345fecb3ca455b8d489b7ba52a1bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="group__Basis.html#gaef4345fecb3ca455b8d489b7ba52a1bd">More...</a><br /></td></tr>
<tr class="separator:gaef4345fecb3ca455b8d489b7ba52a1bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fb047c68c998f2592196b6caf5a837f"><td class="memItemLeft" align="right" valign="top"><a id="ga6fb047c68c998f2592196b6caf5a837f"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga6fb047c68c998f2592196b6caf5a837f">HArDCore2D::RolyComplBasisCell::dimension</a> () const</td></tr>
<tr class="memdesc:ga6fb047c68c998f2592196b6caf5a837f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dimension of the basis. <br /></td></tr>
<tr class="separator:ga6fb047c68c998f2592196b6caf5a837f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98c802c785e2b6ba96dd338c0ea079fd"><td class="memItemLeft" align="right" valign="top"><a id="ga98c802c785e2b6ba96dd338c0ea079fd"></a>
FunctionValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga98c802c785e2b6ba96dd338c0ea079fd">HArDCore2D::RolyComplBasisCell::function</a> (size_t i, const VectorRd &amp;x) const</td></tr>
<tr class="memdesc:ga98c802c785e2b6ba96dd338c0ea079fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the i-th basis function at point x. <br /></td></tr>
<tr class="separator:ga98c802c785e2b6ba96dd338c0ea079fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac105c6743fce4e5fb3fc799d80086bbf"><td class="memItemLeft" align="right" valign="top"><a id="gac105c6743fce4e5fb3fc799d80086bbf"></a>
DivergenceValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#gac105c6743fce4e5fb3fc799d80086bbf">HArDCore2D::RolyComplBasisCell::divergence</a> (size_t i, const VectorRd &amp;x) const</td></tr>
<tr class="memdesc:gac105c6743fce4e5fb3fc799d80086bbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the divergence of the i-th basis function at point x. <br /></td></tr>
<tr class="separator:gac105c6743fce4e5fb3fc799d80086bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d294c963cda7efe0b10bd82bc9b0b91"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga9d294c963cda7efe0b10bd82bc9b0b91">HArDCore2D::GolyComplBasisCell::GolyComplBasisCell</a> (const <a class="el" href="classHArDCore2D_1_1Cell.html">Cell</a> &amp;T, size_t degree)</td></tr>
<tr class="memdesc:ga9d294c963cda7efe0b10bd82bc9b0b91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="group__Basis.html#ga9d294c963cda7efe0b10bd82bc9b0b91">More...</a><br /></td></tr>
<tr class="separator:ga9d294c963cda7efe0b10bd82bc9b0b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55d9d9b8fd25fb21696fc89cd8a06537"><td class="memItemLeft" align="right" valign="top"><a id="ga55d9d9b8fd25fb21696fc89cd8a06537"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga55d9d9b8fd25fb21696fc89cd8a06537">HArDCore2D::GolyComplBasisCell::dimension</a> () const</td></tr>
<tr class="memdesc:ga55d9d9b8fd25fb21696fc89cd8a06537"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dimension of the basis. <br /></td></tr>
<tr class="separator:ga55d9d9b8fd25fb21696fc89cd8a06537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d2d8a3b77a082575c44237bed02c842"><td class="memItemLeft" align="right" valign="top"><a id="ga3d2d8a3b77a082575c44237bed02c842"></a>
FunctionValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga3d2d8a3b77a082575c44237bed02c842">HArDCore2D::GolyComplBasisCell::function</a> (size_t i, const VectorRd &amp;x) const</td></tr>
<tr class="memdesc:ga3d2d8a3b77a082575c44237bed02c842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the i-th basis function at point x. <br /></td></tr>
<tr class="separator:ga3d2d8a3b77a082575c44237bed02c842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45a16ffb93f83f41efa6f59659fd1544"><td class="memTemplParams" colspan="2">template&lt;typename outValue , typename inValue , typename FunctionType &gt; </td></tr>
<tr class="memitem:ga45a16ffb93f83f41efa6f59659fd1544"><td class="memTemplItemLeft" align="right" valign="top">boost::multi_array&lt; outValue, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga45a16ffb93f83f41efa6f59659fd1544">HArDCore2D::transform_values_quad</a> (const boost::multi_array&lt; inValue, 2 &gt; &amp;B_quad, const FunctionType &amp;F)</td></tr>
<tr class="memdesc:ga45a16ffb93f83f41efa6f59659fd1544"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes an array B_quad of values at quadrature nodes and applies the function F to all of them. F must take inValue and return outValue. The function must be called with outValue as template argument: transform_values_quad&lt;outValue&gt;(...)  <a href="group__Basis.html#ga45a16ffb93f83f41efa6f59659fd1544">More...</a><br /></td></tr>
<tr class="separator:ga45a16ffb93f83f41efa6f59659fd1544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1b1bedb394bfa0843347da693760691"><td class="memItemLeft" align="right" valign="top"><a id="gad1b1bedb394bfa0843347da693760691"></a>
static ReturnValue&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::detail::basis_evaluation_traits&lt; BasisType, Function &gt;::evaluate</b> (const BasisType &amp;basis, size_t i, const VectorRd &amp;x)</td></tr>
<tr class="separator:gad1b1bedb394bfa0843347da693760691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2991f0bf6c39fcc1ca9cc586235a84c"><td class="memItemLeft" align="right" valign="top"><a id="gad2991f0bf6c39fcc1ca9cc586235a84c"></a>
static ReturnValue&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::detail::basis_evaluation_traits&lt; BasisType, Function &gt;::evaluate</b> (const BasisType &amp;basis, size_t i, size_t iqn, const boost::multi_array&lt; ReturnValue, 2 &gt; &amp;ancestor_value_quad)</td></tr>
<tr class="separator:gad2991f0bf6c39fcc1ca9cc586235a84c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb1c26e922916f159b9e1eb123a0b53a"><td class="memItemLeft" align="right" valign="top"><a id="gafb1c26e922916f159b9e1eb123a0b53a"></a>
static ReturnValue&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::detail::basis_evaluation_traits&lt; BasisType, Gradient &gt;::evaluate</b> (const BasisType &amp;basis, size_t i, const VectorRd &amp;x)</td></tr>
<tr class="separator:gafb1c26e922916f159b9e1eb123a0b53a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace98edd94d6c29e818930dff7a2e07bd"><td class="memItemLeft" align="right" valign="top"><a id="gace98edd94d6c29e818930dff7a2e07bd"></a>
static ReturnValue&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::detail::basis_evaluation_traits&lt; BasisType, Gradient &gt;::evaluate</b> (const BasisType &amp;basis, size_t i, size_t iqn, const boost::multi_array&lt; ReturnValue, 2 &gt; &amp;ancestor_gradient_quad)</td></tr>
<tr class="separator:gace98edd94d6c29e818930dff7a2e07bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8e4677d16945866dc5ffc6d77de750e"><td class="memItemLeft" align="right" valign="top"><a id="gaa8e4677d16945866dc5ffc6d77de750e"></a>
static ReturnValue&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::detail::basis_evaluation_traits&lt; BasisType, Curl &gt;::evaluate</b> (const BasisType &amp;basis, size_t i, const VectorRd &amp;x)</td></tr>
<tr class="separator:gaa8e4677d16945866dc5ffc6d77de750e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33eabf8cc8a0a0d49f31bcd36bd83137"><td class="memItemLeft" align="right" valign="top"><a id="ga33eabf8cc8a0a0d49f31bcd36bd83137"></a>
static ReturnValue&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::detail::basis_evaluation_traits&lt; BasisType, Curl &gt;::evaluate</b> (const BasisType &amp;basis, size_t i, size_t iqn, const boost::multi_array&lt; ReturnValue, 2 &gt; &amp;ancestor_curl_quad)</td></tr>
<tr class="separator:ga33eabf8cc8a0a0d49f31bcd36bd83137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbc363ebd4854186c0ed682d098158bc"><td class="memItemLeft" align="right" valign="top"><a id="gacbc363ebd4854186c0ed682d098158bc"></a>
static ReturnValue&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::detail::basis_evaluation_traits&lt; BasisType, Divergence &gt;::evaluate</b> (const BasisType &amp;basis, size_t i, const VectorRd &amp;x)</td></tr>
<tr class="separator:gacbc363ebd4854186c0ed682d098158bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29bd9b33da8c88e0aa4f916cbd8b57e4"><td class="memItemLeft" align="right" valign="top"><a id="ga29bd9b33da8c88e0aa4f916cbd8b57e4"></a>
static ReturnValue&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::detail::basis_evaluation_traits&lt; BasisType, Divergence &gt;::evaluate</b> (const BasisType &amp;basis, size_t i, size_t iqn, const boost::multi_array&lt; ReturnValue, 2 &gt; &amp;ancestor_divergence_quad)</td></tr>
<tr class="separator:ga29bd9b33da8c88e0aa4f916cbd8b57e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8307d361c356c200cd7fe5458e165de1"><td class="memItemLeft" align="right" valign="top"><a id="ga8307d361c356c200cd7fe5458e165de1"></a>
static ReturnValue&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::detail::basis_evaluation_traits&lt; TensorizedVectorFamily&lt; ScalarBasisType, N &gt;, Function &gt;::evaluate</b> (const <a class="el" href="classHArDCore2D_1_1TensorizedVectorFamily.html">TensorizedVectorFamily</a>&lt; ScalarBasisType, N &gt; &amp;basis, size_t i, const VectorRd &amp;x)</td></tr>
<tr class="separator:ga8307d361c356c200cd7fe5458e165de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3f2b984f80a3b91f5aacd04d8f90e4e"><td class="memItemLeft" align="right" valign="top"><a id="gaf3f2b984f80a3b91f5aacd04d8f90e4e"></a>
static ReturnValue&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::detail::basis_evaluation_traits&lt; TensorizedVectorFamily&lt; ScalarBasisType, N &gt;, Function &gt;::evaluate</b> (const <a class="el" href="classHArDCore2D_1_1TensorizedVectorFamily.html">TensorizedVectorFamily</a>&lt; ScalarBasisType, N &gt; &amp;basis, size_t i, size_t iqn, const boost::multi_array&lt; double, 2 &gt; &amp;ancestor_basis_quad)</td></tr>
<tr class="separator:gaf3f2b984f80a3b91f5aacd04d8f90e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00734228471bd7fb7221abaf057cad62"><td class="memItemLeft" align="right" valign="top"><a id="ga00734228471bd7fb7221abaf057cad62"></a>
static ReturnValue&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::detail::basis_evaluation_traits&lt; TensorizedVectorFamily&lt; ScalarBasisType, N &gt;, Gradient &gt;::evaluate</b> (const <a class="el" href="classHArDCore2D_1_1TensorizedVectorFamily.html">TensorizedVectorFamily</a>&lt; ScalarBasisType, N &gt; &amp;basis, size_t i, const VectorRd &amp;x)</td></tr>
<tr class="separator:ga00734228471bd7fb7221abaf057cad62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70439cf358cf50fbb42ce7f8581488ba"><td class="memItemLeft" align="right" valign="top"><a id="ga70439cf358cf50fbb42ce7f8581488ba"></a>
static ReturnValue&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::detail::basis_evaluation_traits&lt; TensorizedVectorFamily&lt; ScalarBasisType, N &gt;, Gradient &gt;::evaluate</b> (const <a class="el" href="classHArDCore2D_1_1TensorizedVectorFamily.html">TensorizedVectorFamily</a>&lt; ScalarBasisType, N &gt; &amp;basis, size_t i, size_t iqn, const boost::multi_array&lt; VectorRd, 2 &gt; &amp;ancestor_basis_quad)</td></tr>
<tr class="separator:ga70439cf358cf50fbb42ce7f8581488ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fd5ef14846ad86b831b820fd00e103a"><td class="memItemLeft" align="right" valign="top"><a id="ga9fd5ef14846ad86b831b820fd00e103a"></a>
static ReturnValue&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::detail::basis_evaluation_traits&lt; TensorizedVectorFamily&lt; ScalarBasisType, N &gt;, Curl &gt;::evaluate</b> (const <a class="el" href="classHArDCore2D_1_1TensorizedVectorFamily.html">TensorizedVectorFamily</a>&lt; ScalarBasisType, N &gt; &amp;basis, size_t i, const VectorRd &amp;x)</td></tr>
<tr class="separator:ga9fd5ef14846ad86b831b820fd00e103a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81b8a5e841b0326b67345c01081e4dc9"><td class="memItemLeft" align="right" valign="top"><a id="ga81b8a5e841b0326b67345c01081e4dc9"></a>
static ReturnValue&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::detail::basis_evaluation_traits&lt; TensorizedVectorFamily&lt; ScalarBasisType, N &gt;, Curl &gt;::evaluate</b> (const <a class="el" href="classHArDCore2D_1_1TensorizedVectorFamily.html">TensorizedVectorFamily</a>&lt; ScalarBasisType, N &gt; &amp;basis, size_t i, size_t iqn, const boost::multi_array&lt; VectorRd, 2 &gt; &amp;ancestor_basis_quad)</td></tr>
<tr class="separator:ga81b8a5e841b0326b67345c01081e4dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf4b8143a2c820ee1f49f561e693a926"><td class="memItemLeft" align="right" valign="top"><a id="gaaf4b8143a2c820ee1f49f561e693a926"></a>
static ReturnValue&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::detail::basis_evaluation_traits&lt; TensorizedVectorFamily&lt; ScalarBasisType, N &gt;, Divergence &gt;::evaluate</b> (const <a class="el" href="classHArDCore2D_1_1TensorizedVectorFamily.html">TensorizedVectorFamily</a>&lt; ScalarBasisType, N &gt; &amp;basis, size_t i, const VectorRd &amp;x)</td></tr>
<tr class="separator:gaaf4b8143a2c820ee1f49f561e693a926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f21d7405088b600f0ea2ecd74fcb5ff"><td class="memItemLeft" align="right" valign="top"><a id="ga5f21d7405088b600f0ea2ecd74fcb5ff"></a>
static ReturnValue&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::detail::basis_evaluation_traits&lt; TensorizedVectorFamily&lt; ScalarBasisType, N &gt;, Divergence &gt;::evaluate</b> (const <a class="el" href="classHArDCore2D_1_1TensorizedVectorFamily.html">TensorizedVectorFamily</a>&lt; ScalarBasisType, N &gt; &amp;basis, size_t i, size_t iqn, const boost::multi_array&lt; VectorRd, 2 &gt; &amp;ancestor_basis_quad)</td></tr>
<tr class="separator:ga5f21d7405088b600f0ea2ecd74fcb5ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga736832acc897d00fc7e2a9c8ae2f3cf3"><td class="memItemLeft" align="right" valign="top"><a id="ga736832acc897d00fc7e2a9c8ae2f3cf3"></a>
static ReturnValue&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::detail::basis_evaluation_traits&lt; MatrixFamily&lt; ScalarBasisType, N &gt;, Function &gt;::evaluate</b> (const <a class="el" href="classHArDCore2D_1_1MatrixFamily.html">MatrixFamily</a>&lt; ScalarBasisType, N &gt; &amp;basis, size_t i, const VectorRd &amp;x)</td></tr>
<tr class="separator:ga736832acc897d00fc7e2a9c8ae2f3cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a67b30471c1cb7d79fc8849d40df527"><td class="memItemLeft" align="right" valign="top"><a id="ga3a67b30471c1cb7d79fc8849d40df527"></a>
static ReturnValue&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::detail::basis_evaluation_traits&lt; MatrixFamily&lt; ScalarBasisType, N &gt;, Function &gt;::evaluate</b> (const <a class="el" href="classHArDCore2D_1_1MatrixFamily.html">MatrixFamily</a>&lt; ScalarBasisType, N &gt; &amp;basis, size_t i, size_t iqn, const boost::multi_array&lt; double, 2 &gt; &amp;ancestor_basis_quad)</td></tr>
<tr class="separator:ga3a67b30471c1cb7d79fc8849d40df527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga169af1134195c1284cca13579c78bfa4"><td class="memItemLeft" align="right" valign="top"><a id="ga169af1134195c1284cca13579c78bfa4"></a>
static ReturnValue&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::detail::basis_evaluation_traits&lt; MatrixFamily&lt; ScalarBasisType, N &gt;, Divergence &gt;::evaluate</b> (const <a class="el" href="classHArDCore2D_1_1MatrixFamily.html">MatrixFamily</a>&lt; ScalarBasisType, N &gt; &amp;basis, size_t i, const VectorRd &amp;x)</td></tr>
<tr class="separator:ga169af1134195c1284cca13579c78bfa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5af1a61d38b626383dfef1b161b4b88"><td class="memItemLeft" align="right" valign="top"><a id="gaf5af1a61d38b626383dfef1b161b4b88"></a>
static ReturnValue&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::detail::basis_evaluation_traits&lt; MatrixFamily&lt; ScalarBasisType, N &gt;, Divergence &gt;::evaluate</b> (const <a class="el" href="classHArDCore2D_1_1MatrixFamily.html">MatrixFamily</a>&lt; ScalarBasisType, N &gt; &amp;basis, size_t i, size_t iqn, const boost::multi_array&lt; VectorRd, 2 &gt; &amp;ancestor_basis_quad)</td></tr>
<tr class="separator:gaf5af1a61d38b626383dfef1b161b4b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga687c3c9504c4b10c5a18654530980086"><td class="memTemplParams" colspan="2">template&lt;typename BasisType &gt; </td></tr>
<tr class="memitem:ga687c3c9504c4b10c5a18654530980086"><td class="memTemplItemLeft" align="right" valign="top">static boost::multi_array&lt; typename <a class="el" href="structHArDCore2D_1_1detail_1_1basis__evaluation__traits.html">detail::basis_evaluation_traits</a>&lt; BasisType, BasisFunction &gt;::ReturnValue, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga687c3c9504c4b10c5a18654530980086">HArDCore2D::evaluate_quad&lt; BasisFunction &gt;::compute</a> (const BasisType &amp;basis, const QuadratureRule &amp;quad)</td></tr>
<tr class="memdesc:ga687c3c9504c4b10c5a18654530980086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic basis evaluation.  <a href="group__Basis.html#ga687c3c9504c4b10c5a18654530980086">More...</a><br /></td></tr>
<tr class="separator:ga687c3c9504c4b10c5a18654530980086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06cedf0c3440b94b9974922c72ea7c11"><td class="memTemplParams" colspan="2">template&lt;typename BasisType &gt; </td></tr>
<tr class="memitem:ga06cedf0c3440b94b9974922c72ea7c11"><td class="memTemplItemLeft" align="right" valign="top">static boost::multi_array&lt; typename <a class="el" href="structHArDCore2D_1_1detail_1_1basis__evaluation__traits.html">detail::basis_evaluation_traits</a>&lt; <a class="el" href="classHArDCore2D_1_1Family.html">Family</a>&lt; BasisType &gt;, BasisFunction &gt;::ReturnValue, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga06cedf0c3440b94b9974922c72ea7c11">HArDCore2D::evaluate_quad&lt; BasisFunction &gt;::compute</a> (const <a class="el" href="classHArDCore2D_1_1Family.html">Family</a>&lt; BasisType &gt; &amp;basis, const QuadratureRule &amp;quad)</td></tr>
<tr class="memdesc:ga06cedf0c3440b94b9974922c72ea7c11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a '<a class="el" href="classHArDCore2D_1_1Family.html">Family</a>' of functions at quadrature nodes (optimised compared the generic basis evaluation, to avoid computing several times the ancestor basis at the quadrature nodes)  <a href="group__Basis.html#ga06cedf0c3440b94b9974922c72ea7c11">More...</a><br /></td></tr>
<tr class="separator:ga06cedf0c3440b94b9974922c72ea7c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e707628cf7f51dd4ecf63182eea847a"><td class="memTemplParams" colspan="2">template&lt;typename BasisType , size_t N&gt; </td></tr>
<tr class="memitem:ga2e707628cf7f51dd4ecf63182eea847a"><td class="memTemplItemLeft" align="right" valign="top">static boost::multi_array&lt; typename <a class="el" href="structHArDCore2D_1_1detail_1_1basis__evaluation__traits.html">detail::basis_evaluation_traits</a>&lt; <a class="el" href="classHArDCore2D_1_1TensorizedVectorFamily.html">TensorizedVectorFamily</a>&lt; BasisType, N &gt;, BasisFunction &gt;::ReturnValue, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga2e707628cf7f51dd4ecf63182eea847a">HArDCore2D::evaluate_quad&lt; BasisFunction &gt;::compute</a> (const <a class="el" href="classHArDCore2D_1_1TensorizedVectorFamily.html">TensorizedVectorFamily</a>&lt; BasisType, N &gt; &amp;basis, const QuadratureRule &amp;quad)</td></tr>
<tr class="memdesc:ga2e707628cf7f51dd4ecf63182eea847a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a tensorized family at quadrature nodes (optimised compared the generic basis evaluation, to avoid computing several times the ancestor basis at the quadrature nodes)  <a href="group__Basis.html#ga2e707628cf7f51dd4ecf63182eea847a">More...</a><br /></td></tr>
<tr class="separator:ga2e707628cf7f51dd4ecf63182eea847a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77e7551793be854d7b654addf292aa6b"><td class="memTemplParams" colspan="2">template&lt;typename BasisType , size_t N&gt; </td></tr>
<tr class="memitem:ga77e7551793be854d7b654addf292aa6b"><td class="memTemplItemLeft" align="right" valign="top">static boost::multi_array&lt; typename <a class="el" href="structHArDCore2D_1_1detail_1_1basis__evaluation__traits.html">detail::basis_evaluation_traits</a>&lt; <a class="el" href="classHArDCore2D_1_1MatrixFamily.html">MatrixFamily</a>&lt; BasisType, N &gt;, BasisFunction &gt;::ReturnValue, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga77e7551793be854d7b654addf292aa6b">HArDCore2D::evaluate_quad&lt; BasisFunction &gt;::compute</a> (const <a class="el" href="classHArDCore2D_1_1MatrixFamily.html">MatrixFamily</a>&lt; BasisType, N &gt; &amp;basis, const QuadratureRule &amp;quad)</td></tr>
<tr class="memdesc:ga77e7551793be854d7b654addf292aa6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a Matrix family at quadrature nodes (optimised compared the generic basis evaluation, to avoid computing several times the ancestor basis at the quadrature nodes)  <a href="group__Basis.html#ga77e7551793be854d7b654addf292aa6b">More...</a><br /></td></tr>
<tr class="separator:ga77e7551793be854d7b654addf292aa6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ea7809705d01c7cf6bca57a457a44a4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga9ea7809705d01c7cf6bca57a457a44a4"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga9ea7809705d01c7cf6bca57a457a44a4">HArDCore2D::gram_schmidt</a> (boost::multi_array&lt; T, 2 &gt; &amp;basis_eval, const std::function&lt; double(size_t, size_t)&gt; &amp;inner_product)</td></tr>
<tr class="separator:ga9ea7809705d01c7cf6bca57a457a44a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5363b354f8dce20ca199459fe4074fda"><td class="memItemLeft" align="right" valign="top"><a id="ga5363b354f8dce20ca199459fe4074fda"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga5363b354f8dce20ca199459fe4074fda">HArDCore2D::scalar_product</a> (const double &amp;x, const double &amp;y)</td></tr>
<tr class="memdesc:ga5363b354f8dce20ca199459fe4074fda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar product between two reals. <br /></td></tr>
<tr class="separator:ga5363b354f8dce20ca199459fe4074fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1566133b908e08f82d4598114bf10f3"><td class="memItemLeft" align="right" valign="top"><a id="gad1566133b908e08f82d4598114bf10f3"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#gad1566133b908e08f82d4598114bf10f3">HArDCore2D::scalar_product</a> (const VectorRd &amp;x, const VectorRd &amp;y)</td></tr>
<tr class="memdesc:gad1566133b908e08f82d4598114bf10f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar product between two vectors. <br /></td></tr>
<tr class="separator:gad1566133b908e08f82d4598114bf10f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25065a0ea49bad672154b0a695923f22"><td class="memTemplParams" colspan="2"><a id="ga25065a0ea49bad672154b0a695923f22"></a>
template&lt;int N&gt; </td></tr>
<tr class="memitem:ga25065a0ea49bad672154b0a695923f22"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga25065a0ea49bad672154b0a695923f22">HArDCore2D::scalar_product</a> (const Eigen::Matrix&lt; double, N, N &gt; &amp;x, const Eigen::Matrix&lt; double, N, N &gt; &amp;y)</td></tr>
<tr class="memdesc:ga25065a0ea49bad672154b0a695923f22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar product between two matrices. <br /></td></tr>
<tr class="separator:ga25065a0ea49bad672154b0a695923f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f8b571925236c4b7ebe6afd77d5e4b5"><td class="memTemplParams" colspan="2">template&lt;typename Value &gt; </td></tr>
<tr class="memitem:ga2f8b571925236c4b7ebe6afd77d5e4b5"><td class="memTemplItemLeft" align="right" valign="top">boost::multi_array&lt; double, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga2f8b571925236c4b7ebe6afd77d5e4b5">HArDCore2D::scalar_product</a> (const boost::multi_array&lt; Value, 2 &gt; &amp;basis_quad, const Value &amp;v)</td></tr>
<tr class="memdesc:ga2f8b571925236c4b7ebe6afd77d5e4b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This overloading of the scalar_product function computes the scalar product between an evaluation of a basis and a constant value; both basis values and constant value must be of type Value.  <a href="group__Basis.html#ga2f8b571925236c4b7ebe6afd77d5e4b5">More...</a><br /></td></tr>
<tr class="separator:ga2f8b571925236c4b7ebe6afd77d5e4b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a5604879e905ecb08cbf4dda5d9a33c"><td class="memTemplParams" colspan="2">template&lt;typename BasisType &gt; </td></tr>
<tr class="memitem:ga3a5604879e905ecb08cbf4dda5d9a33c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classHArDCore2D_1_1Family.html">Family</a>&lt; BasisType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga3a5604879e905ecb08cbf4dda5d9a33c">HArDCore2D::l2_orthonormalize</a> (const BasisType &amp;basis, const QuadratureRule &amp;qr, boost::multi_array&lt; typename BasisType::FunctionValue, 2 &gt; &amp;basis_quad)</td></tr>
<tr class="memdesc:ga3a5604879e905ecb08cbf4dda5d9a33c"><td class="mdescLeft">&#160;</td><td class="mdescRight">\(L^2\)-orthonormalization: simply consists in using <a class="el" href="group__Basis.html#ga9ea7809705d01c7cf6bca57a457a44a4">gram_schmidt()</a> with the specific l2 inner product  <a href="group__Basis.html#ga3a5604879e905ecb08cbf4dda5d9a33c">More...</a><br /></td></tr>
<tr class="separator:ga3a5604879e905ecb08cbf4dda5d9a33c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29885facf8b5a576e7e0b609d1e3124f"><td class="memTemplParams" colspan="2">template&lt;typename FunctionValue &gt; </td></tr>
<tr class="memitem:ga29885facf8b5a576e7e0b609d1e3124f"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga29885facf8b5a576e7e0b609d1e3124f">HArDCore2D::compute_gram_matrix</a> (const boost::multi_array&lt; FunctionValue, 2 &gt; &amp;B1, const boost::multi_array&lt; FunctionValue, 2 &gt; &amp;B2, const QuadratureRule &amp;qr, const size_t nrows, const size_t ncols, const std::string sym=&quot;nonsym&quot;)</td></tr>
<tr class="memdesc:ga29885facf8b5a576e7e0b609d1e3124f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Gram-like matrix given the evaluation of two families of functions at quadrature nodes. This templated function is very generic, and thus not the most efficient. More efficient overloads are provided for double- or Vector2d-valued families.  <a href="group__Basis.html#ga29885facf8b5a576e7e0b609d1e3124f">More...</a><br /></td></tr>
<tr class="separator:ga29885facf8b5a576e7e0b609d1e3124f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafea1bf5033abb255fd6b73a3a30bf09e"><td class="memTemplParams" colspan="2">template&lt;typename FunctionValue &gt; </td></tr>
<tr class="memitem:gafea1bf5033abb255fd6b73a3a30bf09e"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Basis.html#gafea1bf5033abb255fd6b73a3a30bf09e">HArDCore2D::compute_gram_matrix</a> (const boost::multi_array&lt; FunctionValue, 2 &gt; &amp;B1, const boost::multi_array&lt; FunctionValue, 2 &gt; &amp;B2, const QuadratureRule &amp;qr, const std::string sym=&quot;nonsym&quot;)</td></tr>
<tr class="memdesc:gafea1bf5033abb255fd6b73a3a30bf09e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Gram-like matrix given the evaluation of two families of functions at quadrature nodes. This version calls the generic one with nrows = nb of elements in family B1 and ncols = nb of elements in family B2.  <a href="group__Basis.html#gafea1bf5033abb255fd6b73a3a30bf09e">More...</a><br /></td></tr>
<tr class="separator:gafea1bf5033abb255fd6b73a3a30bf09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c65c290a977d9d35ae51d6edde392a8"><td class="memTemplParams" colspan="2">template&lt;typename FunctionValue &gt; </td></tr>
<tr class="memitem:ga0c65c290a977d9d35ae51d6edde392a8"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga0c65c290a977d9d35ae51d6edde392a8">HArDCore2D::compute_gram_matrix</a> (const boost::multi_array&lt; FunctionValue, 2 &gt; &amp;B, const QuadratureRule &amp;qr)</td></tr>
<tr class="memdesc:ga0c65c290a977d9d35ae51d6edde392a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Gram matrix given the evaluation of one family of functions at quadrature nodes. Consists in calling the generic templated version with B1=B2.  <a href="group__Basis.html#ga0c65c290a977d9d35ae51d6edde392a8">More...</a><br /></td></tr>
<tr class="separator:ga0c65c290a977d9d35ae51d6edde392a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56ea5a2eec9e5f2534c5ea34c6f8e973"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga56ea5a2eec9e5f2534c5ea34c6f8e973">HArDCore2D::compute_gram_matrix</a> (const boost::multi_array&lt; VectorRd, 2 &gt; &amp;B1, const boost::multi_array&lt; double, 2 &gt; &amp;B2, const QuadratureRule &amp;qr)</td></tr>
<tr class="memdesc:ga56ea5a2eec9e5f2534c5ea34c6f8e973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Gram-like matrix given a family of vector-valued and one of scalar-valued functions by tensorizing the latter.  <a href="group__Basis.html#ga56ea5a2eec9e5f2534c5ea34c6f8e973">More...</a><br /></td></tr>
<tr class="separator:ga56ea5a2eec9e5f2534c5ea34c6f8e973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90eb6f12ab8129f7a8307bcd827b2f00"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga90eb6f12ab8129f7a8307bcd827b2f00">HArDCore2D::compute_gram_matrix</a> (const boost::multi_array&lt; double, 2 &gt; &amp;B1, const boost::multi_array&lt; double, 2 &gt; &amp;B2, const QuadratureRule &amp;qr, const size_t nrows, const size_t ncols, const std::string sym=&quot;nonsym&quot;)</td></tr>
<tr class="memdesc:ga90eb6f12ab8129f7a8307bcd827b2f00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Gram-like matrix given the evaluation of two families of functions at quadrature nodes. This version is an overload for double-valued families, more efficient than the generic templated version.  <a href="group__Basis.html#ga90eb6f12ab8129f7a8307bcd827b2f00">More...</a><br /></td></tr>
<tr class="separator:ga90eb6f12ab8129f7a8307bcd827b2f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16b838fc438f0935a5fc7706d83cf662"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga16b838fc438f0935a5fc7706d83cf662">HArDCore2D::compute_gram_matrix</a> (const boost::multi_array&lt; double, 2 &gt; &amp;B1, const boost::multi_array&lt; double, 2 &gt; &amp;B2, const QuadratureRule &amp;qr, const std::string sym=&quot;nonsym&quot;)</td></tr>
<tr class="memdesc:ga16b838fc438f0935a5fc7706d83cf662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Gram-like matrix given the evaluation of two families of functions at quadrature nodes. Consists in calling the double-valued version with nrows = nb of elements in B1, ncols = nb of elements in B2.  <a href="group__Basis.html#ga16b838fc438f0935a5fc7706d83cf662">More...</a><br /></td></tr>
<tr class="separator:ga16b838fc438f0935a5fc7706d83cf662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81188afa6341cae65e11dcd3c560d027"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga81188afa6341cae65e11dcd3c560d027">HArDCore2D::compute_gram_matrix</a> (const boost::multi_array&lt; VectorRd, 2 &gt; &amp;B1, const boost::multi_array&lt; VectorRd, 2 &gt; &amp;B2, const QuadratureRule &amp;qr, const size_t nrows, const size_t ncols, const std::string sym=&quot;nonsym&quot;)</td></tr>
<tr class="memdesc:ga81188afa6341cae65e11dcd3c560d027"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Gram-like matrix given the evaluation of two families of functions at quadrature nodes. This version is an overload for Vector2d-valued families, more efficient than the generic templated version.  <a href="group__Basis.html#ga81188afa6341cae65e11dcd3c560d027">More...</a><br /></td></tr>
<tr class="separator:ga81188afa6341cae65e11dcd3c560d027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf355214aec1e4ef71621a7d339415ae1"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#gaf355214aec1e4ef71621a7d339415ae1">HArDCore2D::compute_gram_matrix</a> (const boost::multi_array&lt; VectorRd, 2 &gt; &amp;B1, const boost::multi_array&lt; VectorRd, 2 &gt; &amp;B2, const QuadratureRule &amp;qr, const std::string sym=&quot;nonsym&quot;)</td></tr>
<tr class="memdesc:gaf355214aec1e4ef71621a7d339415ae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Gram-like matrix given the evaluation of two families of functions at quadrature nodes. Consists in calling the Vector2d-valued version with nrows = nb of elements in B1, ncols = nb of elements in B2.  <a href="group__Basis.html#gaf355214aec1e4ef71621a7d339415ae1">More...</a><br /></td></tr>
<tr class="separator:gaf355214aec1e4ef71621a7d339415ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1edb7f00f8048d22ce79e63a202a8594"><td class="memTemplParams" colspan="2">template&lt;typename ScalarFamilyType , size_t N&gt; </td></tr>
<tr class="memitem:ga1edb7f00f8048d22ce79e63a202a8594"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga1edb7f00f8048d22ce79e63a202a8594">HArDCore2D::compute_gram_matrix</a> (const <a class="el" href="classHArDCore2D_1_1MatrixFamily.html">MatrixFamily</a>&lt; ScalarFamilyType, N &gt; &amp;MatFam, const boost::multi_array&lt; double, 2 &gt; &amp;scalar_family_quad, const QuadratureRule &amp;qr)</td></tr>
<tr class="memdesc:ga1edb7f00f8048d22ce79e63a202a8594"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Gram-like matrix for a <a class="el" href="classHArDCore2D_1_1MatrixFamily.html" title="Matrix family obtained from a scalar family.">MatrixFamily</a>. This overload is more efficient than the generic function as it only computes the gram matrix of the underlying scalar family, and then creates the bloc-diagonal gram matrix of the <a class="el" href="classHArDCore2D_1_1MatrixFamily.html" title="Matrix family obtained from a scalar family.">MatrixFamily</a> (which is indeed bloc diagonal given the choice of m_E elements in this class).  <a href="group__Basis.html#ga1edb7f00f8048d22ce79e63a202a8594">More...</a><br /></td></tr>
<tr class="separator:ga1edb7f00f8048d22ce79e63a202a8594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1f24a4a88d877b43abcd2df0592f1c2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gad1f24a4a88d877b43abcd2df0592f1c2"><td class="memTemplItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Basis.html#gad1f24a4a88d877b43abcd2df0592f1c2">HArDCore2D::integrate</a> (const <a class="el" href="group__Basis.html#gab1e36fbf129c707351e533ee43579432">FType</a>&lt; T &gt; &amp;f, const <a class="el" href="group__Basis.html#ga41970d25ff5ffdc77e1368ee5ce03bd4">BasisQuad</a>&lt; T &gt; &amp;B, const QuadratureRule &amp;qr, size_t n_rows=0)</td></tr>
<tr class="memdesc:gad1f24a4a88d877b43abcd2df0592f1c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the integral of a given function against all functions from a family.  <a href="group__Basis.html#gad1f24a4a88d877b43abcd2df0592f1c2">More...</a><br /></td></tr>
<tr class="separator:gad1f24a4a88d877b43abcd2df0592f1c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac450f5f0e9ac39ef61e8b3fda75c8931"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gac450f5f0e9ac39ef61e8b3fda75c8931"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Basis.html#gac450f5f0e9ac39ef61e8b3fda75c8931">HArDCore2D::compute_weighted_gram_matrix</a> (const <a class="el" href="group__Basis.html#gab1e36fbf129c707351e533ee43579432">FType</a>&lt; U &gt; &amp;f, const <a class="el" href="group__Basis.html#ga41970d25ff5ffdc77e1368ee5ce03bd4">BasisQuad</a>&lt; T &gt; &amp;B1, const <a class="el" href="group__Basis.html#ga41970d25ff5ffdc77e1368ee5ce03bd4">BasisQuad</a>&lt; T &gt; &amp;B2, const QuadratureRule &amp;qr, size_t n_rows=0, size_t n_cols=0, const std::string sym=&quot;nonsym&quot;)</td></tr>
<tr class="memdesc:gac450f5f0e9ac39ef61e8b3fda75c8931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Gram-like matrix of integrals (f phi_i, phi_j)  <a href="group__Basis.html#gac450f5f0e9ac39ef61e8b3fda75c8931">More...</a><br /></td></tr>
<tr class="separator:gac450f5f0e9ac39ef61e8b3fda75c8931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga167107aa2e92a2656ded2e8cafa7e59d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga167107aa2e92a2656ded2e8cafa7e59d"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga167107aa2e92a2656ded2e8cafa7e59d">HArDCore2D::compute_weighted_gram_matrix</a> (const <a class="el" href="group__Basis.html#gab1e36fbf129c707351e533ee43579432">FType</a>&lt; U &gt; &amp;f, const <a class="el" href="group__Basis.html#ga41970d25ff5ffdc77e1368ee5ce03bd4">BasisQuad</a>&lt; T &gt; &amp;B1, const <a class="el" href="group__Basis.html#ga41970d25ff5ffdc77e1368ee5ce03bd4">BasisQuad</a>&lt; T &gt; &amp;B2, const QuadratureRule &amp;qr, const std::string sym)</td></tr>
<tr class="memdesc:ga167107aa2e92a2656ded2e8cafa7e59d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Gram-like matrix of integrals (f phi_i, phi_j)  <a href="group__Basis.html#ga167107aa2e92a2656ded2e8cafa7e59d">More...</a><br /></td></tr>
<tr class="separator:ga167107aa2e92a2656ded2e8cafa7e59d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga720d988c2c8cdf49c96687d63cc13d7e"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga720d988c2c8cdf49c96687d63cc13d7e">HArDCore2D::compute_weighted_gram_matrix</a> (const <a class="el" href="group__Basis.html#gab1e36fbf129c707351e533ee43579432">FType</a>&lt; VectorRd &gt; &amp;f, const <a class="el" href="group__Basis.html#ga41970d25ff5ffdc77e1368ee5ce03bd4">BasisQuad</a>&lt; VectorRd &gt; &amp;B1, const <a class="el" href="group__Basis.html#ga41970d25ff5ffdc77e1368ee5ce03bd4">BasisQuad</a>&lt; double &gt; &amp;B2, const QuadratureRule &amp;qr, size_t n_rows=0, size_t n_cols=0)</td></tr>
<tr class="memdesc:ga720d988c2c8cdf49c96687d63cc13d7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Gram-like matrix of integrals (f dot phi_i, phi_j)  <a href="group__Basis.html#ga720d988c2c8cdf49c96687d63cc13d7e">More...</a><br /></td></tr>
<tr class="separator:ga720d988c2c8cdf49c96687d63cc13d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8ed4f83013c1957b10c920a57021406"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#gad8ed4f83013c1957b10c920a57021406">HArDCore2D::compute_weighted_gram_matrix</a> (const <a class="el" href="group__Basis.html#gab1e36fbf129c707351e533ee43579432">FType</a>&lt; VectorRd &gt; &amp;f, const <a class="el" href="group__Basis.html#ga41970d25ff5ffdc77e1368ee5ce03bd4">BasisQuad</a>&lt; double &gt; &amp;B1, const <a class="el" href="group__Basis.html#ga41970d25ff5ffdc77e1368ee5ce03bd4">BasisQuad</a>&lt; VectorRd &gt; &amp;B2, const QuadratureRule &amp;qr, size_t n_rows=0, size_t n_cols=0)</td></tr>
<tr class="memdesc:gad8ed4f83013c1957b10c920a57021406"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Gram-like matrix of integrals (phi_i, f dot phi_j)  <a href="group__Basis.html#gad8ed4f83013c1957b10c920a57021406">More...</a><br /></td></tr>
<tr class="separator:gad8ed4f83013c1957b10c920a57021406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d085bfe7e819ade34b54ec812919dda"><td class="memTemplParams" colspan="2">template&lt;typename Value &gt; </td></tr>
<tr class="memitem:ga1d085bfe7e819ade34b54ec812919dda"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga1d085bfe7e819ade34b54ec812919dda">HArDCore2D::compute_closure_matrix</a> (const boost::multi_array&lt; Value, 2 &gt; &amp;f_quad, const boost::multi_array&lt; Value, 2 &gt; &amp;g_quad, const QuadratureRule &amp;qr_f, const QuadratureRule &amp;qr_g)</td></tr>
<tr class="memdesc:ga1d085bfe7e819ade34b54ec812919dda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes closure equation matrices, from evaluations at quadrature nodes. For two families of functions \((f_i)\) and \((g_j)\) with values in some space E, this routine computes the matrix \((\int f_i)\cdot(\int g_j)\) where \(\cdot\) is the dot product in E.  <a href="group__Basis.html#ga1d085bfe7e819ade34b54ec812919dda">More...</a><br /></td></tr>
<tr class="separator:ga1d085bfe7e819ade34b54ec812919dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28c35940e00abae0be3c53c3d37cdb63"><td class="memTemplParams" colspan="2">template&lt;typename Value &gt; </td></tr>
<tr class="memitem:ga28c35940e00abae0be3c53c3d37cdb63"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga28c35940e00abae0be3c53c3d37cdb63">HArDCore2D::compute_closure_matrix</a> (const boost::multi_array&lt; Value, 2 &gt; &amp;f_quad, const boost::multi_array&lt; Value, 2 &gt; &amp;g_quad, const QuadratureRule &amp;qr)</td></tr>
<tr class="memdesc:ga28c35940e00abae0be3c53c3d37cdb63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes closure equation matrices. Overload of the previous one when qr_f=qr_g.  <a href="group__Basis.html#ga28c35940e00abae0be3c53c3d37cdb63">More...</a><br /></td></tr>
<tr class="separator:ga28c35940e00abae0be3c53c3d37cdb63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga423a192827899636b148ba6c2857ea35"><td class="memTemplParams" colspan="2">template&lt;typename Value &gt; </td></tr>
<tr class="memitem:ga423a192827899636b148ba6c2857ea35"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga423a192827899636b148ba6c2857ea35">HArDCore2D::compute_closure_matrix</a> (const boost::multi_array&lt; Value, 2 &gt; &amp;f_quad, const QuadratureRule &amp;qr)</td></tr>
<tr class="memdesc:ga423a192827899636b148ba6c2857ea35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes closure equation matrices. Overload of the previous one when f=g.  <a href="group__Basis.html#ga423a192827899636b148ba6c2857ea35">More...</a><br /></td></tr>
<tr class="separator:ga423a192827899636b148ba6c2857ea35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga650f15db9b781f0ad398e54d96a5ba39"><td class="memTemplParams" colspan="2">template&lt;typename BasisType &gt; </td></tr>
<tr class="memitem:ga650f15db9b781f0ad398e54d96a5ba39"><td class="memTemplItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga650f15db9b781f0ad398e54d96a5ba39">HArDCore2D::l2_projection</a> (const std::function&lt; typename BasisType::FunctionValue(const VectorRd &amp;)&gt; &amp;f, const BasisType &amp;basis, QuadratureRule &amp;quad, const boost::multi_array&lt; typename BasisType::FunctionValue, 2 &gt; &amp;basis_quad)</td></tr>
<tr class="memdesc:ga650f15db9b781f0ad398e54d96a5ba39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the L2-projection of a function.  <a href="group__Basis.html#ga650f15db9b781f0ad398e54d96a5ba39">More...</a><br /></td></tr>
<tr class="separator:ga650f15db9b781f0ad398e54d96a5ba39"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga99ab631a06b5d5a5f9f9673883c92ffe"><td class="memItemLeft" align="right" valign="top"><a id="ga99ab631a06b5d5a5f9f9673883c92ffe"></a>
constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga99ab631a06b5d5a5f9f9673883c92ffe">HArDCore2D::dimspace</a> = 2</td></tr>
<tr class="memdesc:ga99ab631a06b5d5a5f9f9673883c92ffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dimension, and generic types for vector in correct dimension (makes it easier to translate a code between 2D and 3D) <br /></td></tr>
<tr class="separator:ga99ab631a06b5d5a5f9f9673883c92ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2e7be051d395b2467975540f83d2665"><td class="memItemLeft" align="right" valign="top"><a id="gaa2e7be051d395b2467975540f83d2665"></a>
static const TensorRankE&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::MonomialScalarBasisCell::tensorRank</b> = Scalar</td></tr>
<tr class="separator:gaa2e7be051d395b2467975540f83d2665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0f6b3726df8161c638761d398a4aa4e"><td class="memItemLeft" align="right" valign="top"><a id="gac0f6b3726df8161c638761d398a4aa4e"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::MonomialScalarBasisCell::hasFunction</b> = true</td></tr>
<tr class="separator:gac0f6b3726df8161c638761d398a4aa4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb26517e60d4ab841e21ca4a71a9c685"><td class="memItemLeft" align="right" valign="top"><a id="gadb26517e60d4ab841e21ca4a71a9c685"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::MonomialScalarBasisCell::hasGradient</b> = true</td></tr>
<tr class="separator:gadb26517e60d4ab841e21ca4a71a9c685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1c39fee1ff92d9a2c6654dcff408b13"><td class="memItemLeft" align="right" valign="top"><a id="gaf1c39fee1ff92d9a2c6654dcff408b13"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::MonomialScalarBasisCell::hasCurl</b> = true</td></tr>
<tr class="separator:gaf1c39fee1ff92d9a2c6654dcff408b13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga188cf489655ee1dcbf4fcf52060d457c"><td class="memItemLeft" align="right" valign="top"><a id="ga188cf489655ee1dcbf4fcf52060d457c"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::MonomialScalarBasisCell::hasDivergence</b> = false</td></tr>
<tr class="separator:ga188cf489655ee1dcbf4fcf52060d457c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafad80154f0c46b6132980c3edf9378a0"><td class="memItemLeft" align="right" valign="top"><a id="gafad80154f0c46b6132980c3edf9378a0"></a>
static const TensorRankE&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::MonomialScalarBasisEdge::tensorRank</b> = Scalar</td></tr>
<tr class="separator:gafad80154f0c46b6132980c3edf9378a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga069544258c246a19a7574f22074fa4ee"><td class="memItemLeft" align="right" valign="top"><a id="ga069544258c246a19a7574f22074fa4ee"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::MonomialScalarBasisEdge::hasFunction</b> = true</td></tr>
<tr class="separator:ga069544258c246a19a7574f22074fa4ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98b138ce500257ca01b37a6cc62cced7"><td class="memItemLeft" align="right" valign="top"><a id="ga98b138ce500257ca01b37a6cc62cced7"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::MonomialScalarBasisEdge::hasGradient</b> = true</td></tr>
<tr class="separator:ga98b138ce500257ca01b37a6cc62cced7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga361073f6de474dfbc1c4aaa685220245"><td class="memItemLeft" align="right" valign="top"><a id="ga361073f6de474dfbc1c4aaa685220245"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::MonomialScalarBasisEdge::hasCurl</b> = false</td></tr>
<tr class="separator:ga361073f6de474dfbc1c4aaa685220245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga351c69a9068b7cae877fd1d4d369fabb"><td class="memItemLeft" align="right" valign="top"><a id="ga351c69a9068b7cae877fd1d4d369fabb"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::MonomialScalarBasisEdge::hasDivergence</b> = false</td></tr>
<tr class="separator:ga351c69a9068b7cae877fd1d4d369fabb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7a0bf7e235f447facbea1470237a09e"><td class="memItemLeft" align="right" valign="top"><a id="gae7a0bf7e235f447facbea1470237a09e"></a>
static const TensorRankE&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::Family&lt; BasisType &gt;::tensorRank</b> = BasisType::tensorRank</td></tr>
<tr class="separator:gae7a0bf7e235f447facbea1470237a09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadadcc5cd716933a3b1d54794b860bdcc"><td class="memItemLeft" align="right" valign="top"><a id="gadadcc5cd716933a3b1d54794b860bdcc"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::Family&lt; BasisType &gt;::hasFunction</b> = BasisType::hasFunction</td></tr>
<tr class="separator:gadadcc5cd716933a3b1d54794b860bdcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae39bd5582b1fa4926b4f6eb2143cb8b7"><td class="memItemLeft" align="right" valign="top"><a id="gae39bd5582b1fa4926b4f6eb2143cb8b7"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::Family&lt; BasisType &gt;::hasGradient</b> = BasisType::hasGradient</td></tr>
<tr class="separator:gae39bd5582b1fa4926b4f6eb2143cb8b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6193ca9c9f178fe6bfa2f0d85ba86b1"><td class="memItemLeft" align="right" valign="top"><a id="gaa6193ca9c9f178fe6bfa2f0d85ba86b1"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::Family&lt; BasisType &gt;::hasCurl</b> = BasisType::hasCurl</td></tr>
<tr class="separator:gaa6193ca9c9f178fe6bfa2f0d85ba86b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4704c8206eb8a68ec251b10a9f90b54b"><td class="memItemLeft" align="right" valign="top"><a id="ga4704c8206eb8a68ec251b10a9f90b54b"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::Family&lt; BasisType &gt;::hasDivergence</b> = BasisType::hasDivergence</td></tr>
<tr class="separator:ga4704c8206eb8a68ec251b10a9f90b54b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaada1d8a90047badc9910b9b312e6300e"><td class="memItemLeft" align="right" valign="top"><a id="gaada1d8a90047badc9910b9b312e6300e"></a>
static const TensorRankE&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::TensorizedVectorFamily&lt; ScalarFamilyType, N &gt;::tensorRank</b> = Vector</td></tr>
<tr class="separator:gaada1d8a90047badc9910b9b312e6300e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11bea467eab12156126ffc5d296ffecc"><td class="memItemLeft" align="right" valign="top"><a id="ga11bea467eab12156126ffc5d296ffecc"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::TensorizedVectorFamily&lt; ScalarFamilyType, N &gt;::hasFunction</b> = ScalarFamilyType::hasFunction</td></tr>
<tr class="separator:ga11bea467eab12156126ffc5d296ffecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga118c8e9bbbe5d63d2ce9575adf4e02eb"><td class="memItemLeft" align="right" valign="top"><a id="ga118c8e9bbbe5d63d2ce9575adf4e02eb"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::TensorizedVectorFamily&lt; ScalarFamilyType, N &gt;::hasGradient</b> = ScalarFamilyType::hasGradient</td></tr>
<tr class="separator:ga118c8e9bbbe5d63d2ce9575adf4e02eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67fc626998e10c80c40b9419e013e538"><td class="memItemLeft" align="right" valign="top"><a id="ga67fc626998e10c80c40b9419e013e538"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::TensorizedVectorFamily&lt; ScalarFamilyType, N &gt;::hasDivergence</b> = ( ScalarFamilyType::hasGradient &amp;&amp; N==dimspace )</td></tr>
<tr class="separator:ga67fc626998e10c80c40b9419e013e538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga440a12913a7f63653b9766e4180c5884"><td class="memItemLeft" align="right" valign="top"><a id="ga440a12913a7f63653b9766e4180c5884"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::TensorizedVectorFamily&lt; ScalarFamilyType, N &gt;::hasCurl</b> = ( ScalarFamilyType::hasGradient &amp;&amp; N==dimspace )</td></tr>
<tr class="separator:ga440a12913a7f63653b9766e4180c5884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72e72931956a8f0ad4a6c9408629bd75"><td class="memItemLeft" align="right" valign="top"><a id="ga72e72931956a8f0ad4a6c9408629bd75"></a>
static const TensorRankE&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::MatrixFamily&lt; ScalarFamilyType, N &gt;::tensorRank</b> = Matrix</td></tr>
<tr class="separator:ga72e72931956a8f0ad4a6c9408629bd75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79682c4e308e6722f1d465343730fde7"><td class="memItemLeft" align="right" valign="top"><a id="ga79682c4e308e6722f1d465343730fde7"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::MatrixFamily&lt; ScalarFamilyType, N &gt;::hasFunction</b> = ScalarFamilyType::hasFunction</td></tr>
<tr class="separator:ga79682c4e308e6722f1d465343730fde7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8bca41c983ba6b2388c1b6cc3f5525b"><td class="memItemLeft" align="right" valign="top"><a id="gac8bca41c983ba6b2388c1b6cc3f5525b"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::MatrixFamily&lt; ScalarFamilyType, N &gt;::hasGradient</b> = false</td></tr>
<tr class="separator:gac8bca41c983ba6b2388c1b6cc3f5525b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga813c8c3c68b514f97bb10019a5032aa4"><td class="memItemLeft" align="right" valign="top"><a id="ga813c8c3c68b514f97bb10019a5032aa4"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::MatrixFamily&lt; ScalarFamilyType, N &gt;::hasDivergence</b> = ( ScalarFamilyType::hasGradient &amp;&amp; N==dimspace )</td></tr>
<tr class="separator:ga813c8c3c68b514f97bb10019a5032aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63014965059264071bf6c4c3623aa349"><td class="memItemLeft" align="right" valign="top"><a id="ga63014965059264071bf6c4c3623aa349"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::MatrixFamily&lt; ScalarFamilyType, N &gt;::hasCurl</b> = false</td></tr>
<tr class="separator:ga63014965059264071bf6c4c3623aa349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga932efd1bb07555f7423935e77dbbe4e9"><td class="memItemLeft" align="right" valign="top"><a id="ga932efd1bb07555f7423935e77dbbe4e9"></a>
static const TensorRankE&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::TangentFamily&lt; ScalarFamilyType &gt;::tensorRank</b> = Vector</td></tr>
<tr class="separator:ga932efd1bb07555f7423935e77dbbe4e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78dba683e6b13847056f29e3796e04a1"><td class="memItemLeft" align="right" valign="top"><a id="ga78dba683e6b13847056f29e3796e04a1"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::TangentFamily&lt; ScalarFamilyType &gt;::hasFunction</b> = true</td></tr>
<tr class="separator:ga78dba683e6b13847056f29e3796e04a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d94919b89e559bd1b1d765638be18ba"><td class="memItemLeft" align="right" valign="top"><a id="ga2d94919b89e559bd1b1d765638be18ba"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::TangentFamily&lt; ScalarFamilyType &gt;::hasGradient</b> = false</td></tr>
<tr class="separator:ga2d94919b89e559bd1b1d765638be18ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37be45e6490a03fa16b72e3b9ed7c09a"><td class="memItemLeft" align="right" valign="top"><a id="ga37be45e6490a03fa16b72e3b9ed7c09a"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::TangentFamily&lt; ScalarFamilyType &gt;::hasCurl</b> = false</td></tr>
<tr class="separator:ga37be45e6490a03fa16b72e3b9ed7c09a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga255712ad2ff1461993f8c43754c44061"><td class="memItemLeft" align="right" valign="top"><a id="ga255712ad2ff1461993f8c43754c44061"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::TangentFamily&lt; ScalarFamilyType &gt;::hasDivergence</b> = false</td></tr>
<tr class="separator:ga255712ad2ff1461993f8c43754c44061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga699c8451fd81d74301b1a2513ae34df0"><td class="memItemLeft" align="right" valign="top"><a id="ga699c8451fd81d74301b1a2513ae34df0"></a>
static const TensorRankE&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::ShiftedBasis&lt; BasisType &gt;::tensorRank</b> = BasisType::tensorRank</td></tr>
<tr class="separator:ga699c8451fd81d74301b1a2513ae34df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c9b0469e3a9a1d2de82c3a0a5d362f0"><td class="memItemLeft" align="right" valign="top"><a id="ga0c9b0469e3a9a1d2de82c3a0a5d362f0"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::ShiftedBasis&lt; BasisType &gt;::hasFunction</b> = BasisType::hasFunction</td></tr>
<tr class="separator:ga0c9b0469e3a9a1d2de82c3a0a5d362f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7af9068680c10bc140e0d7273e451c8"><td class="memItemLeft" align="right" valign="top"><a id="gaf7af9068680c10bc140e0d7273e451c8"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::ShiftedBasis&lt; BasisType &gt;::hasGradient</b> = BasisType::hasGradient</td></tr>
<tr class="separator:gaf7af9068680c10bc140e0d7273e451c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabac4d77a31c51c6a10406a87fb051bcb"><td class="memItemLeft" align="right" valign="top"><a id="gabac4d77a31c51c6a10406a87fb051bcb"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::ShiftedBasis&lt; BasisType &gt;::hasCurl</b> = BasisType::hasCurl</td></tr>
<tr class="separator:gabac4d77a31c51c6a10406a87fb051bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6705a2937e7d47cadffd9a36e8a7371"><td class="memItemLeft" align="right" valign="top"><a id="gaf6705a2937e7d47cadffd9a36e8a7371"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::ShiftedBasis&lt; BasisType &gt;::hasDivergence</b> = BasisType::hasDivergence</td></tr>
<tr class="separator:gaf6705a2937e7d47cadffd9a36e8a7371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ac0d24bac4b90d8f97562a6f7aa5de5"><td class="memItemLeft" align="right" valign="top"><a id="ga7ac0d24bac4b90d8f97562a6f7aa5de5"></a>
static const TensorRankE&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::RestrictedBasis&lt; BasisType &gt;::tensorRank</b> = BasisType::tensorRank</td></tr>
<tr class="separator:ga7ac0d24bac4b90d8f97562a6f7aa5de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace08c56ba0963f5148c3ae82bc820453"><td class="memItemLeft" align="right" valign="top"><a id="gace08c56ba0963f5148c3ae82bc820453"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::RestrictedBasis&lt; BasisType &gt;::hasFunction</b> = BasisType::hasFunction</td></tr>
<tr class="separator:gace08c56ba0963f5148c3ae82bc820453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61cf97a1a52871887797bb46c15f0ba4"><td class="memItemLeft" align="right" valign="top"><a id="ga61cf97a1a52871887797bb46c15f0ba4"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::RestrictedBasis&lt; BasisType &gt;::hasGradient</b> = BasisType::hasGradient</td></tr>
<tr class="separator:ga61cf97a1a52871887797bb46c15f0ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga929c9098450f73e3f7f5a315ac23b1fe"><td class="memItemLeft" align="right" valign="top"><a id="ga929c9098450f73e3f7f5a315ac23b1fe"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::RestrictedBasis&lt; BasisType &gt;::hasCurl</b> = BasisType::hasCurl</td></tr>
<tr class="separator:ga929c9098450f73e3f7f5a315ac23b1fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c2322e7e67b5ca1f562db511b1e6154"><td class="memItemLeft" align="right" valign="top"><a id="ga0c2322e7e67b5ca1f562db511b1e6154"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::RestrictedBasis&lt; BasisType &gt;::hasDivergence</b> = BasisType::hasDivergence</td></tr>
<tr class="separator:ga0c2322e7e67b5ca1f562db511b1e6154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1acbb7bb95bd4c88fb8d5bb283df1013"><td class="memItemLeft" align="right" valign="top"><a id="ga1acbb7bb95bd4c88fb8d5bb283df1013"></a>
static const TensorRankE&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::GradientBasis&lt; BasisType &gt;::tensorRank</b> = Vector</td></tr>
<tr class="separator:ga1acbb7bb95bd4c88fb8d5bb283df1013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3db76edf9738f960e61862e962e6bd6f"><td class="memItemLeft" align="right" valign="top"><a id="ga3db76edf9738f960e61862e962e6bd6f"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::GradientBasis&lt; BasisType &gt;::hasFunction</b> = true</td></tr>
<tr class="separator:ga3db76edf9738f960e61862e962e6bd6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8f1cede00f4c25346edd02b828a7aa4"><td class="memItemLeft" align="right" valign="top"><a id="gaa8f1cede00f4c25346edd02b828a7aa4"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::GradientBasis&lt; BasisType &gt;::hasGradient</b> = false</td></tr>
<tr class="separator:gaa8f1cede00f4c25346edd02b828a7aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94d63d9b4462f078073749a5cf69f9dd"><td class="memItemLeft" align="right" valign="top"><a id="ga94d63d9b4462f078073749a5cf69f9dd"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::GradientBasis&lt; BasisType &gt;::hasCurl</b> = false</td></tr>
<tr class="separator:ga94d63d9b4462f078073749a5cf69f9dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccec3fbf49f52c17ba38e873de7ac6ca"><td class="memItemLeft" align="right" valign="top"><a id="gaccec3fbf49f52c17ba38e873de7ac6ca"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::GradientBasis&lt; BasisType &gt;::hasDivergence</b> = false</td></tr>
<tr class="separator:gaccec3fbf49f52c17ba38e873de7ac6ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15ec98e78dc07d6f3e4aa4188b725258"><td class="memItemLeft" align="right" valign="top"><a id="ga15ec98e78dc07d6f3e4aa4188b725258"></a>
static const TensorRankE&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::CurlBasis&lt; BasisType &gt;::tensorRank</b> = Vector</td></tr>
<tr class="separator:ga15ec98e78dc07d6f3e4aa4188b725258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcdc4792cb79ef019fc444ddc01f3da9"><td class="memItemLeft" align="right" valign="top"><a id="gabcdc4792cb79ef019fc444ddc01f3da9"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::CurlBasis&lt; BasisType &gt;::hasFunction</b> = true</td></tr>
<tr class="separator:gabcdc4792cb79ef019fc444ddc01f3da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga295c63864e7ca7884a51d823471af2bc"><td class="memItemLeft" align="right" valign="top"><a id="ga295c63864e7ca7884a51d823471af2bc"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::CurlBasis&lt; BasisType &gt;::hasGradient</b> = false</td></tr>
<tr class="separator:ga295c63864e7ca7884a51d823471af2bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf7023f30610f144c79ece361f898d6e"><td class="memItemLeft" align="right" valign="top"><a id="gabf7023f30610f144c79ece361f898d6e"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::CurlBasis&lt; BasisType &gt;::hasCurl</b> = false</td></tr>
<tr class="separator:gabf7023f30610f144c79ece361f898d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba59f1a7f2c43108be3745452a5e1a23"><td class="memItemLeft" align="right" valign="top"><a id="gaba59f1a7f2c43108be3745452a5e1a23"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::CurlBasis&lt; BasisType &gt;::hasDivergence</b> = false</td></tr>
<tr class="separator:gaba59f1a7f2c43108be3745452a5e1a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74b72cff2f104e3b0785cc467ed26fdb"><td class="memItemLeft" align="right" valign="top"><a id="ga74b72cff2f104e3b0785cc467ed26fdb"></a>
static const TensorRankE&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::RolyComplBasisCell::tensorRank</b> = Vector</td></tr>
<tr class="separator:ga74b72cff2f104e3b0785cc467ed26fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga958bf6227cd160a397e0c30b5f66894a"><td class="memItemLeft" align="right" valign="top"><a id="ga958bf6227cd160a397e0c30b5f66894a"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::RolyComplBasisCell::hasFunction</b> = true</td></tr>
<tr class="separator:ga958bf6227cd160a397e0c30b5f66894a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04353045d25fa7d03c19fea4545b7765"><td class="memItemLeft" align="right" valign="top"><a id="ga04353045d25fa7d03c19fea4545b7765"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::RolyComplBasisCell::hasGradient</b> = false</td></tr>
<tr class="separator:ga04353045d25fa7d03c19fea4545b7765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab43a33e791273f67904626f7d759d63"><td class="memItemLeft" align="right" valign="top"><a id="gaab43a33e791273f67904626f7d759d63"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::RolyComplBasisCell::hasCurl</b> = false</td></tr>
<tr class="separator:gaab43a33e791273f67904626f7d759d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae74cf99bd4e012774f9384510ec9acc2"><td class="memItemLeft" align="right" valign="top"><a id="gae74cf99bd4e012774f9384510ec9acc2"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::RolyComplBasisCell::hasDivergence</b> = true</td></tr>
<tr class="separator:gae74cf99bd4e012774f9384510ec9acc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac47dccec11529b9758b3c41a88db57e1"><td class="memItemLeft" align="right" valign="top"><a id="gac47dccec11529b9758b3c41a88db57e1"></a>
static const TensorRankE&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::GolyComplBasisCell::tensorRank</b> = Vector</td></tr>
<tr class="separator:gac47dccec11529b9758b3c41a88db57e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae966be110375f3eb1bcd261bf138c3c7"><td class="memItemLeft" align="right" valign="top"><a id="gae966be110375f3eb1bcd261bf138c3c7"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::GolyComplBasisCell::hasFunction</b> = true</td></tr>
<tr class="separator:gae966be110375f3eb1bcd261bf138c3c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga873732292d598abcfcacf0548910604a"><td class="memItemLeft" align="right" valign="top"><a id="ga873732292d598abcfcacf0548910604a"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::GolyComplBasisCell::hasGradient</b> = false</td></tr>
<tr class="separator:ga873732292d598abcfcacf0548910604a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a6c3a1e146f428129caa931b425f4c3"><td class="memItemLeft" align="right" valign="top"><a id="ga3a6c3a1e146f428129caa931b425f4c3"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::GolyComplBasisCell::hasCurl</b> = false</td></tr>
<tr class="separator:ga3a6c3a1e146f428129caa931b425f4c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf71b19a568d6b205e9bae793287e1907"><td class="memItemLeft" align="right" valign="top"><a id="gaf71b19a568d6b205e9bae793287e1907"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::GolyComplBasisCell::hasDivergence</b> = false</td></tr>
<tr class="separator:gaf71b19a568d6b205e9bae793287e1907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a56c20c343120be9f4e6b312f4123ea"><td class="memItemLeft" align="right" valign="top"><a id="ga3a56c20c343120be9f4e6b312f4123ea"></a>
static const BasisFunctionE&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::detail::basis_evaluation_traits&lt; TensorizedVectorFamily&lt; ScalarBasisType, N &gt;, Function &gt;::AncestorBasisFunction</b> = Function</td></tr>
<tr class="separator:ga3a56c20c343120be9f4e6b312f4123ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29841916fb8f5baf31298b5fbad2296b"><td class="memItemLeft" align="right" valign="top"><a id="ga29841916fb8f5baf31298b5fbad2296b"></a>
static const BasisFunctionE&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::detail::basis_evaluation_traits&lt; TensorizedVectorFamily&lt; ScalarBasisType, N &gt;, Gradient &gt;::AncestorBasisFunction</b> = Gradient</td></tr>
<tr class="separator:ga29841916fb8f5baf31298b5fbad2296b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f9dd18dd7764250655745f8612ba77f"><td class="memItemLeft" align="right" valign="top"><a id="ga0f9dd18dd7764250655745f8612ba77f"></a>
static const BasisFunctionE&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::detail::basis_evaluation_traits&lt; TensorizedVectorFamily&lt; ScalarBasisType, N &gt;, Curl &gt;::AncestorBasisFunction</b> = Gradient</td></tr>
<tr class="separator:ga0f9dd18dd7764250655745f8612ba77f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf55f539c5795292088a97b9a7b68d9fe"><td class="memItemLeft" align="right" valign="top"><a id="gaf55f539c5795292088a97b9a7b68d9fe"></a>
static const BasisFunctionE&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::detail::basis_evaluation_traits&lt; TensorizedVectorFamily&lt; ScalarBasisType, N &gt;, Divergence &gt;::AncestorBasisFunction</b> = Gradient</td></tr>
<tr class="separator:gaf55f539c5795292088a97b9a7b68d9fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga900ad8ce7fe097a18dbd3fed81c038ee"><td class="memItemLeft" align="right" valign="top"><a id="ga900ad8ce7fe097a18dbd3fed81c038ee"></a>
static const BasisFunctionE&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::detail::basis_evaluation_traits&lt; MatrixFamily&lt; ScalarBasisType, N &gt;, Function &gt;::AncestorBasisFunction</b> = Function</td></tr>
<tr class="separator:ga900ad8ce7fe097a18dbd3fed81c038ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb16563c87f18ad28449efd30754bfe3"><td class="memItemLeft" align="right" valign="top"><a id="gacb16563c87f18ad28449efd30754bfe3"></a>
static const BasisFunctionE&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::detail::basis_evaluation_traits&lt; MatrixFamily&lt; ScalarBasisType, N &gt;, Divergence &gt;::AncestorBasisFunction</b> = Gradient</td></tr>
<tr class="separator:gacb16563c87f18ad28449efd30754bfe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Classes and functions for polynomial basis creation and manipulation. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga687c3c9504c4b10c5a18654530980086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga687c3c9504c4b10c5a18654530980086">&#9670;&nbsp;</a></span>compute() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BasisFunctionE BasisFunction&gt; </div>
<div class="memtemplate">
template&lt;typename BasisType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static boost::multi_array&lt;typename <a class="el" href="structHArDCore2D_1_1detail_1_1basis__evaluation__traits.html">detail::basis_evaluation_traits</a>&lt;BasisType, BasisFunction&gt;::ReturnValue, 2&gt; <a class="el" href="structHArDCore2D_1_1evaluate__quad.html">HArDCore2D::evaluate_quad</a>&lt; BasisFunction &gt;::compute </td>
          <td>(</td>
          <td class="paramtype">const BasisType &amp;&#160;</td>
          <td class="paramname"><em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureRule &amp;&#160;</td>
          <td class="paramname"><em>quad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic basis evaluation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basis</td><td>The basis </td></tr>
    <tr><td class="paramname">quad</td><td>The quadrature rule </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga06cedf0c3440b94b9974922c72ea7c11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06cedf0c3440b94b9974922c72ea7c11">&#9670;&nbsp;</a></span>compute() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BasisFunctionE BasisFunction&gt; </div>
<div class="memtemplate">
template&lt;typename BasisType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static boost::multi_array&lt;typename <a class="el" href="structHArDCore2D_1_1detail_1_1basis__evaluation__traits.html">detail::basis_evaluation_traits</a>&lt;<a class="el" href="classHArDCore2D_1_1Family.html">Family</a>&lt;BasisType&gt;, BasisFunction&gt;::ReturnValue, 2&gt; <a class="el" href="structHArDCore2D_1_1evaluate__quad.html">HArDCore2D::evaluate_quad</a>&lt; BasisFunction &gt;::compute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHArDCore2D_1_1Family.html">Family</a>&lt; BasisType &gt; &amp;&#160;</td>
          <td class="paramname"><em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureRule &amp;&#160;</td>
          <td class="paramname"><em>quad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluate a '<a class="el" href="classHArDCore2D_1_1Family.html">Family</a>' of functions at quadrature nodes (optimised compared the generic basis evaluation, to avoid computing several times the ancestor basis at the quadrature nodes) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basis</td><td>The family </td></tr>
    <tr><td class="paramname">quad</td><td>The quadrature rule </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga77e7551793be854d7b654addf292aa6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77e7551793be854d7b654addf292aa6b">&#9670;&nbsp;</a></span>compute() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BasisFunctionE BasisFunction&gt; </div>
<div class="memtemplate">
template&lt;typename BasisType , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static boost::multi_array&lt;typename <a class="el" href="structHArDCore2D_1_1detail_1_1basis__evaluation__traits.html">detail::basis_evaluation_traits</a>&lt;<a class="el" href="classHArDCore2D_1_1MatrixFamily.html">MatrixFamily</a>&lt;BasisType, N&gt;, BasisFunction&gt;::ReturnValue, 2&gt; <a class="el" href="structHArDCore2D_1_1evaluate__quad.html">HArDCore2D::evaluate_quad</a>&lt; BasisFunction &gt;::compute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHArDCore2D_1_1MatrixFamily.html">MatrixFamily</a>&lt; BasisType, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureRule &amp;&#160;</td>
          <td class="paramname"><em>quad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluate a Matrix family at quadrature nodes (optimised compared the generic basis evaluation, to avoid computing several times the ancestor basis at the quadrature nodes) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basis</td><td>The family </td></tr>
    <tr><td class="paramname">quad</td><td>The quadrature rule </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2e707628cf7f51dd4ecf63182eea847a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e707628cf7f51dd4ecf63182eea847a">&#9670;&nbsp;</a></span>compute() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BasisFunctionE BasisFunction&gt; </div>
<div class="memtemplate">
template&lt;typename BasisType , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static boost::multi_array&lt;typename <a class="el" href="structHArDCore2D_1_1detail_1_1basis__evaluation__traits.html">detail::basis_evaluation_traits</a>&lt;<a class="el" href="classHArDCore2D_1_1TensorizedVectorFamily.html">TensorizedVectorFamily</a>&lt;BasisType, N&gt;, BasisFunction&gt;::ReturnValue, 2&gt; <a class="el" href="structHArDCore2D_1_1evaluate__quad.html">HArDCore2D::evaluate_quad</a>&lt; BasisFunction &gt;::compute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHArDCore2D_1_1TensorizedVectorFamily.html">TensorizedVectorFamily</a>&lt; BasisType, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureRule &amp;&#160;</td>
          <td class="paramname"><em>quad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluate a tensorized family at quadrature nodes (optimised compared the generic basis evaluation, to avoid computing several times the ancestor basis at the quadrature nodes) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basis</td><td>The family </td></tr>
    <tr><td class="paramname">quad</td><td>The quadrature rule </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga28c35940e00abae0be3c53c3d37cdb63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28c35940e00abae0be3c53c3d37cdb63">&#9670;&nbsp;</a></span>compute_closure_matrix() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::compute_closure_matrix </td>
          <td>(</td>
          <td class="paramtype">const boost::multi_array&lt; Value, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::multi_array&lt; Value, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureRule &amp;&#160;</td>
          <td class="paramname"><em>qr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes closure equation matrices. Overload of the previous one when qr_f=qr_g. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f_quad</td><td>Evaluations of the functions \((f_i)\) at the quadrature nodes </td></tr>
    <tr><td class="paramname">g_quad</td><td>Evaluations of the functions \((g_j)\) at the quadrature nodes </td></tr>
    <tr><td class="paramname">qr</td><td>quadrature rule for integration </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1d085bfe7e819ade34b54ec812919dda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d085bfe7e819ade34b54ec812919dda">&#9670;&nbsp;</a></span>compute_closure_matrix() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::compute_closure_matrix </td>
          <td>(</td>
          <td class="paramtype">const boost::multi_array&lt; Value, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::multi_array&lt; Value, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureRule &amp;&#160;</td>
          <td class="paramname"><em>qr_f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureRule &amp;&#160;</td>
          <td class="paramname"><em>qr_g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes closure equation matrices, from evaluations at quadrature nodes. For two families of functions \((f_i)\) and \((g_j)\) with values in some space E, this routine computes the matrix \((\int f_i)\cdot(\int g_j)\) where \(\cdot\) is the dot product in E. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f_quad</td><td>Evaluations of the functions \((f_i)\) at the quadrature nodes </td></tr>
    <tr><td class="paramname">g_quad</td><td>Evaluations of the functions \((g_j)\) at the quadrature nodes </td></tr>
    <tr><td class="paramname">qr_f</td><td>quadrature rule for integration of f_i </td></tr>
    <tr><td class="paramname">qr_g</td><td>quadrature rule for integration of g_i </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga423a192827899636b148ba6c2857ea35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga423a192827899636b148ba6c2857ea35">&#9670;&nbsp;</a></span>compute_closure_matrix() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::compute_closure_matrix </td>
          <td>(</td>
          <td class="paramtype">const boost::multi_array&lt; Value, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureRule &amp;&#160;</td>
          <td class="paramname"><em>qr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes closure equation matrices. Overload of the previous one when f=g. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f_quad</td><td>Evaluations of the functions \((f_i)\) at the quadrature nodes </td></tr>
    <tr><td class="paramname">qr</td><td>quadrature rule for integration </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga90eb6f12ab8129f7a8307bcd827b2f00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90eb6f12ab8129f7a8307bcd827b2f00">&#9670;&nbsp;</a></span>compute_gram_matrix() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::compute_gram_matrix </td>
          <td>(</td>
          <td class="paramtype">const boost::multi_array&lt; double, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::multi_array&lt; double, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureRule &amp;&#160;</td>
          <td class="paramname"><em>qr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>ncols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>sym</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Gram-like matrix given the evaluation of two families of functions at quadrature nodes. This version is an overload for double-valued families, more efficient than the generic templated version. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">B1</td><td>First family at quadrature nodes </td></tr>
    <tr><td class="paramname">B2</td><td>Second family at quadrature nodes </td></tr>
    <tr><td class="paramname">qr</td><td>Quadrature rule used for evaluation </td></tr>
    <tr><td class="paramname">nrows</td><td>Number of rows of the matrix (nb of members of first family to consider) </td></tr>
    <tr><td class="paramname">ncols</td><td>Number of rows of the matrix (nn of members of second family to consider) </td></tr>
    <tr><td class="paramname">sym</td><td>Optional. "sym" to indicate that the matrix is symmetric (B1=B2) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga16b838fc438f0935a5fc7706d83cf662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16b838fc438f0935a5fc7706d83cf662">&#9670;&nbsp;</a></span>compute_gram_matrix() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::compute_gram_matrix </td>
          <td>(</td>
          <td class="paramtype">const boost::multi_array&lt; double, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::multi_array&lt; double, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureRule &amp;&#160;</td>
          <td class="paramname"><em>qr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>sym</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Gram-like matrix given the evaluation of two families of functions at quadrature nodes. Consists in calling the double-valued version with nrows = nb of elements in B1, ncols = nb of elements in B2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">B1</td><td>First family at quadrature nodes </td></tr>
    <tr><td class="paramname">B2</td><td>Second family at quadrature nodes </td></tr>
    <tr><td class="paramname">qr</td><td>Quadrature rule used for evaluation </td></tr>
    <tr><td class="paramname">sym</td><td>Optional. "sym" to indicate that the matrix is symmetric (B1=B2) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0c65c290a977d9d35ae51d6edde392a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c65c290a977d9d35ae51d6edde392a8">&#9670;&nbsp;</a></span>compute_gram_matrix() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FunctionValue &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::compute_gram_matrix </td>
          <td>(</td>
          <td class="paramtype">const boost::multi_array&lt; FunctionValue, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureRule &amp;&#160;</td>
          <td class="paramname"><em>qr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the Gram matrix given the evaluation of one family of functions at quadrature nodes. Consists in calling the generic templated version with B1=B2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">B</td><td><a class="el" href="classHArDCore2D_1_1Family.html">Family</a> at quadrature nodes </td></tr>
    <tr><td class="paramname">qr</td><td>Quadrature rule used for evaluation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga29885facf8b5a576e7e0b609d1e3124f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29885facf8b5a576e7e0b609d1e3124f">&#9670;&nbsp;</a></span>compute_gram_matrix() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FunctionValue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::compute_gram_matrix </td>
          <td>(</td>
          <td class="paramtype">const boost::multi_array&lt; FunctionValue, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::multi_array&lt; FunctionValue, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureRule &amp;&#160;</td>
          <td class="paramname"><em>qr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>ncols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>sym</em> = <code>&quot;nonsym&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Gram-like matrix given the evaluation of two families of functions at quadrature nodes. This templated function is very generic, and thus not the most efficient. More efficient overloads are provided for double- or Vector2d-valued families. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">B1</td><td>First family at quadrature nodes </td></tr>
    <tr><td class="paramname">B2</td><td>Second family at quadrature nodes </td></tr>
    <tr><td class="paramname">qr</td><td>Quadrature rule used for evaluation </td></tr>
    <tr><td class="paramname">nrows</td><td>Number of rows of the matrix (nb of members of first family to consider) </td></tr>
    <tr><td class="paramname">ncols</td><td>Number of rows of the matrix (nn of members of second family to consider) </td></tr>
    <tr><td class="paramname">sym</td><td>Optional. "sym" to indicate that the matrix is symmetric (B1=B2) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafea1bf5033abb255fd6b73a3a30bf09e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafea1bf5033abb255fd6b73a3a30bf09e">&#9670;&nbsp;</a></span>compute_gram_matrix() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FunctionValue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::compute_gram_matrix </td>
          <td>(</td>
          <td class="paramtype">const boost::multi_array&lt; FunctionValue, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::multi_array&lt; FunctionValue, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureRule &amp;&#160;</td>
          <td class="paramname"><em>qr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>sym</em> = <code>&quot;nonsym&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Gram-like matrix given the evaluation of two families of functions at quadrature nodes. This version calls the generic one with nrows = nb of elements in family B1 and ncols = nb of elements in family B2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">B1</td><td>First family at quadrature nodes </td></tr>
    <tr><td class="paramname">B2</td><td>Second family at quadrature nodes </td></tr>
    <tr><td class="paramname">qr</td><td>Quadrature rule used for evaluation </td></tr>
    <tr><td class="paramname">sym</td><td>Optional. "sym" to indicate that the matrix is symmetric (B1=B2) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga56ea5a2eec9e5f2534c5ea34c6f8e973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56ea5a2eec9e5f2534c5ea34c6f8e973">&#9670;&nbsp;</a></span>compute_gram_matrix() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::compute_gram_matrix </td>
          <td>(</td>
          <td class="paramtype">const boost::multi_array&lt; VectorRd, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::multi_array&lt; double, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureRule &amp;&#160;</td>
          <td class="paramname"><em>qr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Gram-like matrix given a family of vector-valued and one of scalar-valued functions by tensorizing the latter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">B1</td><td>First family at quadrature nodes </td></tr>
    <tr><td class="paramname">B2</td><td>Second family (to be tensorized) at quadrature nodes </td></tr>
    <tr><td class="paramname">qr</td><td>Quadrature rule used for evaluation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga81188afa6341cae65e11dcd3c560d027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81188afa6341cae65e11dcd3c560d027">&#9670;&nbsp;</a></span>compute_gram_matrix() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::compute_gram_matrix </td>
          <td>(</td>
          <td class="paramtype">const boost::multi_array&lt; VectorRd, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::multi_array&lt; VectorRd, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureRule &amp;&#160;</td>
          <td class="paramname"><em>qr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>ncols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>sym</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Gram-like matrix given the evaluation of two families of functions at quadrature nodes. This version is an overload for Vector2d-valued families, more efficient than the generic templated version. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">B1</td><td>First family at quadrature nodes </td></tr>
    <tr><td class="paramname">B2</td><td>Second family at quadrature nodes </td></tr>
    <tr><td class="paramname">qr</td><td>Quadrature rule used for evaluation </td></tr>
    <tr><td class="paramname">nrows</td><td>Optional. Number of rows of the matrix (nb of members of first family to consider). </td></tr>
    <tr><td class="paramname">ncols</td><td>Optional. Number of rows of the matrix (nb of members of second family to consider). </td></tr>
    <tr><td class="paramname">sym</td><td>Optional. "sym" to indicate that the matrix is symmetric (B1=B2) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf355214aec1e4ef71621a7d339415ae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf355214aec1e4ef71621a7d339415ae1">&#9670;&nbsp;</a></span>compute_gram_matrix() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::compute_gram_matrix </td>
          <td>(</td>
          <td class="paramtype">const boost::multi_array&lt; VectorRd, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::multi_array&lt; VectorRd, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureRule &amp;&#160;</td>
          <td class="paramname"><em>qr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>sym</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Gram-like matrix given the evaluation of two families of functions at quadrature nodes. Consists in calling the Vector2d-valued version with nrows = nb of elements in B1, ncols = nb of elements in B2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">B1</td><td>First family at quadrature nodes </td></tr>
    <tr><td class="paramname">B2</td><td>Second family at quadrature nodes </td></tr>
    <tr><td class="paramname">qr</td><td>Quadrature rule used for evaluation </td></tr>
    <tr><td class="paramname">sym</td><td>Optional. "sym" to indicate that the matrix is symmetric (B1=B2) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1edb7f00f8048d22ce79e63a202a8594"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1edb7f00f8048d22ce79e63a202a8594">&#9670;&nbsp;</a></span>compute_gram_matrix() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarFamilyType , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::compute_gram_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHArDCore2D_1_1MatrixFamily.html">MatrixFamily</a>&lt; ScalarFamilyType, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>MatFam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::multi_array&lt; double, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>scalar_family_quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureRule &amp;&#160;</td>
          <td class="paramname"><em>qr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Gram-like matrix for a <a class="el" href="classHArDCore2D_1_1MatrixFamily.html" title="Matrix family obtained from a scalar family.">MatrixFamily</a>. This overload is more efficient than the generic function as it only computes the gram matrix of the underlying scalar family, and then creates the bloc-diagonal gram matrix of the <a class="el" href="classHArDCore2D_1_1MatrixFamily.html" title="Matrix family obtained from a scalar family.">MatrixFamily</a> (which is indeed bloc diagonal given the choice of m_E elements in this class). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">MatFam</td><td>Matrix family </td></tr>
    <tr><td class="paramname">scalar_family_quad</td><td>values of the underlying scalar family at quadrature nodes </td></tr>
    <tr><td class="paramname">qr</td><td>Quadrature rule used for evaluation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga167107aa2e92a2656ded2e8cafa7e59d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga167107aa2e92a2656ded2e8cafa7e59d">&#9670;&nbsp;</a></span>compute_weighted_gram_matrix() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::compute_weighted_gram_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Basis.html#gab1e36fbf129c707351e533ee43579432">FType</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__Basis.html#ga41970d25ff5ffdc77e1368ee5ce03bd4">BasisQuad</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>B1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__Basis.html#ga41970d25ff5ffdc77e1368ee5ce03bd4">BasisQuad</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>B2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureRule &amp;&#160;</td>
          <td class="paramname"><em>qr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>sym</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Gram-like matrix of integrals (f phi_i, phi_j) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Weight function. Posible types of U are MatrixRd and double - must be compatible with T </td></tr>
    <tr><td class="paramname">B1</td><td>First family of basis functions at quadrature nodes. Posible types of T are VectorRd and double </td></tr>
    <tr><td class="paramname">B2</td><td>Second family of basis functions at quadrature nodes. Posible types of T are VectorRd and double </td></tr>
    <tr><td class="paramname">qr</td><td>Quadrature rule </td></tr>
    <tr><td class="paramname">sym</td><td>Argument if matrix is symmetric to increase efficiency </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac450f5f0e9ac39ef61e8b3fda75c8931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac450f5f0e9ac39ef61e8b3fda75c8931">&#9670;&nbsp;</a></span>compute_weighted_gram_matrix() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::compute_weighted_gram_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Basis.html#gab1e36fbf129c707351e533ee43579432">FType</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__Basis.html#ga41970d25ff5ffdc77e1368ee5ce03bd4">BasisQuad</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>B1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__Basis.html#ga41970d25ff5ffdc77e1368ee5ce03bd4">BasisQuad</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>B2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureRule &amp;&#160;</td>
          <td class="paramname"><em>qr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n_rows</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n_cols</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>sym</em> = <code>&quot;nonsym&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Gram-like matrix of integrals (f phi_i, phi_j) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Weight function. Posible types of U are MatrixRd and double - must be compatible with T </td></tr>
    <tr><td class="paramname">B1</td><td>First family of basis functions at quadrature nodes. Posible types of T are VectorRd and double </td></tr>
    <tr><td class="paramname">B2</td><td>Second family of basis functions at quadrature nodes. Posible types of T are VectorRd and double </td></tr>
    <tr><td class="paramname">qr</td><td>Quadrature rule </td></tr>
    <tr><td class="paramname">n_rows</td><td>Optional argument for number of functions from first family to be integrated against. Default integrates whole family </td></tr>
    <tr><td class="paramname">n_cols</td><td>Optional argument for number of functions from second family to be integrated against. Default integrates whole family </td></tr>
    <tr><td class="paramname">sym</td><td>Optional argument if matrix is symmetric to increase efficiency </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad8ed4f83013c1957b10c920a57021406"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8ed4f83013c1957b10c920a57021406">&#9670;&nbsp;</a></span>compute_weighted_gram_matrix() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::compute_weighted_gram_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Basis.html#gab1e36fbf129c707351e533ee43579432">FType</a>&lt; VectorRd &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__Basis.html#ga41970d25ff5ffdc77e1368ee5ce03bd4">BasisQuad</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>B1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__Basis.html#ga41970d25ff5ffdc77e1368ee5ce03bd4">BasisQuad</a>&lt; VectorRd &gt; &amp;&#160;</td>
          <td class="paramname"><em>B2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureRule &amp;&#160;</td>
          <td class="paramname"><em>qr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n_cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Gram-like matrix of integrals (phi_i, f dot phi_j) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Weight function </td></tr>
    <tr><td class="paramname">B1</td><td><a class="el" href="classHArDCore2D_1_1Family.html">Family</a> of scalar basis functions at quadrature nodes </td></tr>
    <tr><td class="paramname">B2</td><td><a class="el" href="classHArDCore2D_1_1Family.html">Family</a> of vector basis functions at quadrature nodes </td></tr>
    <tr><td class="paramname">qr</td><td>Quadrature rule </td></tr>
    <tr><td class="paramname">n_rows</td><td>Optional argument for number of functions from scalar family to be integrated against. Default integrates whole family </td></tr>
    <tr><td class="paramname">n_cols</td><td>Optional argument for number of functions from vector family to be integrated against. Default integrates whole family </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga720d988c2c8cdf49c96687d63cc13d7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga720d988c2c8cdf49c96687d63cc13d7e">&#9670;&nbsp;</a></span>compute_weighted_gram_matrix() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::compute_weighted_gram_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Basis.html#gab1e36fbf129c707351e533ee43579432">FType</a>&lt; VectorRd &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__Basis.html#ga41970d25ff5ffdc77e1368ee5ce03bd4">BasisQuad</a>&lt; VectorRd &gt; &amp;&#160;</td>
          <td class="paramname"><em>B1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__Basis.html#ga41970d25ff5ffdc77e1368ee5ce03bd4">BasisQuad</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>B2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureRule &amp;&#160;</td>
          <td class="paramname"><em>qr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n_cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Gram-like matrix of integrals (f dot phi_i, phi_j) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Weight function </td></tr>
    <tr><td class="paramname">B1</td><td><a class="el" href="classHArDCore2D_1_1Family.html">Family</a> of vector basis functions at quadrature nodes </td></tr>
    <tr><td class="paramname">B2</td><td><a class="el" href="classHArDCore2D_1_1Family.html">Family</a> of scalar basis functions at quadrature nodes </td></tr>
    <tr><td class="paramname">qr</td><td>Quadrature rule </td></tr>
    <tr><td class="paramname">n_rows</td><td>Optional argument for number of functions from vector family to be integrated against. Default integrates whole family </td></tr>
    <tr><td class="paramname">n_cols</td><td>Optional argument for number of functions from scalar family to be integrated against. Default integrates whole family </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2e8f09ecc2cfd226ebb6539b34934d6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e8f09ecc2cfd226ebb6539b34934d6a">&#9670;&nbsp;</a></span>Family()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHArDCore2D_1_1Family.html">HArDCore2D::Family</a>&lt; BasisType &gt;::<a class="el" href="classHArDCore2D_1_1Family.html">Family</a> </td>
          <td>(</td>
          <td class="paramtype">const BasisType &amp;&#160;</td>
          <td class="paramname"><em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basis</td><td>The basis in which the family is expressed </td></tr>
    <tr><td class="paramname">matrix</td><td>The coefficient matrix whose i-th line contains the coefficient of the expansion of the i-th function of the family in the basis </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9d294c963cda7efe0b10bd82bc9b0b91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d294c963cda7efe0b10bd82bc9b0b91">&#9670;&nbsp;</a></span>GolyComplBasisCell()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HArDCore2D::GolyComplBasisCell::GolyComplBasisCell </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHArDCore2D_1_1Cell.html">Cell</a> &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>degree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>A mesh element </td></tr>
    <tr><td class="paramname">degree</td><td>The maximum polynomial degree to be considered </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9ea7809705d01c7cf6bca57a457a44a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ea7809705d01c7cf6bca57a457a44a4">&#9670;&nbsp;</a></span>gram_schmidt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::gram_schmidt </td>
          <td>(</td>
          <td class="paramtype">boost::multi_array&lt; T, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>basis_eval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; double(size_t, size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>inner_product</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gram-Schmidt algorithm to ortonormalize a basis. The matrix \(M\) returned by this function gives the coefficients in the original basis of the orthonormalised basis. If \((f_1,...,f_r)\) is the original basis, the orthonormalised basis is \((\phi_1,...,\phi_r)\) where \(\phi_i = \sum_j M_{ij}f_j\).</p>
<p>The function also modifies the variable basis_eval so that it contains the evaluation on at quadrature nodes of the new orthonormalised basis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basis_eval</td><td>Evaluations at quadrature nodes of the original basis. </td></tr>
    <tr><td class="paramname">inner_product</td><td>inner product (of two original basis functions) with respect to which we orthonormalise. This inner product must only depend on the basis functions through their values basis_eval. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad1f24a4a88d877b43abcd2df0592f1c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1f24a4a88d877b43abcd2df0592f1c2">&#9670;&nbsp;</a></span>integrate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd HArDCore2D::integrate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Basis.html#gab1e36fbf129c707351e533ee43579432">FType</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__Basis.html#ga41970d25ff5ffdc77e1368ee5ce03bd4">BasisQuad</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureRule &amp;&#160;</td>
          <td class="paramname"><em>qr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n_rows</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the integral of a given function against all functions from a family. </p>
<p>Possible types for T are those for which we have a "scalar_product" function (currently: double, VectorRd, MatrixRd) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Function to be integrated. </td></tr>
    <tr><td class="paramname">B</td><td><a class="el" href="classHArDCore2D_1_1Family.html">Family</a> of basis functions at quadrature nodes. </td></tr>
    <tr><td class="paramname">qr</td><td>Quadrature rule </td></tr>
    <tr><td class="paramname">n_rows</td><td>Optional argument for number of basis functions to be integrated. Default integrates all in the family. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3a5604879e905ecb08cbf4dda5d9a33c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a5604879e905ecb08cbf4dda5d9a33c">&#9670;&nbsp;</a></span>l2_orthonormalize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHArDCore2D_1_1Family.html">Family</a>&lt;BasisType&gt; HArDCore2D::l2_orthonormalize </td>
          <td>(</td>
          <td class="paramtype">const BasisType &amp;&#160;</td>
          <td class="paramname"><em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureRule &amp;&#160;</td>
          <td class="paramname"><em>qr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::multi_array&lt; typename BasisType::FunctionValue, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>basis_quad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>\(L^2\)-orthonormalization: simply consists in using <a class="el" href="group__Basis.html#ga9ea7809705d01c7cf6bca57a457a44a4">gram_schmidt()</a> with the specific l2 inner product </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basis</td><td>basis to orthonormalise </td></tr>
    <tr><td class="paramname">qr</td><td>quadrature rule for computing the l2 inner product </td></tr>
    <tr><td class="paramname">basis_quad</td><td>values of basis functions at quadrature nodes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga650f15db9b781f0ad398e54d96a5ba39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga650f15db9b781f0ad398e54d96a5ba39">&#9670;&nbsp;</a></span>l2_projection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd HArDCore2D::l2_projection </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; typename BasisType::FunctionValue(const VectorRd &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BasisType &amp;&#160;</td>
          <td class="paramname"><em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QuadratureRule &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::multi_array&lt; typename BasisType::FunctionValue, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>basis_quad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the L2-projection of a function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Function to project </td></tr>
    <tr><td class="paramname">basis</td><td>Basis for the space on which we project </td></tr>
    <tr><td class="paramname">quad</td><td>Quadrature rule </td></tr>
    <tr><td class="paramname">basis_quad</td><td>Evaluation of the basis at quadrature nodes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga077d11dc2b2d74d11b72f165dc8d033a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga077d11dc2b2d74d11b72f165dc8d033a">&#9670;&nbsp;</a></span>MonomialScalarBasisCell()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HArDCore2D::MonomialScalarBasisCell::MonomialScalarBasisCell </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHArDCore2D_1_1Cell.html">Cell</a> &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>degree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>A mesh cell </td></tr>
    <tr><td class="paramname">degree</td><td>The maximum polynomial degree to be considered </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1794a48fbd89584ed844950e0057f513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1794a48fbd89584ed844950e0057f513">&#9670;&nbsp;</a></span>MonomialScalarBasisEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HArDCore2D::MonomialScalarBasisEdge::MonomialScalarBasisEdge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHArDCore2D_1_1Edge.html">Edge</a> &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>degree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">E</td><td>A mesh edge </td></tr>
    <tr><td class="paramname">degree</td><td>The maximum polynomial degree to be considered </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3c6a0bd9f6d2d6411762613b363f1716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c6a0bd9f6d2d6411762613b363f1716">&#9670;&nbsp;</a></span>RestrictedBasis()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHArDCore2D_1_1RestrictedBasis.html">HArDCore2D::RestrictedBasis</a>&lt; BasisType &gt;::<a class="el" href="classHArDCore2D_1_1RestrictedBasis.html">RestrictedBasis</a> </td>
          <td>(</td>
          <td class="paramtype">const BasisType &amp;&#160;</td>
          <td class="paramname"><em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>dimension</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basis</td><td>A basis </td></tr>
    <tr><td class="paramname">dimension</td><td>The dimension of the restricted basis </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaef4345fecb3ca455b8d489b7ba52a1bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef4345fecb3ca455b8d489b7ba52a1bd">&#9670;&nbsp;</a></span>RolyComplBasisCell()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HArDCore2D::RolyComplBasisCell::RolyComplBasisCell </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHArDCore2D_1_1Cell.html">Cell</a> &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>degree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>A mesh element </td></tr>
    <tr><td class="paramname">degree</td><td>The maximum polynomial degree to be considered </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2f8b571925236c4b7ebe6afd77d5e4b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f8b571925236c4b7ebe6afd77d5e4b5">&#9670;&nbsp;</a></span>scalar_product()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::multi_array&lt;double, 2&gt; HArDCore2D::scalar_product </td>
          <td>(</td>
          <td class="paramtype">const boost::multi_array&lt; Value, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>basis_quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Value &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This overloading of the scalar_product function computes the scalar product between an evaluation of a basis and a constant value; both basis values and constant value must be of type Value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basis_quad</td><td>The basis evaluation </td></tr>
    <tr><td class="paramname">v</td><td>The vector to take the scalar product with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadb935c3f74623dbd29c124c0c6dc605e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb935c3f74623dbd29c124c0c6dc605e">&#9670;&nbsp;</a></span>ShiftedBasis()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHArDCore2D_1_1ShiftedBasis.html">HArDCore2D::ShiftedBasis</a>&lt; BasisType &gt;::<a class="el" href="classHArDCore2D_1_1ShiftedBasis.html">ShiftedBasis</a> </td>
          <td>(</td>
          <td class="paramtype">const BasisType &amp;&#160;</td>
          <td class="paramname"><em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basis</td><td>A basis </td></tr>
    <tr><td class="paramname">shift</td><td>The shift </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6cc5c5f1642d42f7479ba5907961811c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cc5c5f1642d42f7479ba5907961811c">&#9670;&nbsp;</a></span>TangentFamily()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarFamilyType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHArDCore2D_1_1TangentFamily.html">HArDCore2D::TangentFamily</a>&lt; ScalarFamilyType &gt;::<a class="el" href="classHArDCore2D_1_1TangentFamily.html">TangentFamily</a> </td>
          <td>(</td>
          <td class="paramtype">const ScalarFamilyType &amp;&#160;</td>
          <td class="paramname"><em>scalar_family</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorRd &amp;&#160;</td>
          <td class="paramname"><em>generator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar_family</td><td>A basis for the scalar space </td></tr>
    <tr><td class="paramname">generator</td><td>One generator of the edge </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga45a16ffb93f83f41efa6f59659fd1544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45a16ffb93f83f41efa6f59659fd1544">&#9670;&nbsp;</a></span>transform_values_quad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename outValue , typename inValue , typename FunctionType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::multi_array&lt;outValue, 2&gt; HArDCore2D::transform_values_quad </td>
          <td>(</td>
          <td class="paramtype">const boost::multi_array&lt; inValue, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B_quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctionType &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes an array B_quad of values at quadrature nodes and applies the function F to all of them. F must take inValue and return outValue. The function must be called with outValue as template argument: transform_values_quad&lt;outValue&gt;(...) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">B_quad</td><td>Evaluations to be transformed </td></tr>
    <tr><td class="paramname">F</td><td>Transformation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
