<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HArD::Core2D: Schemes/HHO-diffusion/HHO_Diffusion.hpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HArD::Core2D
   </div>
   <div id="projectbrief">Hybrid Arbitrary Degree::Core 2D - Library to implement 2D schemes with edge and cell polynomials as unknowns</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_60d99d4f8bf576094f0ece8cd9292bc3.html">Schemes</a></li><li class="navelem"><a class="el" href="dir_4bf8b0cf7eee90d47fe337be4bd09b8d.html">HHO-diffusion</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">HHO_Diffusion.hpp</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment">// Implementation of the HHO scheme in 2D for the diffusion equation</span></div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="comment">//   { -div(K \grad(u)) = f,       inside Omega</span></div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="comment">//   { K \grad(u) . nTF = g,       on GammaN</span></div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="comment">//   {                 u = g,       on GammaD</span></div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="comment">// </span></div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="comment">//  At the moment, only pure Neumann or pure Dirichlet</span></div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="comment">// Author: Jerome Droniou (jerome.droniou@monash.edu)</span></div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="comment">/*</span></div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;<span class="comment">*</span></div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;<span class="comment">*  This implementation of HHO was developped following the principles described in </span></div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;<span class="comment">* Appendix B of the book</span></div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;<span class="comment">*</span></div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<span class="comment">* The Hybrid High-Order Method for Polytopal Meshes: Design, Analysis, and Applications.</span></div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;<span class="comment">* D. A. Di Pietro and J. Droniou. 2019, 516p. </span></div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="comment">* url: https://hal.archives-ouvertes.fr/hal-02151813.</span></div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;<span class="comment">*</span></div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;<span class="comment">* If you use this code or part of it for a scientific publication, please cite the book</span></div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<span class="comment">* above as a reference for the implementation.</span></div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;<span class="comment">*</span></div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;<span class="comment">*/</span></div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;<span class="preprocessor">#ifndef _HHO_DIFFUSION_HPP</span></div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;<span class="preprocessor">#define _HHO_DIFFUSION_HPP</span></div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;<span class="preprocessor">#include &lt;functional&gt;</span></div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;<span class="preprocessor">#include &lt;utility&gt;</span></div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;<span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;<span class="preprocessor">#include &lt;boost/timer/timer.hpp&gt;</span></div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;<span class="comment">// Matrices and linear solvers</span></div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;<span class="preprocessor">#include &lt;Eigen/Sparse&gt;</span></div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;<span class="preprocessor">#include &lt;Eigen/Dense&gt;</span></div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;<span class="comment">//#include &quot;Eigen/MA41.cpp&quot;</span></div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;<span class="preprocessor">#include &lt;mesh.hpp&gt;</span></div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;<span class="preprocessor">#include &lt;hybridcore.hpp&gt;</span></div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;<span class="preprocessor">#include &lt;elementquad.hpp&gt;</span></div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;<span class="keyword">namespace </span><a class="code" href="namespaceHArDCore2D.html">HArDCore2D</a> {</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;<span class="comment">// ----------------------------------------------------------------------------</span></div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;<span class="comment">//                            Class definition</span></div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;<span class="comment">// ----------------------------------------------------------------------------</span></div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;</div><div class="line"><a name="l00063"></a><span class="lineno"><a class="line" href="classHArDCore2D_1_1HHO__Diffusion.html">   63</a></span>&#160;<span class="keyword">class </span><a class="code" href="classHArDCore2D_1_1HHO__Diffusion.html">HHO_Diffusion</a> {</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;<span class="comment">// Types</span></div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;<span class="keyword">public</span>:</div><div class="line"><a name="l00067"></a><span class="lineno"><a class="line" href="classHArDCore2D_1_1HHO__Diffusion.html#ac2ddc18a37be70e4767a9040fb6a09f6">   67</a></span>&#160;  <span class="keyword">using</span> <a class="code" href="classHArDCore2D_1_1HHO__Diffusion.html#ac2ddc18a37be70e4767a9040fb6a09f6">solution_function_type</a> = std::function&lt;double(double,double)&gt;;    </div><div class="line"><a name="l00068"></a><span class="lineno"><a class="line" href="classHArDCore2D_1_1HHO__Diffusion.html#ade095df766ff04bf09385a163136e5c0">   68</a></span>&#160;  <span class="keyword">using</span> <a class="code" href="classHArDCore2D_1_1HHO__Diffusion.html#ade095df766ff04bf09385a163136e5c0">source_function_type</a> = std::function&lt;double(double,double,Cell*)&gt;;    </div><div class="line"><a name="l00069"></a><span class="lineno"><a class="line" href="classHArDCore2D_1_1HHO__Diffusion.html#a14797a72cc96ee5ea6fc45e4986d6a84">   69</a></span>&#160;  <span class="keyword">using</span> <a class="code" href="classHArDCore2D_1_1HHO__Diffusion.html#a14797a72cc96ee5ea6fc45e4986d6a84">grad_function_type</a> = std::function&lt;Eigen::Vector2d(double,double,Cell*)&gt;;    </div><div class="line"><a name="l00070"></a><span class="lineno"><a class="line" href="classHArDCore2D_1_1HHO__Diffusion.html#acc4abb92b452d6407d45a87823fb47f9">   70</a></span>&#160;  <span class="keyword">using</span> <a class="code" href="classHArDCore2D_1_1HHO__Diffusion.html#acc4abb92b452d6407d45a87823fb47f9">tensor_function_type</a> = std::function&lt;Eigen::Matrix2d(double,double,Cell*)&gt;;    </div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;  <a class="code" href="group__HHO__Diffusion.html#ga9ab2e2cdf0c77f60069f7572c587c4f1">HHO_Diffusion</a>(</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;    <a class="code" href="classHArDCore2D_1_1HHO__Diffusion.html#acc4abb92b452d6407d45a87823fb47f9">tensor_function_type</a> kappa,   </div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;    <a class="code" href="classHArDCore2D_1_1HHO__Diffusion.html#ade095df766ff04bf09385a163136e5c0">source_function_type</a> source,  </div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;    <span class="keywordtype">size_t</span> BC,                     </div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;    <a class="code" href="classHArDCore2D_1_1HHO__Diffusion.html#ac2ddc18a37be70e4767a9040fb6a09f6">solution_function_type</a> exact_solution,   </div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;    <a class="code" href="classHArDCore2D_1_1HHO__Diffusion.html#a14797a72cc96ee5ea6fc45e4986d6a84">grad_function_type</a> grad_exact_solution,   </div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;    std::string solver_type    </div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;    );</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;  Eigen::VectorXd <a class="code" href="group__HHO__Diffusion.html#ga1aebf22f19de92c115aed69ba394de88">solve</a>(<a class="code" href="classHArDCore2D_1_1HybridCore.html">HybridCore</a>&amp; hho);</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;  <span class="keywordtype">double</span> <a class="code" href="group__HHO__Diffusion.html#ga1f21d17ee818df40d6c0081300c44982">EnergyNorm</a>(<a class="code" href="classHArDCore2D_1_1HybridCore.html">HybridCore</a>&amp; hho, <span class="keyword">const</span> Eigen::VectorXd Xh); </div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;  <span class="keywordtype">double</span> <a class="code" href="group__HHO__Diffusion.html#ga4b67f061d06b1aea5a626792a2bddd1e">get_assembly_time</a>() <span class="keyword">const</span>; </div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;  <span class="keywordtype">double</span> <a class="code" href="group__HHO__Diffusion.html#ga0ba01c42bc116f962b6982b27e95b471">get_solving_time</a>() <span class="keyword">const</span>;  </div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;  <span class="keywordtype">double</span> <a class="code" href="group__HHO__Diffusion.html#gad53ffa4a52af7bf6803e28f36c7e3365">get_solving_error</a>() <span class="keyword">const</span>;  </div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;  <span class="keywordtype">double</span> <a class="code" href="group__HHO__Diffusion.html#ga43051dfce03a9f75c33903f1736f4e1a">get_itime</a>(<span class="keywordtype">size_t</span> idx) <span class="keyword">const</span>;    </div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;<span class="keyword">private</span>:</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;  Eigen::MatrixXd diffusion_operator(<a class="code" href="classHArDCore2D_1_1HybridCore.html">HybridCore</a>&amp; hho, <span class="keyword">const</span> <span class="keywordtype">size_t</span> iT, <span class="keyword">const</span> <a class="code" href="classHArDCore2D_1_1ElementQuad.html">ElementQuad</a> &amp;elquad) <span class="keyword">const</span>;</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;  Eigen::VectorXd load_operator(<a class="code" href="classHArDCore2D_1_1HybridCore.html">HybridCore</a>&amp; hho, <span class="keyword">const</span> <span class="keywordtype">size_t</span> iT, <span class="keyword">const</span> <a class="code" href="classHArDCore2D_1_1ElementQuad.html">ElementQuad</a> &amp;elquad) <span class="keyword">const</span>;</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;  <span class="keyword">const</span> <a class="code" href="classHArDCore2D_1_1HHO__Diffusion.html#acc4abb92b452d6407d45a87823fb47f9">tensor_function_type</a> kappa;</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;  <span class="keyword">const</span> <a class="code" href="classHArDCore2D_1_1HHO__Diffusion.html#ade095df766ff04bf09385a163136e5c0">source_function_type</a> source;</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;  <span class="keyword">const</span> <span class="keywordtype">size_t</span> BC;</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;  <span class="keyword">const</span> <a class="code" href="classHArDCore2D_1_1HHO__Diffusion.html#ac2ddc18a37be70e4767a9040fb6a09f6">solution_function_type</a> exact_solution;</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;  <span class="keyword">const</span> <a class="code" href="classHArDCore2D_1_1HHO__Diffusion.html#a14797a72cc96ee5ea6fc45e4986d6a84">grad_function_type</a> grad_exact_solution;</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;  <span class="keyword">const</span> std::string solver_type;</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;  <span class="comment">// To store local bilinear forms</span></div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;  std::vector&lt;Eigen::MatrixXd&gt; aT;</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;  <span class="comment">// Computation statistics</span></div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;  <span class="keywordtype">size_t</span> _assembly_time;</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;  <span class="keywordtype">size_t</span> _solving_time;</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;  <span class="keywordtype">double</span> _solving_error;</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;  <span class="keyword">mutable</span> std::vector&lt;size_t&gt; _itime = std::vector&lt;size_t&gt;(10, 0);</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;};</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;</div><div class="line"><a name="l00118"></a><span class="lineno"><a class="line" href="group__HHO__Diffusion.html#ga9ab2e2cdf0c77f60069f7572c587c4f1">  118</a></span>&#160;<a class="code" href="group__HHO__Diffusion.html#ga9ab2e2cdf0c77f60069f7572c587c4f1">HHO_Diffusion::HHO_Diffusion</a>(<a class="code" href="classHArDCore2D_1_1HHO__Diffusion.html#acc4abb92b452d6407d45a87823fb47f9">tensor_function_type</a> kappa, <a class="code" href="classHArDCore2D_1_1HHO__Diffusion.html#ade095df766ff04bf09385a163136e5c0">source_function_type</a> source, <span class="keywordtype">size_t</span> BC, <a class="code" href="classHArDCore2D_1_1HHO__Diffusion.html#ac2ddc18a37be70e4767a9040fb6a09f6">solution_function_type</a> exact_solution, <a class="code" href="classHArDCore2D_1_1HHO__Diffusion.html#a14797a72cc96ee5ea6fc45e4986d6a84">grad_function_type</a> grad_exact_solution, std::string solver_type)</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;  : kappa(kappa),</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;    source(source),</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;    BC(BC),</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;    exact_solution(exact_solution),</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;    grad_exact_solution(grad_exact_solution),</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;    solver_type(solver_type) {</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;  <span class="comment">// Do nothing</span></div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;}</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;</div><div class="line"><a name="l00128"></a><span class="lineno"><a class="line" href="group__HHO__Diffusion.html#ga1aebf22f19de92c115aed69ba394de88">  128</a></span>&#160;Eigen::VectorXd <a class="code" href="group__HHO__Diffusion.html#ga1aebf22f19de92c115aed69ba394de88">HHO_Diffusion::solve</a>(<a class="code" href="classHArDCore2D_1_1HybridCore.html">HybridCore</a> &amp;hho) {</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;  boost::timer::cpu_timer timer;  <span class="comment">// Time the matrix assembly</span></div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;  boost::timer::cpu_timer timerint; </div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;  <span class="keyword">const</span> <span class="keyword">auto</span> mesh = hho.<a class="code" href="group__HybridCore.html#gab3337e9e6d16154e080e247b3fa43d72">get_mesh_ptr</a>();</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;  aT.resize(mesh-&gt;n_cells());</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;  <span class="comment">//--------------- PREPARE SYSTEM ------------------------//</span></div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;  <span class="comment">// System matrix</span></div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;  Eigen::SparseMatrix&lt;double&gt; GlobMat(hho.<a class="code" href="group__HybridCore.html#gac0af0b8fa9bea07b9cfba8cbb1b50bed">ntotal_edge_dofs</a>(), hho.<a class="code" href="group__HybridCore.html#gac0af0b8fa9bea07b9cfba8cbb1b50bed">ntotal_edge_dofs</a>());</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;  std::vector&lt;Eigen::Triplet&lt;double&gt;&gt; triplets_GlobMat;</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;  <span class="comment">// If static condensation (L&gt;=0): matrix to recover cell unknowns</span></div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;  <span class="comment">// If barycentric elimination (L=-1): matrix to recover cell unknowns</span></div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;  Eigen::SparseMatrix&lt;double&gt; ScBeMat(hho.<a class="code" href="group__HybridCore.html#ga86e6a3566cf506821606c8802a5f2364">ntotal_cell_dofs</a>(), hho.<a class="code" href="group__HybridCore.html#gac0af0b8fa9bea07b9cfba8cbb1b50bed">ntotal_edge_dofs</a>());</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;  std::vector&lt;Eigen::Triplet&lt;double&gt;&gt; triplets_ScBe;</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;  <span class="comment">// Source terms for the system, and for recovering cell unknowns from static condensation</span></div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;  Eigen::VectorXd GlobRHS = Eigen::VectorXd::Zero(hho.<a class="code" href="group__HybridCore.html#gac0af0b8fa9bea07b9cfba8cbb1b50bed">ntotal_edge_dofs</a>());</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;  Eigen::VectorXd ScRHS = Eigen::VectorXd::Zero(hho.<a class="code" href="group__HybridCore.html#ga86e6a3566cf506821606c8802a5f2364">ntotal_cell_dofs</a>());</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;  <span class="comment">// Global quadrature rule for the cells</span></div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;  Eigen::VectorXd cell_quadrature = Eigen::VectorXd::Zero(hho.<a class="code" href="group__HybridCore.html#ga86e6a3566cf506821606c8802a5f2364">ntotal_cell_dofs</a>());</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;  <span class="comment">//-------------- ASSEMBLE LOCAL CONTRIBUTIONS -------------//</span></div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;  <span class="keyword">auto</span> total_measure = 0.0;</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> iT = 0; iT &lt; mesh-&gt;n_cells(); iT++) {</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;    <a class="code" href="classHArDCore2D_1_1Cell.html">Cell</a>* iCell = mesh-&gt;cell(iT);</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;  </div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;    total_measure += iCell-&gt;<a class="code" href="group__Mesh.html#gac19ec98507a18d255bd54b1e55b16653">measure</a>();</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;    <span class="comment">// Total number of face degrees of freedom local to this cell (adjacent faces to the cell)</span></div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;    <span class="keywordtype">size_t</span> nlocal_edges = iCell-&gt;<a class="code" href="group__Mesh.html#ga1b0586610a05e1a7a64bbe11f59e9b19">n_edges</a>();</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;    <span class="keywordtype">size_t</span> edge_dofs = nlocal_edges * hho.<a class="code" href="group__HybridCore.html#ga41f1294e34e4daade19ad16981eaac15">nlocal_edge_dofs</a>();</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;    <span class="comment">// Local bilinear form and source term</span></div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;    <span class="keywordtype">size_t</span> doeT = hho.<a class="code" href="group__HybridCore.html#gaaa9fe846646c9e26f699364ac29631f6">Ldeg</a>()+hho.<a class="code" href="group__HybridCore.html#gadaf859b98dea34338c9e6376e975b131">K</a>()+1;</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;    <span class="keywordtype">size_t</span> doeF = 2*hho.<a class="code" href="group__HybridCore.html#gadaf859b98dea34338c9e6376e975b131">K</a>()+1;</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;    <a class="code" href="classHArDCore2D_1_1ElementQuad.html">ElementQuad</a> elquad(hho, iT, doeT, doeF);</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;    aT[iT] = diffusion_operator(hho, iT, elquad);</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;    Eigen::VectorXd bT = load_operator(hho, iT, elquad);</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;    <span class="comment">// Local matrix and right-hand side on the face unknowns</span></div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;    Eigen::MatrixXd MatF = Eigen::MatrixXd::Zero(edge_dofs,edge_dofs);</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;    Eigen::VectorXd bF = Eigen::VectorXd::Zero(edge_dofs);</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;    <span class="keywordflow">if</span> (hho.<a class="code" href="group__HybridCore.html#ga816cd87658b200d1ea32d2c4fefd5c6e">L</a>()&gt;=0) {</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;      <span class="comment">// STATIC CONDENSATION OF ELEMENT UNKNOWNS</span></div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;      <span class="comment">// Perform static condensation</span></div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;      Eigen::MatrixXd ATT = aT[iT].topLeftCorner(hho.<a class="code" href="group__HybridCore.html#gab698480a3a9e9339d5c191549b817501">nlocal_cell_dofs</a>(), hho.<a class="code" href="group__HybridCore.html#gab698480a3a9e9339d5c191549b817501">nlocal_cell_dofs</a>());</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;      Eigen::MatrixXd ATF = aT[iT].topRightCorner(hho.<a class="code" href="group__HybridCore.html#gab698480a3a9e9339d5c191549b817501">nlocal_cell_dofs</a>(), edge_dofs);</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;      Eigen::MatrixXd AFF = aT[iT].bottomRightCorner(edge_dofs, edge_dofs);</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;      Eigen::PartialPivLU&lt;Eigen::MatrixXd&gt; invATT;</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;      invATT.compute(ATT);</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;      </div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;      Eigen::MatrixXd invATT_ATF = invATT.solve(ATF);</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;      Eigen::VectorXd invATT_bTcell = invATT.solve(bT.head(hho.<a class="code" href="group__HybridCore.html#gab698480a3a9e9339d5c191549b817501">nlocal_cell_dofs</a>()));</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;      MatF = AFF - ATF.transpose() * invATT_ATF;</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;      </div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;      bF = bT.tail(edge_dofs) - ATF.transpose() * invATT_bTcell;</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;            </div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;      <span class="comment">// Assemble static condensation operator</span></div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;      ScRHS.segment(iT * hho.<a class="code" href="group__HybridCore.html#gab698480a3a9e9339d5c191549b817501">nlocal_cell_dofs</a>(), hho.<a class="code" href="group__HybridCore.html#gab698480a3a9e9339d5c191549b817501">nlocal_cell_dofs</a>()) = invATT_bTcell;</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; hho.<a class="code" href="group__HybridCore.html#gab698480a3a9e9339d5c191549b817501">nlocal_cell_dofs</a>(); i++) {</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> jlF = 0; jlF &lt; nlocal_edges; jlF++) {</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;          <span class="keyword">const</span> <span class="keywordtype">size_t</span> jF = iCell-&gt;<a class="code" href="classHArDCore2D_1_1Cell.html#a85defed1382a8af8227e89f00434603e">edge</a>(jlF)-&gt;<a class="code" href="group__Mesh.html#ga774e975ebad5e6bdccf549215293d624">global_index</a>();</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;          <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> jk = 0; jk &lt; hho.<a class="code" href="group__HybridCore.html#ga41f1294e34e4daade19ad16981eaac15">nlocal_edge_dofs</a>(); jk++) {</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;            <span class="keyword">const</span> <span class="keywordtype">size_t</span> jLocal = jlF * hho.<a class="code" href="group__HybridCore.html#ga41f1294e34e4daade19ad16981eaac15">nlocal_edge_dofs</a>() + jk;</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;            <span class="keyword">const</span> <span class="keywordtype">size_t</span> jGlobal = jF * hho.<a class="code" href="group__HybridCore.html#ga41f1294e34e4daade19ad16981eaac15">nlocal_edge_dofs</a>() + jk;</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;            triplets_ScBe.emplace_back(iT * hho.<a class="code" href="group__HybridCore.html#gab698480a3a9e9339d5c191549b817501">nlocal_cell_dofs</a>() + i, jGlobal, invATT_ATF(i, jLocal));</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;          }</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;        }</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;      }</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;    } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;      <span class="comment">// BARYCENTRIC ELIMINATION OF ELEMENT UNKNOWNS</span></div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;      <span class="comment">// Create reduction matrix: 1+nlocal_edges * nlocal_edges matrix with the coefficients on the first row, and the identity below. When multiplied by the face unknowns, return cell and face unknowns</span></div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;      <span class="comment">// Note that the basis functions are constant, but not necessarily assumed to be one (which is not the case after orthonormalisation for example), which is why we have to adjust the first row.</span></div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;      Eigen::MatrixXd red_matT = Eigen::MatrixXd::Zero(1+nlocal_edges,nlocal_edges);</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;      red_matT.row(0) = hho.<a class="code" href="classHArDCore2D_1_1HybridCore.html#a06825c5d156026d465a2798389aa952b">compute_weights</a>(iT);</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;      Eigen::Vector2d xT = iCell-&gt;<a class="code" href="group__Mesh.html#ga66b278b12266d5c5bfee8699886cc89b">center_mass</a>();</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;      <span class="keywordtype">double</span> phiT_cst = hho.<a class="code" href="classHArDCore2D_1_1HybridCore.html#a34242db07cc2b3c3b867d9e4580b634d">cell_basis</a>(iT,0)(xT.x(), xT.y());</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> ilE = 0; ilE &lt; nlocal_edges; ilE++){</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;        Eigen::Vector2d xE = iCell-&gt;<a class="code" href="classHArDCore2D_1_1Cell.html#a85defed1382a8af8227e89f00434603e">edge</a>(ilE)-&gt;<a class="code" href="group__Mesh.html#ga41ebc04d2b292197a02a9afd25a76a18">center_mass</a>();</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;        <span class="keywordtype">size_t</span> iE = iCell-&gt;<a class="code" href="classHArDCore2D_1_1Cell.html#a85defed1382a8af8227e89f00434603e">edge</a>(ilE)-&gt;<a class="code" href="group__Mesh.html#ga774e975ebad5e6bdccf549215293d624">global_index</a>();</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;        <span class="keywordtype">double</span> phiE_cst = hho.<a class="code" href="classHArDCore2D_1_1HybridCore.html#a6b4feaeef7739a2e30fcf6c601fcf721">edge_basis</a>(iE,0)(xE.x(), xE.y());</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;        red_matT(0,ilE) *= phiE_cst / phiT_cst;</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;      }</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;      red_matT.bottomRightCorner(nlocal_edges,nlocal_edges) = Eigen::MatrixXd::Identity(nlocal_edges,nlocal_edges);</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;      bF = red_matT.transpose() * bT;</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;      MatF = red_matT.transpose() * aT[iT] * red_matT;</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;      <span class="comment">// To recover cell unknown</span></div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> jlF = 0; jlF &lt; nlocal_edges; jlF++) {</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;        <span class="keyword">const</span> <span class="keywordtype">size_t</span> jF = iCell-&gt;<a class="code" href="classHArDCore2D_1_1Cell.html#a85defed1382a8af8227e89f00434603e">edge</a>(jlF)-&gt;<a class="code" href="group__Mesh.html#ga774e975ebad5e6bdccf549215293d624">global_index</a>();</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;        <span class="keyword">const</span> <span class="keywordtype">size_t</span> jGlobal = jF * hho.<a class="code" href="group__HybridCore.html#ga41f1294e34e4daade19ad16981eaac15">nlocal_edge_dofs</a>();</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;        triplets_ScBe.emplace_back(iT, jGlobal, red_matT(0,jlF));</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;      }</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;    }</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;    <span class="comment">// Assemble local contribution into global matrix</span></div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> ilF = 0; ilF &lt; nlocal_edges; ilF++) {</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;      <span class="keyword">const</span> <span class="keywordtype">size_t</span> iF = iCell-&gt;<a class="code" href="classHArDCore2D_1_1Cell.html#a85defed1382a8af8227e89f00434603e">edge</a>(ilF)-&gt;<a class="code" href="group__Mesh.html#ga774e975ebad5e6bdccf549215293d624">global_index</a>();</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> ik = 0; ik &lt; hho.<a class="code" href="group__HybridCore.html#ga41f1294e34e4daade19ad16981eaac15">nlocal_edge_dofs</a>(); ik++) {</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;        <span class="keyword">const</span> <span class="keywordtype">size_t</span> iLocal = ilF * hho.<a class="code" href="group__HybridCore.html#ga41f1294e34e4daade19ad16981eaac15">nlocal_edge_dofs</a>() + ik;</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;        <span class="keyword">const</span> <span class="keywordtype">size_t</span> iGlobal = iF * hho.<a class="code" href="group__HybridCore.html#ga41f1294e34e4daade19ad16981eaac15">nlocal_edge_dofs</a>() + ik;</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> jlF = 0; jlF &lt; nlocal_edges; jlF++) {</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;          <span class="keyword">const</span> <span class="keywordtype">size_t</span> jF = iCell-&gt;<a class="code" href="classHArDCore2D_1_1Cell.html#a85defed1382a8af8227e89f00434603e">edge</a>(jlF)-&gt;<a class="code" href="group__Mesh.html#ga774e975ebad5e6bdccf549215293d624">global_index</a>();</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;          <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> jk = 0; jk &lt; hho.<a class="code" href="group__HybridCore.html#ga41f1294e34e4daade19ad16981eaac15">nlocal_edge_dofs</a>(); jk++) {</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;            <span class="keyword">const</span> <span class="keywordtype">size_t</span> jLocal = jlF * hho.<a class="code" href="group__HybridCore.html#ga41f1294e34e4daade19ad16981eaac15">nlocal_edge_dofs</a>() + jk;</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;            <span class="keyword">const</span> <span class="keywordtype">size_t</span> jGlobal = jF * hho.<a class="code" href="group__HybridCore.html#ga41f1294e34e4daade19ad16981eaac15">nlocal_edge_dofs</a>() + jk;</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;            triplets_GlobMat.emplace_back(iGlobal, jGlobal, MatF(iLocal, jLocal));</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;          }</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;        }</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;        GlobRHS(iGlobal) += bF(iLocal);</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;      }</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;    }</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;  </div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;    <span class="comment">// Record cell quadrature</span></div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;    <span class="keywordflow">if</span> (BC==1){</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; hho.<a class="code" href="group__HybridCore.html#gab698480a3a9e9339d5c191549b817501">nlocal_cell_dofs</a>(); i++) {</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;        <span class="keyword">const</span> <span class="keyword">auto</span>&amp; phi_i = hho.<a class="code" href="classHArDCore2D_1_1HybridCore.html#a34242db07cc2b3c3b867d9e4580b634d">cell_basis</a>(iT, i);</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;        cell_quadrature(iT * hho.<a class="code" href="group__HybridCore.html#gab698480a3a9e9339d5c191549b817501">nlocal_cell_dofs</a>() + i) = hho.<a class="code" href="group__HybridCore.html#ga64ffbc44306e06018efe3cea5a62f652">integrate_over_cell</a>(iT, phi_i);</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;      }</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;    }</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;  }</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;  <span class="keywordflow">if</span> (BC==1){</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;    <span class="comment">// Neumann BC: remove a row in the matrix and fix the first degree of freedom</span></div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;    triplets_GlobMat.erase(std::remove_if(std::begin(triplets_GlobMat), std::end(triplets_GlobMat),</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;                                  [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; x) { <span class="keywordflow">return</span> (x.row() == 0); }), std::end(triplets_GlobMat));</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;    triplets_GlobMat.emplace_back(0, 0, 1);</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;    GlobRHS(0) = 0;</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;  }</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;  <span class="comment">// Assemble the global linear system (without BC), and matrix to recover statically-condensed cell dofs</span></div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;  GlobMat.setFromTriplets(std::begin(triplets_GlobMat), std::end(triplets_GlobMat));</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;  ScBeMat.setFromTriplets(std::begin(triplets_ScBe), std::end(triplets_ScBe));</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;  <span class="comment">//-------------- TREATMENT OF BOUNDARY CONDITIONS -------------//</span></div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;  <span class="comment">// If Dirichlet, the final system is only posed on the interior edge unknowns and we have to subtract from the source</span></div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;  <span class="comment">//    term the contribution of the boundary values</span></div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;  <span class="comment">// If Neumann, the final system is posed on all edge unknowns</span></div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;  <span class="keywordtype">size_t</span> nb_unknowns = 0;</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;  <span class="keywordtype">size_t</span> nb_fixed_dofs = 0;</div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;  Eigen::SparseMatrix&lt;double&gt; A;</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;  Eigen::VectorXd B;</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;  Eigen::VectorXd UDir;</div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;  <span class="keywordflow">if</span> (BC==0){</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;    <span class="comment">// Dirichlet boundary conditions</span></div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;    nb_unknowns = hho.<a class="code" href="group__HybridCore.html#ga95c76303ee1dabc5c78f0bdd7a2c6aaa">ninternal_edge_dofs</a>();</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;    nb_fixed_dofs = hho.<a class="code" href="group__HybridCore.html#ga4e7b0325c0966ec722fe8808048fb3ab">nboundary_edge_dofs</a>();</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;    A = GlobMat.topLeftCorner(nb_unknowns, nb_unknowns);</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;    </div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;    <span class="comment">// Boundary value: UDir corresponds to the L2 projection of the exact solution on the polynomial spaces on the edges</span></div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;    UDir = Eigen::VectorXd::Zero(nb_fixed_dofs);</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;    std::vector&lt;Edge *&gt; b_edges = mesh-&gt;get_b_edges(); <span class="comment">// List of boundary edges</span></div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> ibF = 0; ibF &lt; mesh-&gt;n_b_edges(); ibF++){</div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;      <a class="code" href="classHArDCore2D_1_1Edge.html">Edge</a>* edge = b_edges[ibF]; </div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;      <span class="keywordtype">size_t</span> iF = edge-&gt;<a class="code" href="group__Mesh.html#ga774e975ebad5e6bdccf549215293d624">global_index</a>();</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;      <span class="comment">// Mass matrix and boundary values</span></div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;      QuadratureRule quadF = <a class="code" href="group__Quadratures.html#gaccff0bc4833f415d2160633e2d93ccc3">generate_quadrature_rule</a>(*edge, 2*hho.<a class="code" href="group__HybridCore.html#gadaf859b98dea34338c9e6376e975b131">K</a>());</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;      std::vector&lt;Eigen::ArrayXd&gt; phiF_quadF = hho.<a class="code" href="classHArDCore2D_1_1HybridCore.html#acf453b4f239a76fe7f21b02ac91e127c">basis_quad</a>(<span class="stringliteral">&quot;edge&quot;</span>, iF, quadF, hho.<a class="code" href="group__HybridCore.html#gadaf859b98dea34338c9e6376e975b131">K</a>());</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;      Eigen::MatrixXd MFF = hho.<a class="code" href="classHArDCore2D_1_1HybridCore.html#aa5c203c11a661933930a33335b0e2479">gram_matrix</a>(phiF_quadF, phiF_quadF, hho.<a class="code" href="group__HybridCore.html#ga41f1294e34e4daade19ad16981eaac15">nlocal_edge_dofs</a>(), hho.<a class="code" href="group__HybridCore.html#ga41f1294e34e4daade19ad16981eaac15">nlocal_edge_dofs</a>(), quadF, <span class="keyword">true</span>);</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;      <span class="comment">// Compute (uexact, phi_i)_F for all edge basis functions phi_i</span></div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;      Eigen::VectorXd RHS_UDirF = Eigen::VectorXd::Zero(hho.<a class="code" href="group__HybridCore.html#ga41f1294e34e4daade19ad16981eaac15">nlocal_edge_dofs</a>());</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; hho.<a class="code" href="group__HybridCore.html#ga41f1294e34e4daade19ad16981eaac15">nlocal_edge_dofs</a>(); j++){</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;        <span class="keyword">const</span> <span class="keyword">auto</span>&amp; phi_j = hho.<a class="code" href="classHArDCore2D_1_1HybridCore.html#a6b4feaeef7739a2e30fcf6c601fcf721">edge_basis</a>(iF, j);</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;        QuadratureRule quadF = <a class="code" href="group__Quadratures.html#gaccff0bc4833f415d2160633e2d93ccc3">generate_quadrature_rule</a>(*edge, 2*hho.<a class="code" href="group__HybridCore.html#gadaf859b98dea34338c9e6376e975b131">K</a>()+2);</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;        <span class="keywordflow">for</span> (<a class="code" href="structHArDCore2D_1_1QuadratureNode.html">QuadratureNode</a> qF : quadF){</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;          RHS_UDirF(j) += qF.w * phi_j(qF.x, qF.y) * exact_solution(qF.x, qF.y);</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;        }</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;      }</div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;      <span class="comment">// Project exact solution</span></div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;      UDir.segment(ibF * hho.<a class="code" href="group__HybridCore.html#ga41f1294e34e4daade19ad16981eaac15">nlocal_edge_dofs</a>(), hho.<a class="code" href="group__HybridCore.html#ga41f1294e34e4daade19ad16981eaac15">nlocal_edge_dofs</a>()) = MFF.ldlt().solve(RHS_UDirF);</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;    }</div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;</div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;    B = GlobRHS.segment(0, nb_unknowns) - GlobMat.topRightCorner(nb_unknowns, nb_fixed_dofs) * UDir;</div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;</div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (BC==1){</div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;    <span class="comment">// We will solve the complete system</span></div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;    nb_unknowns = hho.<a class="code" href="group__HybridCore.html#gac0af0b8fa9bea07b9cfba8cbb1b50bed">ntotal_edge_dofs</a>();</div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;    A = GlobMat;</div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;    B = GlobRHS;</div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;    UDir = Eigen::VectorXd::Zero(nb_fixed_dofs);</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;  }</div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;</div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;  _assembly_time = timer.elapsed().user + timer.elapsed().system;</div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;</div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;  <span class="comment">//-------------- SOLVE CONDENSED SYSTEM -------------//</span></div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;  timer.start();</div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;</div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;  Eigen::VectorXd xF = Eigen::VectorXd::Zero(nb_unknowns);</div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;</div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;<span class="comment">//  if (solver_type == &quot;ma41&quot;) {</span></div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;<span class="comment">//    Eigen::MA41&lt;Eigen::SparseMatrix&lt;double&gt;, Eigen::VectorXd&gt; solver;</span></div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;<span class="comment">//    solver.analyzePattern(A);</span></div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;<span class="comment">//    solver.factorize(A);</span></div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;<span class="comment">//    xF = solver.solve(B);</span></div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;<span class="comment">//  } else {</span></div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;    Eigen::BiCGSTAB&lt;Eigen::SparseMatrix&lt;double&gt; &gt; solver;</div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;    solver.compute(A);</div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;    xF = solver.solve(B);</div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;    std::cout &lt;&lt; <span class="stringliteral">&quot;#iterations:     &quot;</span> &lt;&lt; solver.iterations() &lt;&lt; std::endl;</div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;    std::cout &lt;&lt; <span class="stringliteral">&quot;estimated error: &quot;</span> &lt;&lt; solver.error()      &lt;&lt; std::endl;</div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;<span class="comment">//  }</span></div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;  _solving_error = (A * xF - B).norm();</div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;  <span class="comment">// Recover the fixed boundary values, cell unknowns (from static condensation/barycentric elimination)</span></div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;  Eigen::VectorXd Xh = Eigen::VectorXd::Zero(hho.<a class="code" href="group__HybridCore.html#gaf887b486ad0eea60382e306f1487b44a">ntotal_dofs</a>());</div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;  Xh.tail(nb_fixed_dofs) = UDir;</div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;  Xh.segment(hho.<a class="code" href="group__HybridCore.html#ga86e6a3566cf506821606c8802a5f2364">ntotal_cell_dofs</a>(), nb_unknowns) = xF;</div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;  <span class="keywordflow">if</span> (hho.<a class="code" href="group__HybridCore.html#ga816cd87658b200d1ea32d2c4fefd5c6e">L</a>()&gt;=0) {</div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;    Xh.head(hho.<a class="code" href="group__HybridCore.html#ga86e6a3566cf506821606c8802a5f2364">ntotal_cell_dofs</a>()) = ScRHS - ScBeMat * Xh.tail(hho.<a class="code" href="group__HybridCore.html#gac0af0b8fa9bea07b9cfba8cbb1b50bed">ntotal_edge_dofs</a>());</div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;  } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;    Xh.head(hho.<a class="code" href="group__HybridCore.html#ga86e6a3566cf506821606c8802a5f2364">ntotal_cell_dofs</a>()) = ScBeMat * Xh.tail(hho.<a class="code" href="group__HybridCore.html#gac0af0b8fa9bea07b9cfba8cbb1b50bed">ntotal_edge_dofs</a>());</div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;  }</div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;</div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;  <span class="comment">// Only Neumann: translate to get the proper average</span></div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;  <span class="keywordflow">if</span> (BC==1){</div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;    <span class="comment">// Compute average to translate</span></div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;    <span class="keyword">auto</span> average = cell_quadrature.dot(Xh.head(hho.<a class="code" href="group__HybridCore.html#ga86e6a3566cf506821606c8802a5f2364">ntotal_cell_dofs</a>())) / total_measure;</div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;    <span class="keyword">auto</span> average_exact_sol = hho.<a class="code" href="group__HybridCore.html#gab058c4e54d1e33c49e537b8d0f602848">integrate_over_domain</a>([&amp;](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) {</div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;      <span class="keywordflow">return</span> exact_solution(x,y);</div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;      }) / total_measure;</div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;</div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;    <span class="comment">// Translate the cells and edges</span></div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;    <span class="comment">// We compute the interpolant of the constant function &quot;average_exact_sol - average&quot; </span></div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;    <span class="comment">// and we translate Xh by that amount</span></div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;    std::function&lt;double(double, double)&gt; AveDiff = [&amp;average_exact_sol,&amp;average](<span class="keywordtype">double</span> x, <span class="keywordtype">double</span> y)-&gt;<span class="keywordtype">double</span></div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;        { <span class="keywordflow">return</span> average_exact_sol - average;};</div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;    Eigen::VectorXd Cst = hho.<a class="code" href="group__HybridCore.html#ga71c953efc96f467cb24faa1b60ee9bb2">interpolate</a>(AveDiff, 2*hho.<a class="code" href="group__HybridCore.html#gadaf859b98dea34338c9e6376e975b131">K</a>()+3);</div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;    Xh += Cst;</div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;</div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;  }</div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;</div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;  _solving_time = timer.elapsed().user + timer.elapsed().system;  <span class="comment">// Record the final solving time</span></div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;</div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;  <span class="keywordflow">return</span> Xh;</div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;}</div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;</div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;<span class="comment">//******************************** </span></div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;<span class="comment">//    local diffusion matrix </span></div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;<span class="comment">//********************************</span></div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;</div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;Eigen::MatrixXd HHO_Diffusion::diffusion_operator(<a class="code" href="classHArDCore2D_1_1HybridCore.html">HybridCore</a> &amp;hho, <span class="keyword">const</span> <span class="keywordtype">size_t</span> iT, <span class="keyword">const</span> <a class="code" href="classHArDCore2D_1_1ElementQuad.html">ElementQuad</a> &amp;elquad)<span class="keyword"> const </span>{</div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;</div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;  boost::timer::cpu_timer timeint;</div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;</div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;  <span class="keyword">const</span> <span class="keyword">auto</span> mesh = hho.<a class="code" href="group__HybridCore.html#gab3337e9e6d16154e080e247b3fa43d72">get_mesh_ptr</a>();</div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;  <a class="code" href="classHArDCore2D_1_1Cell.html">Cell</a>* cell = mesh-&gt;cell(iT);</div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;  <span class="keyword">const</span> <span class="keywordtype">size_t</span> nedgesT = cell-&gt;<a class="code" href="group__Mesh.html#ga1b0586610a05e1a7a64bbe11f59e9b19">n_edges</a>();</div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;</div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;  <span class="comment">// Total number of degrees of freedom local to this cell (cell and its adjacent faces)</span></div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;  <span class="keywordtype">size_t</span> local_dofs = hho.<a class="code" href="group__HybridCore.html#gab698480a3a9e9339d5c191549b817501">nlocal_cell_dofs</a>() + nedgesT * hho.<a class="code" href="group__HybridCore.html#ga41f1294e34e4daade19ad16981eaac15">nlocal_edge_dofs</a>();</div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;</div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;  <span class="comment">//-------------------  Initialisatons ------------------------------//</span></div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;</div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;timeint.start();</div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;  </div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;  <span class="comment">// Diffusion in the cell.</span></div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;  std::function&lt;Eigen::Matrix2d(double,double)&gt; kappaT = [&amp;](<span class="keywordtype">double</span> x, <span class="keywordtype">double</span> y){</div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;    <span class="comment">// Constant in the cell</span></div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;    Eigen::Vector2d cellcenter = cell-&gt;<a class="code" href="group__Mesh.html#ga66b278b12266d5c5bfee8699886cc89b">center_mass</a>();</div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;    <span class="keywordflow">return</span> kappa(cellcenter.x(), cellcenter.y(), cell);</div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;    <span class="comment">// Variable in the cell - the scheme may not provide optimal convergence rate if the diffusion is actually variable in the cell!</span></div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;    <span class="comment">// If the diffusion is piecewise constant, choosing the previous version ensures that, for edge integrals, it&#39;s the value inside the cell that is computed (essential in case kappa is discontinuous across the edges)</span></div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;<span class="comment">//      return kappa(x, y, cell);</span></div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;  };</div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;</div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;  <span class="comment">// Compute cell quadrature nodes and values of cell basis functions and gradients at these nodes</span></div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;  QuadratureRule quadT = elquad.<a class="code" href="group__HybridCore.html#ga16951d0e488060237fbb5eee3c5194b2">get_quadT</a>();</div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;  std::vector&lt;Eigen::ArrayXd&gt; phiT_quadT = elquad.<a class="code" href="group__HybridCore.html#ga0cde817c1cf12e839c3f195aa02498ba">get_phiT_quadT</a>();</div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;  std::vector&lt;Eigen::ArrayXXd&gt; dphiT_quadT = elquad.<a class="code" href="group__HybridCore.html#gae8e43d7a9a64a009690c4890534e6549">get_dphiT_quadT</a>();</div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;  <span class="comment">// Diffusion tensor at the quadrature nodes</span></div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;  std::vector&lt;Eigen::Matrix2d&gt; kappaT_quadT(quadT.size());</div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;  std::transform(quadT.begin(), quadT.end(), kappaT_quadT.begin(),</div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;      [&amp;kappaT,&amp;cell](<a class="code" href="structHArDCore2D_1_1QuadratureNode.html">QuadratureNode</a> qr) -&gt; Eigen::MatrixXd { <span class="keywordflow">return</span> kappaT(qr.x, qr.y); });</div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;</div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;</div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;_itime[0] += timeint.elapsed().user + timeint.elapsed().system;</div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;timeint.start();</div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;</div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;  <span class="comment">// Preparing matrices to store face mass matrices (for face and cell basis functions), and face-cell mass matrices</span></div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;  <span class="comment">// (will be useful for the stabilisation term)</span></div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;  std::vector&lt;Eigen::MatrixXd&gt; MFF(mesh-&gt;cell(iT)-&gt;n_edges(), Eigen::MatrixXd::Zero(hho.<a class="code" href="group__HybridCore.html#ga41f1294e34e4daade19ad16981eaac15">nlocal_edge_dofs</a>(), hho.<a class="code" href="group__HybridCore.html#ga41f1294e34e4daade19ad16981eaac15">nlocal_edge_dofs</a>()));</div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;  std::vector&lt;Eigen::MatrixXd&gt; MFT(mesh-&gt;cell(iT)-&gt;n_edges(), Eigen::MatrixXd::Zero(hho.<a class="code" href="group__HybridCore.html#ga41f1294e34e4daade19ad16981eaac15">nlocal_edge_dofs</a>(), hho.<a class="code" href="group__HybridCore.html#ga57c23358c4ca7e485e8382c6b2761ad5">nhighorder_dofs</a>()));</div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;</div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;_itime[1] += timeint.elapsed().user + timeint.elapsed().system;</div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;timeint.start();</div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;</div><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;</div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;  <span class="comment">//-------------------- Compute PT, matrix of potential reconstruction ---------//</span></div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;</div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;  <span class="comment">// Stiffness matrix (kappaT dphi_i,dphi_j)_T for phi_i, phi_j up to degree K+1</span></div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;  Eigen::MatrixXd StiffT = hho.<a class="code" href="classHArDCore2D_1_1HybridCore.html#aa5c203c11a661933930a33335b0e2479">gram_matrix</a>(dphiT_quadT, dphiT_quadT, hho.<a class="code" href="group__HybridCore.html#ga57c23358c4ca7e485e8382c6b2761ad5">nhighorder_dofs</a>(), hho.<a class="code" href="group__HybridCore.html#ga57c23358c4ca7e485e8382c6b2761ad5">nhighorder_dofs</a>(), quadT, <span class="keyword">true</span>, kappaT_quadT);  </div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;</div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;  <span class="comment">// Mass matrix of (phi_i,phi_j)_T for phi_i up to degree L and phi_j up to degree K+1</span></div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;  Eigen::MatrixXd MTT = hho.<a class="code" href="classHArDCore2D_1_1HybridCore.html#aa5c203c11a661933930a33335b0e2479">gram_matrix</a>(phiT_quadT, phiT_quadT, hho.<a class="code" href="group__HybridCore.html#gab698480a3a9e9339d5c191549b817501">nlocal_cell_dofs</a>(), hho.<a class="code" href="group__HybridCore.html#ga57c23358c4ca7e485e8382c6b2761ad5">nhighorder_dofs</a>(), quadT, <span class="keyword">true</span>);</div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;</div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;  <span class="comment">// Row vector of (phi_j,1)_T for phi_j up to degree K+1, and LT^t*LT (used later to impose average condition on PT)</span></div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;  Eigen::VectorXd LT = (MTT.row(0)).transpose();</div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;  Eigen::MatrixXd LTtLT = LT * (LT.transpose());</div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;</div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;  <span class="comment">// Right-hand side: we start with volumetric terms (dphi_i,dphi_j)_T for phi_i up to degree K+1 and phi_j up to degree L</span></div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;  Eigen::MatrixXd BP = Eigen::MatrixXd::Zero(hho.<a class="code" href="group__HybridCore.html#ga57c23358c4ca7e485e8382c6b2761ad5">nhighorder_dofs</a>(), local_dofs);</div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;  BP.topLeftCorner(hho.<a class="code" href="group__HybridCore.html#ga57c23358c4ca7e485e8382c6b2761ad5">nhighorder_dofs</a>(), hho.<a class="code" href="group__HybridCore.html#gab698480a3a9e9339d5c191549b817501">nlocal_cell_dofs</a>()) = StiffT.topLeftCorner(hho.<a class="code" href="group__HybridCore.html#ga57c23358c4ca7e485e8382c6b2761ad5">nhighorder_dofs</a>(), hho.<a class="code" href="group__HybridCore.html#gab698480a3a9e9339d5c191549b817501">nlocal_cell_dofs</a>());</div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;</div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;  <span class="comment">// Boundary terms in BP</span></div><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> ilF = 0; ilF &lt; mesh-&gt;cell(iT)-&gt;n_edges(); ilF++) {</div><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;    <span class="comment">// Offset for face unknowns</span></div><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">size_t</span> offset_F = hho.<a class="code" href="group__HybridCore.html#gab698480a3a9e9339d5c191549b817501">nlocal_cell_dofs</a>() + ilF * hho.<a class="code" href="group__HybridCore.html#ga41f1294e34e4daade19ad16981eaac15">nlocal_edge_dofs</a>();</div><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; nTF = mesh-&gt;cell(iT)-&gt;edge_normal(ilF);</div><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;</div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;    <span class="comment">// Compute face quadrature nodes and values of basis functions (and gradients) at these nodes</span></div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;    QuadratureRule quadF = elquad.<a class="code" href="group__HybridCore.html#gaa90e88daa7803576aaeb9edc3574e935">get_quadF</a>(ilF);</div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;    <span class="keywordtype">size_t</span> nbqF = quadF.size();</div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;    </div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;    std::vector&lt;Eigen::ArrayXd&gt; phiT_quadF = elquad.<a class="code" href="group__HybridCore.html#ga89dc78ee0eea49e4a9725ed7df748ba9">get_phiT_quadF</a>(ilF);</div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;    std::vector&lt;Eigen::ArrayXd&gt; phiF_quadF = elquad.<a class="code" href="group__HybridCore.html#ga2c8a70eb42762e460ad31e4d43afb0e8">get_phiF_quadF</a>(ilF);</div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;    std::vector&lt;Eigen::ArrayXXd&gt; dphiT_quadF = elquad.<a class="code" href="group__HybridCore.html#ga11e133360ae70b9aef714054b7de76a4">get_dphiT_quadF</a>(ilF);</div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;</div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;    <span class="comment">// Calculation of RHS BP</span></div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;    <span class="comment">//</span></div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;    <span class="comment">// kappaT*nTF on quadrature nodes</span></div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;    std::vector&lt;Eigen::Vector2d&gt; quadF_kappaT_nTF(nbqF, Eigen::Vector2d::Zero());</div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> iqn = 0; iqn &lt; nbqF; iqn++){</div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;      quadF_kappaT_nTF[iqn] = quadF[iqn].w * kappaT(quadF[iqn].x, quadF[iqn].y)*nTF;</div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;    }</div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 1; i &lt; hho.<a class="code" href="group__HybridCore.html#ga57c23358c4ca7e485e8382c6b2761ad5">nhighorder_dofs</a>(); i++) {</div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;      <span class="comment">// We do not need i=0 because it corresponds to dphi_i=0</span></div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> iqn = 0; iqn &lt; nbqF; iqn++){</div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;        <span class="comment">// Contribution of test function to BP(i, .)</span></div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;        <span class="keywordtype">double</span> contrib_i = (dphiT_quadF[i].col(iqn).matrix()).dot(quadF_kappaT_nTF[iqn]);</div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;        <span class="comment">// Integration</span></div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; hho.<a class="code" href="group__HybridCore.html#gab698480a3a9e9339d5c191549b817501">nlocal_cell_dofs</a>(); j++) {</div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;          <span class="comment">// Cell unknown</span></div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;          BP(i,j) -= contrib_i * phiT_quadF[j](iqn);</div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;        }</div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; hho.<a class="code" href="group__HybridCore.html#ga41f1294e34e4daade19ad16981eaac15">nlocal_edge_dofs</a>(); j++) {</div><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;          <span class="comment">// Edge unknowns</span></div><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;          BP(i, offset_F + j) += contrib_i * phiF_quadF[j](iqn);</div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;        }</div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;      }</div><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;    }</div><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;</div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;</div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;    <span class="comment">// Face mass matrix, and cell-face mass matrix, for stabilisation term below</span></div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;    MFF[ilF] = hho.<a class="code" href="classHArDCore2D_1_1HybridCore.html#aa5c203c11a661933930a33335b0e2479">gram_matrix</a>(phiF_quadF, phiF_quadF, hho.<a class="code" href="group__HybridCore.html#ga41f1294e34e4daade19ad16981eaac15">nlocal_edge_dofs</a>(), hho.<a class="code" href="group__HybridCore.html#ga41f1294e34e4daade19ad16981eaac15">nlocal_edge_dofs</a>(), quadF, <span class="keyword">true</span>);</div><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;    MFT[ilF] = hho.<a class="code" href="classHArDCore2D_1_1HybridCore.html#aa5c203c11a661933930a33335b0e2479">gram_matrix</a>(phiF_quadF, phiT_quadF, hho.<a class="code" href="group__HybridCore.html#ga41f1294e34e4daade19ad16981eaac15">nlocal_edge_dofs</a>(), hho.<a class="code" href="group__HybridCore.html#ga57c23358c4ca7e485e8382c6b2761ad5">nhighorder_dofs</a>(), quadF, <span class="keyword">false</span>);</div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160; </div><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;  }</div><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;</div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;  <span class="comment">// Compute PT</span></div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;  <span class="keywordtype">double</span> scalT = StiffT.trace() / std::pow(LT.norm(), 2);</div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;  BP.topLeftCorner(hho.<a class="code" href="group__HybridCore.html#ga57c23358c4ca7e485e8382c6b2761ad5">nhighorder_dofs</a>(), hho.<a class="code" href="group__HybridCore.html#gab698480a3a9e9339d5c191549b817501">nlocal_cell_dofs</a>()) += </div><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;          scalT * LTtLT.topLeftCorner(hho.<a class="code" href="group__HybridCore.html#ga57c23358c4ca7e485e8382c6b2761ad5">nhighorder_dofs</a>(), hho.<a class="code" href="group__HybridCore.html#gab698480a3a9e9339d5c191549b817501">nlocal_cell_dofs</a>());</div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;  Eigen::MatrixXd PT = ((StiffT+scalT*LTtLT).ldlt()).<a class="code" href="group__HHO__Diffusion.html#ga1aebf22f19de92c115aed69ba394de88">solve</a>(BP);</div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;</div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;  <span class="comment">// Consistent component (K \nabla pT, \nabla pT)_T in local bilinear form</span></div><div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;  Eigen::MatrixXd ATF = PT.transpose() * StiffT * PT;</div><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;</div><div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;  <span class="comment">//-------------------- Compute stabilisation term sT ---------//</span></div><div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;</div><div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;  Eigen::MatrixXd STF = Eigen::MatrixXd::Zero(local_dofs, local_dofs);</div><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;</div><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;  <span class="comment">// Cell residual delta_T^l = pi_T^l (rT uT) - u_T</span></div><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;  Eigen::MatrixXd MTTKinv = ( MTT.topLeftCorner(hho.<a class="code" href="group__HybridCore.html#gab698480a3a9e9339d5c191549b817501">nlocal_cell_dofs</a>(), hho.<a class="code" href="group__HybridCore.html#gab698480a3a9e9339d5c191549b817501">nlocal_cell_dofs</a>()) ).inverse();</div><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;  Eigen::MatrixXd deltaTL = MTTKinv * MTT * PT;</div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;  deltaTL.topLeftCorner(hho.<a class="code" href="group__HybridCore.html#gab698480a3a9e9339d5c191549b817501">nlocal_cell_dofs</a>(), hho.<a class="code" href="group__HybridCore.html#gab698480a3a9e9339d5c191549b817501">nlocal_cell_dofs</a>()) -=</div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;        Eigen::MatrixXd::Identity(hho.<a class="code" href="group__HybridCore.html#gab698480a3a9e9339d5c191549b817501">nlocal_cell_dofs</a>(), hho.<a class="code" href="group__HybridCore.html#gab698480a3a9e9339d5c191549b817501">nlocal_cell_dofs</a>());</div><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;</div><div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> ilF = 0; ilF &lt; nedgesT; ilF++) {</div><div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;    <span class="comment">// Two options for stabilisation: diameter of edge, or ratio measure cell/measure edge</span></div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;<span class="comment">//    double dTF = cell-&gt;edge(ilF)-&gt;diam();</span></div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;    <span class="keywordtype">double</span> dTF = cell-&gt;<a class="code" href="group__Mesh.html#gac19ec98507a18d255bd54b1e55b16653">measure</a>() / cell-&gt;<a class="code" href="classHArDCore2D_1_1Cell.html#a85defed1382a8af8227e89f00434603e">edge</a>(ilF)-&gt;<a class="code" href="classHArDCore2D_1_1Edge.html#a6c00cbb57ddc2e80e3c07849eadc68a8">measure</a>();</div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;</div><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;    Eigen::Vector2d xF = cell-&gt;<a class="code" href="classHArDCore2D_1_1Cell.html#a85defed1382a8af8227e89f00434603e">edge</a>(ilF)-&gt;<a class="code" href="group__Mesh.html#ga41ebc04d2b292197a02a9afd25a76a18">center_mass</a>();</div><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;</div><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;    <span class="keyword">auto</span> kappa_TF = kappaT(xF.x(), xF.y()).trace();</div><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;</div><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;    <span class="comment">// Face residual delta_TF^k = pi_F^k (rT uT) - u_F</span></div><div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;    Eigen::MatrixXd MFFinv = MFF[ilF].inverse();</div><div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;    Eigen::MatrixXd deltaTFK = MFFinv * MFT[ilF] * PT;</div><div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;    deltaTFK.block(0, hho.<a class="code" href="group__HybridCore.html#gab698480a3a9e9339d5c191549b817501">nlocal_cell_dofs</a>() + ilF * hho.<a class="code" href="group__HybridCore.html#ga41f1294e34e4daade19ad16981eaac15">nlocal_edge_dofs</a>(), hho.<a class="code" href="group__HybridCore.html#ga41f1294e34e4daade19ad16981eaac15">nlocal_edge_dofs</a>(), hho.<a class="code" href="group__HybridCore.html#ga41f1294e34e4daade19ad16981eaac15">nlocal_edge_dofs</a>()) -=</div><div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;        Eigen::MatrixXd::Identity(hho.<a class="code" href="group__HybridCore.html#ga41f1294e34e4daade19ad16981eaac15">nlocal_edge_dofs</a>(), hho.<a class="code" href="group__HybridCore.html#ga41f1294e34e4daade19ad16981eaac15">nlocal_edge_dofs</a>());</div><div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;</div><div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;    <span class="comment">// Stabilisation term</span></div><div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;    Eigen::MatrixXd deltaTFK_minus_deltaTL = deltaTFK - MFFinv * MFT[ilF].topLeftCorner(hho.<a class="code" href="group__HybridCore.html#ga41f1294e34e4daade19ad16981eaac15">nlocal_edge_dofs</a>(), hho.<a class="code" href="group__HybridCore.html#gab698480a3a9e9339d5c191549b817501">nlocal_cell_dofs</a>()) * deltaTL;</div><div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;</div><div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;    STF += (kappa_TF / dTF) * deltaTFK_minus_deltaTL.transpose() * MFF[ilF] *  deltaTFK_minus_deltaTL;</div><div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;</div><div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;  }</div><div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;_itime[2] += timeint.elapsed().user + timeint.elapsed().system;</div><div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;timeint.start();</div><div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;</div><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;  <span class="comment">// Adjust local bilinear form with stabilisation term</span></div><div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;  ATF += STF;</div><div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;</div><div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;  <span class="keywordflow">return</span> ATF;</div><div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;</div><div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;}</div><div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;</div><div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;</div><div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;<span class="comment">//******************************** </span></div><div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;<span class="comment">//    local load term </span></div><div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;<span class="comment">//********************************</span></div><div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;</div><div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;Eigen::VectorXd HHO_Diffusion::load_operator(<a class="code" href="classHArDCore2D_1_1HybridCore.html">HybridCore</a> &amp;hho, <span class="keyword">const</span> <span class="keywordtype">size_t</span> iT, <span class="keyword">const</span> <a class="code" href="classHArDCore2D_1_1ElementQuad.html">ElementQuad</a> &amp;elquad)<span class="keyword"> const </span>{</div><div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;  <span class="comment">// Load for the cell DOFs (first indices) and face DOFs (last indices)</span></div><div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;  <span class="keyword">const</span> <span class="keyword">auto</span> mesh = hho.<a class="code" href="group__HybridCore.html#gab3337e9e6d16154e080e247b3fa43d72">get_mesh_ptr</a>();</div><div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;  <a class="code" href="classHArDCore2D_1_1Cell.html">Cell</a>* cell = mesh-&gt;cell(iT);</div><div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;  <span class="keywordtype">size_t</span> cell_edge_dofs = hho.<a class="code" href="group__HybridCore.html#gab698480a3a9e9339d5c191549b817501">nlocal_cell_dofs</a>() + cell-&gt;<a class="code" href="group__Mesh.html#ga1b0586610a05e1a7a64bbe11f59e9b19">n_edges</a>()*hho.<a class="code" href="group__HybridCore.html#ga41f1294e34e4daade19ad16981eaac15">nlocal_edge_dofs</a>();</div><div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;  Eigen::VectorXd b = Eigen::VectorXd::Zero(cell_edge_dofs);</div><div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;</div><div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;  <span class="comment">// Quadrature nodes and values of cell basis functions at these nodes</span></div><div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;  QuadratureRule quadT = elquad.<a class="code" href="group__HybridCore.html#ga16951d0e488060237fbb5eee3c5194b2">get_quadT</a>();</div><div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;  <span class="keywordtype">size_t</span> nbq = quadT.size();</div><div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;  std::vector&lt;Eigen::ArrayXd&gt; phiT_quadT = elquad.<a class="code" href="group__HybridCore.html#ga0cde817c1cf12e839c3f195aa02498ba">get_phiT_quadT</a>();</div><div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;</div><div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;  <span class="comment">// Value of source times quadrature weights at the quadrature nodes</span></div><div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;  Eigen::ArrayXd weight_source_quad = Eigen::ArrayXd::Zero(nbq);</div><div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> iqn = 0; iqn &lt; nbq; iqn++){</div><div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;    weight_source_quad(iqn) = quadT[iqn].w * source(quadT[iqn].x, quadT[iqn].y, cell);</div><div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;  }</div><div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;</div><div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i &lt; hho.<a class="code" href="group__HybridCore.html#gab698480a3a9e9339d5c191549b817501">nlocal_cell_dofs</a>(); i++){</div><div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;    b(i) = (weight_source_quad * phiT_quadT[i]).sum();</div><div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;  }</div><div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;  <span class="comment">// Boundary values, if we have a boundary cell</span></div><div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;  <span class="keywordflow">if</span> (cell-&gt;<a class="code" href="group__Mesh.html#ga710ded03b7741c8377e0b2dda2395b46">is_boundary</a>()){</div><div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;    <span class="keywordflow">if</span> (BC==0){</div><div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;      <span class="comment">// Dirichlet BCs: no source terms on these edges</span></div><div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (BC==1) {</div><div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;      <span class="comment">// Neumann BCs</span></div><div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> ilF = 0; ilF &lt; cell-&gt;<a class="code" href="group__Mesh.html#ga1b0586610a05e1a7a64bbe11f59e9b19">n_edges</a>(); ilF++) {</div><div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;        <a class="code" href="classHArDCore2D_1_1Edge.html">Edge</a>* edge = cell-&gt;<a class="code" href="classHArDCore2D_1_1Cell.html#a85defed1382a8af8227e89f00434603e">edge</a>(ilF);</div><div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;        <span class="keyword">const</span> <span class="keywordtype">size_t</span> iF = edge-&gt;<a class="code" href="group__Mesh.html#ga774e975ebad5e6bdccf549215293d624">global_index</a>(); </div><div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;        <span class="comment">// BC on boundary faces</span></div><div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;        <span class="keywordflow">if</span> (edge-&gt;<a class="code" href="group__Mesh.html#ga10424f4b99793ab359b5dd099f9255ee">is_boundary</a>()){</div><div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;          <span class="comment">// Offset for face unknowns</span></div><div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;          <span class="keyword">const</span> <span class="keywordtype">size_t</span> offset_F = hho.<a class="code" href="group__HybridCore.html#gab698480a3a9e9339d5c191549b817501">nlocal_cell_dofs</a>() + ilF * hho.<a class="code" href="group__HybridCore.html#ga41f1294e34e4daade19ad16981eaac15">nlocal_edge_dofs</a>();</div><div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;          <span class="comment">// Normal to the edge</span></div><div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;          <span class="keyword">const</span> <span class="keyword">auto</span>&amp; nTF = cell-&gt;<a class="code" href="classHArDCore2D_1_1Cell.html#af55d7a602439110ebbb3c9aee1895580">edge_normal</a>(ilF);</div><div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;          <span class="comment">// for each DOF of the boundary face</span></div><div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;          <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; hho.<a class="code" href="group__HybridCore.html#ga41f1294e34e4daade19ad16981eaac15">nlocal_edge_dofs</a>(); i++){</div><div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;            <span class="keyword">const</span> <span class="keyword">auto</span>&amp; phi_i = hho.<a class="code" href="classHArDCore2D_1_1HybridCore.html#a6b4feaeef7739a2e30fcf6c601fcf721">edge_basis</a>(iF, i);</div><div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;            QuadratureRule quadF = <a class="code" href="group__Quadratures.html#gaccff0bc4833f415d2160633e2d93ccc3">generate_quadrature_rule</a>(*edge, 2*hho.<a class="code" href="group__HybridCore.html#gadaf859b98dea34338c9e6376e975b131">K</a>()+2);</div><div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;            std::function&lt;double(double,double)&gt; Kgrad_n = [&amp;](<span class="keywordtype">double</span> x, <span class="keywordtype">double</span> y){</div><div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;                <span class="keywordflow">return</span> nTF.dot(kappa(x,y,cell) * grad_exact_solution(x,y,cell)) * phi_i(x,y);</div><div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;              };</div><div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;            <span class="keywordflow">for</span> (<a class="code" href="structHArDCore2D_1_1QuadratureNode.html">QuadratureNode</a> qF : quadF){</div><div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;              b(offset_F + i) += qF.w * Kgrad_n(qF.x,qF.y);</div><div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;            }</div><div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;          }</div><div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;        }</div><div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;      }</div><div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;    }</div><div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;  }</div><div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;  </div><div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;  <span class="keywordflow">return</span> b;</div><div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;}</div><div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;</div><div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;</div><div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;</div><div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;<span class="comment">//******************************** </span></div><div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;<span class="comment">//    energy norm </span></div><div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;<span class="comment">//********************************</span></div><div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;</div><div class="line"><a name="l00609"></a><span class="lineno"><a class="line" href="group__HHO__Diffusion.html#ga1f21d17ee818df40d6c0081300c44982">  609</a></span>&#160;<span class="keywordtype">double</span> <a class="code" href="group__HHO__Diffusion.html#ga1f21d17ee818df40d6c0081300c44982">HHO_Diffusion::EnergyNorm</a>(<a class="code" href="classHArDCore2D_1_1HybridCore.html">HybridCore</a>&amp; hho, <span class="keyword">const</span> Eigen::VectorXd Xh) {</div><div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;  <span class="keyword">const</span> <span class="keyword">auto</span> mesh = hho.<a class="code" href="group__HybridCore.html#gab3337e9e6d16154e080e247b3fa43d72">get_mesh_ptr</a>();</div><div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;  <span class="keywordtype">double</span> value = 0.0;</div><div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;</div><div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> iT = 0; iT &lt; mesh-&gt; n_cells(); iT++) {</div><div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;    Eigen::VectorXd XTF = hho.<a class="code" href="classHArDCore2D_1_1HybridCore.html#a02b46a742045262030431b73eb112f9c">restr</a>(Xh, iT);</div><div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;    value += XTF.transpose() * aT[iT] * XTF;</div><div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;  }</div><div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;</div><div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;  <span class="keywordflow">return</span> sqrt(value);</div><div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;</div><div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;}</div><div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;</div><div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;</div><div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;</div><div class="line"><a name="l00624"></a><span class="lineno"><a class="line" href="group__HHO__Diffusion.html#ga4b67f061d06b1aea5a626792a2bddd1e">  624</a></span>&#160;<span class="keywordtype">double</span> <a class="code" href="group__HHO__Diffusion.html#ga4b67f061d06b1aea5a626792a2bddd1e">HHO_Diffusion::get_assembly_time</a>()<span class="keyword"> const </span>{</div><div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;  <span class="keywordflow">return</span> double(_assembly_time) * pow(10, -9);</div><div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;}</div><div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;</div><div class="line"><a name="l00628"></a><span class="lineno"><a class="line" href="group__HHO__Diffusion.html#ga0ba01c42bc116f962b6982b27e95b471">  628</a></span>&#160;<span class="keywordtype">double</span> <a class="code" href="group__HHO__Diffusion.html#ga0ba01c42bc116f962b6982b27e95b471">HHO_Diffusion::get_solving_time</a>()<span class="keyword"> const </span>{</div><div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;  <span class="keywordflow">return</span> double(_solving_time) * pow(10, -9);</div><div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;}</div><div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;</div><div class="line"><a name="l00632"></a><span class="lineno"><a class="line" href="group__HHO__Diffusion.html#ga43051dfce03a9f75c33903f1736f4e1a">  632</a></span>&#160;<span class="keywordtype">double</span> <a class="code" href="group__HHO__Diffusion.html#ga43051dfce03a9f75c33903f1736f4e1a">HHO_Diffusion::get_itime</a>(<span class="keywordtype">size_t</span> idx)<span class="keyword"> const </span>{</div><div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;  <span class="keywordflow">return</span> double(_itime[idx]) * pow(10, -9);</div><div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;}</div><div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;</div><div class="line"><a name="l00636"></a><span class="lineno"><a class="line" href="group__HHO__Diffusion.html#gad53ffa4a52af7bf6803e28f36c7e3365">  636</a></span>&#160;<span class="keywordtype">double</span> <a class="code" href="group__HHO__Diffusion.html#gad53ffa4a52af7bf6803e28f36c7e3365">HHO_Diffusion::get_solving_error</a>()<span class="keyword"> const </span>{</div><div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;  <span class="keywordflow">return</span> _solving_error;</div><div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;}</div><div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;</div><div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;} <span class="comment">// end of namespace HArDCore2D</span></div><div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;</div><div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;<span class="preprocessor">#endif //_HHO_DIFFUSION_HPP</span></div><div class="ttc" id="group__HybridCore_html_ga16951d0e488060237fbb5eee3c5194b2"><div class="ttname"><a href="group__HybridCore.html#ga16951d0e488060237fbb5eee3c5194b2">HArDCore2D::ElementQuad::get_quadT</a></div><div class="ttdeci">QuadratureRule get_quadT() const</div><div class="ttdoc">Returns quadrature rules in cell. </div><div class="ttdef"><b>Definition:</b> elementquad.hpp:96</div></div>
<div class="ttc" id="group__HHO__Diffusion_html_gad53ffa4a52af7bf6803e28f36c7e3365"><div class="ttname"><a href="group__HHO__Diffusion.html#gad53ffa4a52af7bf6803e28f36c7e3365">HArDCore2D::HHO_Diffusion::get_solving_error</a></div><div class="ttdeci">double get_solving_error() const</div><div class="ttdoc">residual after solving the scheme </div><div class="ttdef"><b>Definition:</b> HHO_Diffusion.hpp:636</div></div>
<div class="ttc" id="group__Mesh_html_ga774e975ebad5e6bdccf549215293d624"><div class="ttname"><a href="group__Mesh.html#ga774e975ebad5e6bdccf549215293d624">HArDCore2D::Edge::global_index</a></div><div class="ttdeci">size_t global_index() const</div><div class="ttdoc">returns the edge global index </div><div class="ttdef"><b>Definition:</b> edge.hpp:82</div></div>
<div class="ttc" id="classHArDCore2D_1_1Edge_html_a6c00cbb57ddc2e80e3c07849eadc68a8"><div class="ttname"><a href="classHArDCore2D_1_1Edge.html#a6c00cbb57ddc2e80e3c07849eadc68a8">HArDCore2D::Edge::measure</a></div><div class="ttdeci">double measure() const</div><div class="ttdoc">length of the edge </div><div class="ttdef"><b>Definition:</b> edge.cpp:55</div></div>
<div class="ttc" id="group__Mesh_html_ga66b278b12266d5c5bfee8699886cc89b"><div class="ttname"><a href="group__Mesh.html#ga66b278b12266d5c5bfee8699886cc89b">HArDCore2D::Cell::center_mass</a></div><div class="ttdeci">Vector2d center_mass() const</div><div class="ttdoc">returns the center of mass of the cell </div><div class="ttdef"><b>Definition:</b> cell.hpp:99</div></div>
<div class="ttc" id="group__HHO__Diffusion_html_ga4b67f061d06b1aea5a626792a2bddd1e"><div class="ttname"><a href="group__HHO__Diffusion.html#ga4b67f061d06b1aea5a626792a2bddd1e">HArDCore2D::HHO_Diffusion::get_assembly_time</a></div><div class="ttdeci">double get_assembly_time() const</div><div class="ttdoc">cpu time to assemble the scheme </div><div class="ttdef"><b>Definition:</b> HHO_Diffusion.hpp:624</div></div>
<div class="ttc" id="group__HybridCore_html_ga816cd87658b200d1ea32d2c4fefd5c6e"><div class="ttname"><a href="group__HybridCore.html#ga816cd87658b200d1ea32d2c4fefd5c6e">HArDCore2D::HybridCore::L</a></div><div class="ttdeci">int L() const</div><div class="ttdoc">polynomial degree of cell unknowns </div><div class="ttdef"><b>Definition:</b> hybridcore.hpp:464</div></div>
<div class="ttc" id="group__HybridCore_html_gab058c4e54d1e33c49e537b8d0f602848"><div class="ttname"><a href="group__HybridCore.html#gab058c4e54d1e33c49e537b8d0f602848">HArDCore2D::HybridCore::integrate_over_domain</a></div><div class="ttdeci">double integrate_over_domain(const Function &amp;f) const</div><div class="ttdoc">Integrates a function over the domaine. Use with parcimony, expensive (re-compute quadratures) ...</div><div class="ttdef"><b>Definition:</b> hybridcore.hpp:352</div></div>
<div class="ttc" id="classHArDCore2D_1_1HybridCore_html_a02b46a742045262030431b73eb112f9c"><div class="ttname"><a href="classHArDCore2D_1_1HybridCore.html#a02b46a742045262030431b73eb112f9c">HArDCore2D::HybridCore::restr</a></div><div class="ttdeci">Eigen::VectorXd restr(const Eigen::VectorXd &amp;Xh, size_t iT) const</div><div class="ttdoc">Extract from a global vector Xh of unknowns the unknowns corresponding to cell iT. </div><div class="ttdef"><b>Definition:</b> hybridcore.cpp:581</div></div>
<div class="ttc" id="group__HybridCore_html_ga0cde817c1cf12e839c3f195aa02498ba"><div class="ttname"><a href="group__HybridCore.html#ga0cde817c1cf12e839c3f195aa02498ba">HArDCore2D::ElementQuad::get_phiT_quadT</a></div><div class="ttdeci">std::vector&lt; Eigen::ArrayXd &gt; get_phiT_quadT() const</div><div class="ttdoc">Returns values of cell basis functions at cell quadrature rules in cell. </div><div class="ttdef"><b>Definition:</b> elementquad.hpp:97</div></div>
<div class="ttc" id="classHArDCore2D_1_1Edge_html"><div class="ttname"><a href="classHArDCore2D_1_1Edge.html">HArDCore2D::Edge</a></div><div class="ttdoc">The Edge class provides description of an edge. </div><div class="ttdef"><b>Definition:</b> edge.hpp:31</div></div>
<div class="ttc" id="classHArDCore2D_1_1HybridCore_html_aa5c203c11a661933930a33335b0e2479"><div class="ttname"><a href="classHArDCore2D_1_1HybridCore.html#aa5c203c11a661933930a33335b0e2479">HArDCore2D::HybridCore::gram_matrix</a></div><div class="ttdeci">Eigen::MatrixXd gram_matrix(const std::vector&lt; Eigen::ArrayXd &gt; &amp;f_quad, const std::vector&lt; Eigen::ArrayXd &gt; &amp;g_quad, const size_t &amp;nrows, const size_t &amp;ncols, const QuadratureRule &amp;quad, const bool &amp;sym, std::vector&lt; double &gt; L2weight={}) const</div><div class="ttdef"><b>Definition:</b> hybridcore.cpp:397</div></div>
<div class="ttc" id="classHArDCore2D_1_1HybridCore_html_a6b4feaeef7739a2e30fcf6c601fcf721"><div class="ttname"><a href="classHArDCore2D_1_1HybridCore.html#a6b4feaeef7739a2e30fcf6c601fcf721">HArDCore2D::HybridCore::edge_basis</a></div><div class="ttdeci">const edge_basis_type &amp; edge_basis(size_t iF, size_t i) const</div><div class="ttdoc">Return a reference to the i&amp;#39;th basis function of the edge iF. </div><div class="ttdef"><b>Definition:</b> hybridcore.cpp:113</div></div>
<div class="ttc" id="classHArDCore2D_1_1HybridCore_html_a34242db07cc2b3c3b867d9e4580b634d"><div class="ttname"><a href="classHArDCore2D_1_1HybridCore.html#a34242db07cc2b3c3b867d9e4580b634d">HArDCore2D::HybridCore::cell_basis</a></div><div class="ttdeci">const cell_basis_type &amp; cell_basis(size_t iT, size_t i) const</div><div class="ttdoc">Return a reference to the i&amp;#39;th basis function of the cell iT. </div><div class="ttdef"><b>Definition:</b> hybridcore.cpp:107</div></div>
<div class="ttc" id="group__HybridCore_html_gae8e43d7a9a64a009690c4890534e6549"><div class="ttname"><a href="group__HybridCore.html#gae8e43d7a9a64a009690c4890534e6549">HArDCore2D::ElementQuad::get_dphiT_quadT</a></div><div class="ttdeci">std::vector&lt; Eigen::ArrayXXd &gt; get_dphiT_quadT() const</div><div class="ttdoc">Returns values of gradients of cell basis functions at cell quadrature rules in cell. </div><div class="ttdef"><b>Definition:</b> elementquad.hpp:98</div></div>
<div class="ttc" id="group__HybridCore_html_ga2c8a70eb42762e460ad31e4d43afb0e8"><div class="ttname"><a href="group__HybridCore.html#ga2c8a70eb42762e460ad31e4d43afb0e8">HArDCore2D::ElementQuad::get_phiF_quadF</a></div><div class="ttdeci">std::vector&lt; Eigen::ArrayXd &gt; get_phiF_quadF(size_t ilF) const</div><div class="ttdoc">Returns values of edges basis functions at cell quadrature rules on edge with local number ilF...</div><div class="ttdef"><b>Definition:</b> elementquad.hpp:101</div></div>
<div class="ttc" id="group__HHO__Diffusion_html_ga1aebf22f19de92c115aed69ba394de88"><div class="ttname"><a href="group__HHO__Diffusion.html#ga1aebf22f19de92c115aed69ba394de88">HArDCore2D::HHO_Diffusion::solve</a></div><div class="ttdeci">Eigen::VectorXd solve(HybridCore &amp;hho)</div><div class="ttdoc">Assemble and solve the scheme. </div><div class="ttdef"><b>Definition:</b> HHO_Diffusion.hpp:128</div></div>
<div class="ttc" id="group__HybridCore_html_ga71c953efc96f467cb24faa1b60ee9bb2"><div class="ttname"><a href="group__HybridCore.html#ga71c953efc96f467cb24faa1b60ee9bb2">HArDCore2D::HybridCore::interpolate</a></div><div class="ttdeci">Eigen::VectorXd interpolate(const Function &amp;f, size_t doe) const</div><div class="ttdoc">Compute the interpolant in the discrete space of a continuous function. </div><div class="ttdef"><b>Definition:</b> hybridcore.hpp:368</div></div>
<div class="ttc" id="classHArDCore2D_1_1Cell_html"><div class="ttname"><a href="classHArDCore2D_1_1Cell.html">HArDCore2D::Cell</a></div><div class="ttdoc">The Cell class provides description of a cell. </div><div class="ttdef"><b>Definition:</b> cell.hpp:31</div></div>
<div class="ttc" id="group__HHO__Diffusion_html_ga1f21d17ee818df40d6c0081300c44982"><div class="ttname"><a href="group__HHO__Diffusion.html#ga1f21d17ee818df40d6c0081300c44982">HArDCore2D::HHO_Diffusion::EnergyNorm</a></div><div class="ttdeci">double EnergyNorm(HybridCore &amp;hho, const Eigen::VectorXd Xh)</div><div class="ttdoc">Discrete energy norm (associated to the diffusion operator) of an hybrid function. </div><div class="ttdef"><b>Definition:</b> HHO_Diffusion.hpp:609</div></div>
<div class="ttc" id="classHArDCore2D_1_1HybridCore_html_acf453b4f239a76fe7f21b02ac91e127c"><div class="ttname"><a href="classHArDCore2D_1_1HybridCore.html#acf453b4f239a76fe7f21b02ac91e127c">HArDCore2D::HybridCore::basis_quad</a></div><div class="ttdeci">const std::vector&lt; Eigen::ArrayXd &gt; basis_quad(const std::string celledge, const size_t iTF, const QuadratureRule quad, const size_t degree, const std::string type_basis=&quot;basis&quot;) const</div><div class="ttdoc">Computes (cell or edge) basis functions at the given quadrature nodes. </div><div class="ttdef"><b>Definition:</b> hybridcore.cpp:467</div></div>
<div class="ttc" id="group__HybridCore_html_ga86e6a3566cf506821606c8802a5f2364"><div class="ttname"><a href="group__HybridCore.html#ga86e6a3566cf506821606c8802a5f2364">HArDCore2D::HybridCore::ntotal_cell_dofs</a></div><div class="ttdeci">size_t ntotal_cell_dofs() const</div><div class="ttdoc">total number of cell degrees of freedom </div><div class="ttdef"><b>Definition:</b> hybridcore.hpp:452</div></div>
<div class="ttc" id="group__HybridCore_html_ga64ffbc44306e06018efe3cea5a62f652"><div class="ttname"><a href="group__HybridCore.html#ga64ffbc44306e06018efe3cea5a62f652">HArDCore2D::HybridCore::integrate_over_cell</a></div><div class="ttdeci">double integrate_over_cell(const size_t iT, const Function &amp;f) const</div><div class="ttdoc">Integrates a function over a cell. Use with parcimony, expensive (re-compute quadratures) ...</div><div class="ttdef"><b>Definition:</b> hybridcore.hpp:334</div></div>
<div class="ttc" id="classHArDCore2D_1_1HybridCore_html_a06825c5d156026d465a2798389aa952b"><div class="ttname"><a href="classHArDCore2D_1_1HybridCore.html#a06825c5d156026d465a2798389aa952b">HArDCore2D::HybridCore::compute_weights</a></div><div class="ttdeci">Eigen::VectorXd compute_weights(size_t iT) const</div><div class="ttdoc">Weights to compute cell unknowns from edge unknowns when l=-1. </div><div class="ttdef"><b>Definition:</b> hybridcore.cpp:555</div></div>
<div class="ttc" id="group__Mesh_html_ga1b0586610a05e1a7a64bbe11f59e9b19"><div class="ttname"><a href="group__Mesh.html#ga1b0586610a05e1a7a64bbe11f59e9b19">HArDCore2D::Cell::n_edges</a></div><div class="ttdeci">size_t n_edges() const</div><div class="ttdoc">returns number of edges of the cell </div><div class="ttdef"><b>Definition:</b> cell.hpp:104</div></div>
<div class="ttc" id="classHArDCore2D_1_1HHO__Diffusion_html_acc4abb92b452d6407d45a87823fb47f9"><div class="ttname"><a href="classHArDCore2D_1_1HHO__Diffusion.html#acc4abb92b452d6407d45a87823fb47f9">HArDCore2D::HHO_Diffusion::tensor_function_type</a></div><div class="ttdeci">std::function&lt; Eigen::Matrix2d(double, double, Cell *)&gt; tensor_function_type</div><div class="ttdoc">type for diffusion tensor </div><div class="ttdef"><b>Definition:</b> HHO_Diffusion.hpp:70</div></div>
<div class="ttc" id="group__HHO__Diffusion_html_ga43051dfce03a9f75c33903f1736f4e1a"><div class="ttname"><a href="group__HHO__Diffusion.html#ga43051dfce03a9f75c33903f1736f4e1a">HArDCore2D::HHO_Diffusion::get_itime</a></div><div class="ttdeci">double get_itime(size_t idx) const</div><div class="ttdoc">various intermediate assembly times </div><div class="ttdef"><b>Definition:</b> HHO_Diffusion.hpp:632</div></div>
<div class="ttc" id="classHArDCore2D_1_1HHO__Diffusion_html"><div class="ttname"><a href="classHArDCore2D_1_1HHO__Diffusion.html">HArDCore2D::HHO_Diffusion</a></div><div class="ttdoc">The HHO_Diffusion class provides tools to implement the HHO method for the diffusion problem...</div><div class="ttdef"><b>Definition:</b> HHO_Diffusion.hpp:63</div></div>
<div class="ttc" id="classHArDCore2D_1_1HybridCore_html"><div class="ttname"><a href="classHArDCore2D_1_1HybridCore.html">HArDCore2D::HybridCore</a></div><div class="ttdef"><b>Definition:</b> hybridcore.hpp:65</div></div>
<div class="ttc" id="group__HybridCore_html_gaa90e88daa7803576aaeb9edc3574e935"><div class="ttname"><a href="group__HybridCore.html#gaa90e88daa7803576aaeb9edc3574e935">HArDCore2D::ElementQuad::get_quadF</a></div><div class="ttdeci">QuadratureRule get_quadF(size_t ilF) const</div><div class="ttdoc">Returns quadrature rules on edge with local number ilF. </div><div class="ttdef"><b>Definition:</b> elementquad.hpp:99</div></div>
<div class="ttc" id="group__HybridCore_html_gac0af0b8fa9bea07b9cfba8cbb1b50bed"><div class="ttname"><a href="group__HybridCore.html#gac0af0b8fa9bea07b9cfba8cbb1b50bed">HArDCore2D::HybridCore::ntotal_edge_dofs</a></div><div class="ttdeci">size_t ntotal_edge_dofs() const</div><div class="ttdoc">total number of edge degrees of freedom </div><div class="ttdef"><b>Definition:</b> hybridcore.hpp:454</div></div>
<div class="ttc" id="classHArDCore2D_1_1HHO__Diffusion_html_ac2ddc18a37be70e4767a9040fb6a09f6"><div class="ttname"><a href="classHArDCore2D_1_1HHO__Diffusion.html#ac2ddc18a37be70e4767a9040fb6a09f6">HArDCore2D::HHO_Diffusion::solution_function_type</a></div><div class="ttdeci">std::function&lt; double(double, double)&gt; solution_function_type</div><div class="ttdoc">type for solution </div><div class="ttdef"><b>Definition:</b> HHO_Diffusion.hpp:67</div></div>
<div class="ttc" id="group__Mesh_html_ga41ebc04d2b292197a02a9afd25a76a18"><div class="ttname"><a href="group__Mesh.html#ga41ebc04d2b292197a02a9afd25a76a18">HArDCore2D::Edge::center_mass</a></div><div class="ttdeci">Vector2d center_mass() const</div><div class="ttdoc">get the midpoint of the edge </div><div class="ttdef"><b>Definition:</b> edge.hpp:86</div></div>
<div class="ttc" id="group__Mesh_html_ga710ded03b7741c8377e0b2dda2395b46"><div class="ttname"><a href="group__Mesh.html#ga710ded03b7741c8377e0b2dda2395b46">HArDCore2D::Cell::is_boundary</a></div><div class="ttdeci">bool is_boundary() const</div><div class="ttdoc">returns true if cell touches the boundary </div><div class="ttdef"><b>Definition:</b> cell.hpp:100</div></div>
<div class="ttc" id="classHArDCore2D_1_1ElementQuad_html"><div class="ttname"><a href="classHArDCore2D_1_1ElementQuad.html">HArDCore2D::ElementQuad</a></div><div class="ttdef"><b>Definition:</b> elementquad.hpp:49</div></div>
<div class="ttc" id="group__HybridCore_html_gadaf859b98dea34338c9e6376e975b131"><div class="ttname"><a href="group__HybridCore.html#gadaf859b98dea34338c9e6376e975b131">HArDCore2D::HybridCore::K</a></div><div class="ttdeci">size_t K() const</div><div class="ttdoc">polynomial degree of edge unknowns </div><div class="ttdef"><b>Definition:</b> hybridcore.hpp:463</div></div>
<div class="ttc" id="group__HybridCore_html_gaf887b486ad0eea60382e306f1487b44a"><div class="ttname"><a href="group__HybridCore.html#gaf887b486ad0eea60382e306f1487b44a">HArDCore2D::HybridCore::ntotal_dofs</a></div><div class="ttdeci">size_t ntotal_dofs() const</div><div class="ttdoc">Total number of degrees of freedom. </div><div class="ttdef"><b>Definition:</b> hybridcore.hpp:460</div></div>
<div class="ttc" id="classHArDCore2D_1_1HHO__Diffusion_html_a14797a72cc96ee5ea6fc45e4986d6a84"><div class="ttname"><a href="classHArDCore2D_1_1HHO__Diffusion.html#a14797a72cc96ee5ea6fc45e4986d6a84">HArDCore2D::HHO_Diffusion::grad_function_type</a></div><div class="ttdeci">std::function&lt; Eigen::Vector2d(double, double, Cell *)&gt; grad_function_type</div><div class="ttdoc">type for gradient </div><div class="ttdef"><b>Definition:</b> HHO_Diffusion.hpp:69</div></div>
<div class="ttc" id="namespaceHArDCore2D_html"><div class="ttname"><a href="namespaceHArDCore2D.html">HArDCore2D</a></div><div class="ttdef"><b>Definition:</b> HHO_Diffusion.hpp:51</div></div>
<div class="ttc" id="group__Mesh_html_ga10424f4b99793ab359b5dd099f9255ee"><div class="ttname"><a href="group__Mesh.html#ga10424f4b99793ab359b5dd099f9255ee">HArDCore2D::Edge::is_boundary</a></div><div class="ttdeci">bool is_boundary() const</div><div class="ttdoc">getter to see if edge is boundary edge </div><div class="ttdef"><b>Definition:</b> edge.hpp:84</div></div>
<div class="ttc" id="group__HybridCore_html_gab3337e9e6d16154e080e247b3fa43d72"><div class="ttname"><a href="group__HybridCore.html#gab3337e9e6d16154e080e247b3fa43d72">HArDCore2D::HybridCore::get_mesh_ptr</a></div><div class="ttdeci">const Mesh * get_mesh_ptr() const</div><div class="ttdoc">returns a pointer to the mesh </div><div class="ttdef"><b>Definition:</b> hybridcore.hpp:462</div></div>
<div class="ttc" id="group__HybridCore_html_gab698480a3a9e9339d5c191549b817501"><div class="ttname"><a href="group__HybridCore.html#gab698480a3a9e9339d5c191549b817501">HArDCore2D::HybridCore::nlocal_cell_dofs</a></div><div class="ttdeci">size_t nlocal_cell_dofs() const</div><div class="ttdoc">number of degrees of freedom in each cell (dimension of polynomial space) </div><div class="ttdef"><b>Definition:</b> hybridcore.hpp:451</div></div>
<div class="ttc" id="group__HybridCore_html_ga11e133360ae70b9aef714054b7de76a4"><div class="ttname"><a href="group__HybridCore.html#ga11e133360ae70b9aef714054b7de76a4">HArDCore2D::ElementQuad::get_dphiT_quadF</a></div><div class="ttdeci">std::vector&lt; Eigen::ArrayXXd &gt; get_dphiT_quadF(size_t ilF) const</div><div class="ttdoc">Returns values of gradients of cell basis functions at cell quadrature rules on edge with local numbe...</div><div class="ttdef"><b>Definition:</b> elementquad.hpp:102</div></div>
<div class="ttc" id="group__Mesh_html_gac19ec98507a18d255bd54b1e55b16653"><div class="ttname"><a href="group__Mesh.html#gac19ec98507a18d255bd54b1e55b16653">HArDCore2D::Cell::measure</a></div><div class="ttdeci">double measure() const</div><div class="ttdoc">returns area of cell </div><div class="ttdef"><b>Definition:</b> cell.hpp:102</div></div>
<div class="ttc" id="group__HybridCore_html_gaaa9fe846646c9e26f699364ac29631f6"><div class="ttname"><a href="group__HybridCore.html#gaaa9fe846646c9e26f699364ac29631f6">HArDCore2D::HybridCore::Ldeg</a></div><div class="ttdeci">int Ldeg() const</div><div class="ttdoc">usually equal to L, but put at 0 if L=-1 </div><div class="ttdef"><b>Definition:</b> hybridcore.hpp:465</div></div>
<div class="ttc" id="structHArDCore2D_1_1QuadratureNode_html"><div class="ttname"><a href="structHArDCore2D_1_1QuadratureNode.html">HArDCore2D::QuadratureNode</a></div><div class="ttdoc">Description of one node and one weight from a quadrature rule. </div><div class="ttdef"><b>Definition:</b> quadraturerule.hpp:39</div></div>
<div class="ttc" id="group__HybridCore_html_ga57c23358c4ca7e485e8382c6b2761ad5"><div class="ttname"><a href="group__HybridCore.html#ga57c23358c4ca7e485e8382c6b2761ad5">HArDCore2D::HybridCore::nhighorder_dofs</a></div><div class="ttdeci">size_t nhighorder_dofs() const</div><div class="ttdoc">total number of cell degrees of freedom with polynomials up to order k+1 </div><div class="ttdef"><b>Definition:</b> hybridcore.hpp:455</div></div>
<div class="ttc" id="classHArDCore2D_1_1HHO__Diffusion_html_ade095df766ff04bf09385a163136e5c0"><div class="ttname"><a href="classHArDCore2D_1_1HHO__Diffusion.html#ade095df766ff04bf09385a163136e5c0">HArDCore2D::HHO_Diffusion::source_function_type</a></div><div class="ttdeci">std::function&lt; double(double, double, Cell *)&gt; source_function_type</div><div class="ttdoc">type for source </div><div class="ttdef"><b>Definition:</b> HHO_Diffusion.hpp:68</div></div>
<div class="ttc" id="classHArDCore2D_1_1Cell_html_af55d7a602439110ebbb3c9aee1895580"><div class="ttname"><a href="classHArDCore2D_1_1Cell.html#af55d7a602439110ebbb3c9aee1895580">HArDCore2D::Cell::edge_normal</a></div><div class="ttdeci">Vector2d edge_normal(size_t i)</div><div class="ttdoc">returns the outer normal to the i-th edge </div><div class="ttdef"><b>Definition:</b> cell.cpp:82</div></div>
<div class="ttc" id="group__HybridCore_html_ga89dc78ee0eea49e4a9725ed7df748ba9"><div class="ttname"><a href="group__HybridCore.html#ga89dc78ee0eea49e4a9725ed7df748ba9">HArDCore2D::ElementQuad::get_phiT_quadF</a></div><div class="ttdeci">std::vector&lt; Eigen::ArrayXd &gt; get_phiT_quadF(size_t ilF) const</div><div class="ttdoc">Returns values of cell basis functions at cell quadrature rules on edge with local number ilF...</div><div class="ttdef"><b>Definition:</b> elementquad.hpp:100</div></div>
<div class="ttc" id="group__HHO__Diffusion_html_ga0ba01c42bc116f962b6982b27e95b471"><div class="ttname"><a href="group__HHO__Diffusion.html#ga0ba01c42bc116f962b6982b27e95b471">HArDCore2D::HHO_Diffusion::get_solving_time</a></div><div class="ttdeci">double get_solving_time() const</div><div class="ttdoc">cpu time to solve the scheme </div><div class="ttdef"><b>Definition:</b> HHO_Diffusion.hpp:628</div></div>
<div class="ttc" id="classHArDCore2D_1_1Cell_html_a85defed1382a8af8227e89f00434603e"><div class="ttname"><a href="classHArDCore2D_1_1Cell.html#a85defed1382a8af8227e89f00434603e">HArDCore2D::Cell::edge</a></div><div class="ttdeci">Edge * edge(size_t iL) const</div><div class="ttdoc">returns the iL-th edge of the cell </div><div class="ttdef"><b>Definition:</b> cell.cpp:58</div></div>
<div class="ttc" id="group__HybridCore_html_ga4e7b0325c0966ec722fe8808048fb3ab"><div class="ttname"><a href="group__HybridCore.html#ga4e7b0325c0966ec722fe8808048fb3ab">HArDCore2D::HybridCore::nboundary_edge_dofs</a></div><div class="ttdeci">size_t nboundary_edge_dofs() const</div><div class="ttdoc">total number of edge degrees of freedom for boundary edges </div><div class="ttdef"><b>Definition:</b> hybridcore.hpp:459</div></div>
<div class="ttc" id="group__HybridCore_html_ga41f1294e34e4daade19ad16981eaac15"><div class="ttname"><a href="group__HybridCore.html#ga41f1294e34e4daade19ad16981eaac15">HArDCore2D::HybridCore::nlocal_edge_dofs</a></div><div class="ttdeci">size_t nlocal_edge_dofs() const</div><div class="ttdoc">number of degrees of freedom on each edge (dimension of polynomial space) </div><div class="ttdef"><b>Definition:</b> hybridcore.hpp:453</div></div>
<div class="ttc" id="group__Quadratures_html_gaccff0bc4833f415d2160633e2d93ccc3"><div class="ttname"><a href="group__Quadratures.html#gaccff0bc4833f415d2160633e2d93ccc3">HArDCore2D::generate_quadrature_rule</a></div><div class="ttdeci">QuadratureRule generate_quadrature_rule(const Cell &amp;T, const size_t doe, const bool force_split)</div><div class="ttdoc">Generate quadrature rule on mesh element. </div><div class="ttdef"><b>Definition:</b> quadraturerule.cpp:10</div></div>
<div class="ttc" id="group__HybridCore_html_ga95c76303ee1dabc5c78f0bdd7a2c6aaa"><div class="ttname"><a href="group__HybridCore.html#ga95c76303ee1dabc5c78f0bdd7a2c6aaa">HArDCore2D::HybridCore::ninternal_edge_dofs</a></div><div class="ttdeci">size_t ninternal_edge_dofs() const</div><div class="ttdoc">total number of edge degrees of freedom for internal edges </div><div class="ttdef"><b>Definition:</b> hybridcore.hpp:458</div></div>
<div class="ttc" id="group__HHO__Diffusion_html_ga9ab2e2cdf0c77f60069f7572c587c4f1"><div class="ttname"><a href="group__HHO__Diffusion.html#ga9ab2e2cdf0c77f60069f7572c587c4f1">HArDCore2D::HHO_Diffusion::HHO_Diffusion</a></div><div class="ttdeci">HHO_Diffusion(tensor_function_type kappa, source_function_type source, size_t BC, solution_function_type exact_solution, grad_function_type grad_exact_solution, std::string solver_type)</div><div class="ttdoc">Constructor of the class. </div><div class="ttdef"><b>Definition:</b> HHO_Diffusion.hpp:118</div></div>
</div><!-- fragment --></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
