<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HArD::Core2D: Schemes/HHO-locvardiff/HHO_LocVarDiff.hpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HArD::Core2D
   </div>
   <div id="projectbrief">Hybrid Arbitrary Degree::Core 2D - Library to implement 2D schemes with edge and cell polynomials as unknowns</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_60d99d4f8bf576094f0ece8cd9292bc3.html">Schemes</a></li><li class="navelem"><a class="el" href="dir_47c9014e8939c045f8da58d62cfd936a.html">HHO-locvardiff</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">HHO_LocVarDiff.hpp</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment">// Implementation of the HHO scheme in 2D for the diffusion equation</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="comment">//   { -div(K \grad(u)) = f,       inside Omega</span></div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="comment">//   { K \grad(u) . nTF = g,       on GammaN</span></div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="comment">//   {                 u = g,       on GammaD</span></div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="comment">// </span></div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="comment">//  At the moment, only pure Neumann or pure Dirichlet</span></div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="comment">// Author: Jerome Droniou (jerome.droniou@monash.edu)</span></div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160; </div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="comment">/*</span></div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;<span class="comment"> *</span></div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;<span class="comment"> *  This implementation of HHO was developped following the principles described in </span></div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;<span class="comment"> * Appendix B of the book</span></div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;<span class="comment"> *</span></div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<span class="comment"> * The Hybrid High-Order Method for Polytopal Meshes: Design, Analysis, and Applications. </span></div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;<span class="comment"> *  D. A. Di Pietro and J. Droniou. Modeling, Simulation and Applications, vol. 19. </span></div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="comment"> *  Springer International Publishing, 2020, xxxi + 525p. doi: 10.1007/978-3-030-37203-3. </span></div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;<span class="comment"> *  url: https://hal.archives-ouvertes.fr/hal-02151813.</span></div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;<span class="comment"> *</span></div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<span class="comment"> * If you use this code or part of it for a scientific publication, please cite the book</span></div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;<span class="comment"> * above as a reference for the implementation.</span></div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;<span class="comment"> *</span></div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;<span class="comment"> */</span></div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160; </div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;<span class="preprocessor">#ifndef _HHO_LOCVARDIFF_HPP</span></div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;<span class="preprocessor">#define _HHO_LOCVARDIFF_HPP</span></div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160; </div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;<span class="preprocessor">#include &lt;functional&gt;</span></div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;<span class="preprocessor">#include &lt;utility&gt;</span></div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;<span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160; </div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;<span class="preprocessor">#include &lt;boost/timer/timer.hpp&gt;</span></div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160; </div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;<span class="comment">// Matrices and linear solvers</span></div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;<span class="preprocessor">#include &lt;Eigen/Sparse&gt;</span></div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;<span class="preprocessor">#include &lt;Eigen/Dense&gt;</span></div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;<span class="comment">//#include &quot;Eigen/MA41.cpp&quot;</span></div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160; </div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;<span class="preprocessor">#include &lt;vertex.hpp&gt;</span></div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;<span class="preprocessor">#include &lt;hybridcore.hpp&gt;</span></div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;<span class="preprocessor">#include &lt;elementquad.hpp&gt;</span></div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;<span class="preprocessor">#include &lt;parallel_for.hpp&gt;</span></div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;<span class="preprocessor">#include &lt;BoundaryConditions/BoundaryConditions.hpp&gt;</span></div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;<span class="preprocessor">#include &quot;TestCase/TestCase.hpp&quot;</span></div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160; </div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;<span class="keyword">namespace </span>HArDCore2D {</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160; </div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;  <span class="comment">// ----------------------------------------------------------------------------</span></div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;  <span class="comment">//                            Class definition</span></div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;  <span class="comment">// ----------------------------------------------------------------------------</span></div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160; </div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160; </div>
<div class="line"><a name="l00065"></a><span class="lineno"><a class="line" href="classHArDCore2D_1_1HHO__LocVarDiff.html">   65</a></span>&#160;  <span class="keyword">class </span><a class="code" href="classHArDCore2D_1_1HHO__LocVarDiff.html">HHO_LocVarDiff</a> {</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160; </div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;  <span class="keyword">public</span>:</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160; </div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    <a class="code" href="group__HHO__LocVarDiff.html#ga426d431a09113a934bc5dfc574a329fe">HHO_LocVarDiff</a>(</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;       <a class="code" href="classHArDCore2D_1_1HybridCore.html">HybridCore</a>&amp; hho,        </div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;       <span class="keywordtype">size_t</span> K,              </div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;       <span class="keywordtype">int</span> L,                 </div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;       CellFType&lt;MatrixRd&gt; kappa,   </div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;       <span class="keywordtype">size_t</span> deg_kappa,              </div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;       CellFType&lt;double&gt; source,  </div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;       <a class="code" href="classBoundaryConditions.html">BoundaryConditions</a> BC,                     </div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;       <a class="code" href="group__Basis.html#gab1e36fbf129c707351e533ee43579432">FType&lt;double&gt;</a> exact_solution,   </div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;       CellFType&lt;VectorRd&gt; grad_exact_solution,   </div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;       std::string solver_type,    </div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;       <span class="keywordtype">bool</span> use_threads,    </div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;       std::ostream &amp; output = std::cout    </div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;       );</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160; </div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    <span class="keywordtype">void</span> <a class="code" href="group__HHO__LocVarDiff.html#ga5a556b259e62cf0474e2f933da569b15">assemble</a>(<a class="code" href="classHArDCore2D_1_1HybridCore.html">HybridCore</a>&amp; hho);</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;    <a class="code" href="classHArDCore2D_1_1UVector.html">UVector</a> solve(<a class="code" href="classHArDCore2D_1_1HybridCore.html">HybridCore</a>&amp; hho);</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160; </div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;    <span class="keywordtype">double</span> <a class="code" href="group__HHO__LocVarDiff.html#ga11896824f2d3a743fd7caabeb396f158">EnergyNorm</a>(<a class="code" href="classHArDCore2D_1_1HybridCore.html">HybridCore</a>&amp; hho, <span class="keyword">const</span> <a class="code" href="classHArDCore2D_1_1UVector.html">UVector</a> Xh); </div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160; </div>
<div class="line"><a name="l00093"></a><span class="lineno"><a class="line" href="group__HHO__LocVarDiff.html#gafef8cb4110ec3b95f3c83090fe26d598">   93</a></span>&#160;    Eigen::SparseMatrix&lt;double&gt; <a class="code" href="group__HHO__LocVarDiff.html#gafef8cb4110ec3b95f3c83090fe26d598">get_SysMat</a>(){</div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;      <span class="keywordflow">return</span> SysMat;</div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;    }</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160; </div>
<div class="line"><a name="l00098"></a><span class="lineno"><a class="line" href="group__HHO__LocVarDiff.html#ga9c37d2cf2744465d0bf50ff02fe185f9">   98</a></span>&#160;    <span class="keyword">inline</span> <span class="keywordtype">double</span> <a class="code" href="group__HHO__LocVarDiff.html#ga9c37d2cf2744465d0bf50ff02fe185f9">get_assembly_time</a>()<span class="keyword"> const</span></div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;<span class="keyword">      </span>{</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;        <span class="keywordflow">return</span> double(_assembly_time) * pow(10, -9);</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;      }; </div>
<div class="line"><a name="l00103"></a><span class="lineno"><a class="line" href="group__HHO__LocVarDiff.html#gad184ecd99c5da4172395a210d0289c12">  103</a></span>&#160;    <span class="keyword">inline</span> <span class="keywordtype">double</span> <a class="code" href="group__HHO__LocVarDiff.html#gad184ecd99c5da4172395a210d0289c12">get_solving_time</a>()<span class="keyword"> const</span></div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;<span class="keyword">      </span>{</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;        <span class="keywordflow">return</span> double(_solving_time) * pow(10, -9);</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;      };  </div>
<div class="line"><a name="l00108"></a><span class="lineno"><a class="line" href="group__HHO__LocVarDiff.html#ga9648b003ca1d519794bcc5407c8ce606">  108</a></span>&#160;    <span class="keyword">inline</span> <span class="keywordtype">double</span> <a class="code" href="group__HHO__LocVarDiff.html#ga9648b003ca1d519794bcc5407c8ce606">get_solving_error</a>()<span class="keyword"> const</span></div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;<span class="keyword">      </span>{</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;        <span class="keywordflow">return</span> _solving_error;</div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;      };</div>
<div class="line"><a name="l00113"></a><span class="lineno"><a class="line" href="group__HHO__LocVarDiff.html#ga61e65ce589db4203515ae8e1f5c30d0f">  113</a></span>&#160;    <span class="keyword">inline</span> <span class="keywordtype">double</span> <a class="code" href="group__HHO__LocVarDiff.html#ga61e65ce589db4203515ae8e1f5c30d0f">get_itime</a>(<span class="keywordtype">size_t</span> idx)<span class="keyword"> const      </span></div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;<span class="keyword">      </span>{</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;        <span class="keywordflow">return</span> double(_itime[idx]) * pow(10, -9);</div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;      };   </div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160; </div>
<div class="line"><a name="l00119"></a><span class="lineno"><a class="line" href="group__HHO__LocVarDiff.html#ga4f40caa5b5d827f078f32fdfa888ed4e">  119</a></span>&#160;    <span class="keyword">const</span> <span class="keyword">inline</span> <span class="keywordtype">size_t</span> <a class="code" href="group__HHO__LocVarDiff.html#ga4f40caa5b5d827f078f32fdfa888ed4e">get_nlocal_cell_dofs</a>() { <span class="keywordflow">return</span> m_nlocal_cell_dofs; }</div>
<div class="line"><a name="l00121"></a><span class="lineno"><a class="line" href="group__HHO__LocVarDiff.html#gab6713bb636cc108b62d04e0c87a4fdf8">  121</a></span>&#160;    <span class="keyword">const</span> <span class="keyword">inline</span> <span class="keywordtype">size_t</span> <a class="code" href="group__HHO__LocVarDiff.html#gab6713bb636cc108b62d04e0c87a4fdf8">get_nlocal_edge_dofs</a>() { <span class="keywordflow">return</span> m_nlocal_edge_dofs; }</div>
<div class="line"><a name="l00123"></a><span class="lineno"><a class="line" href="group__HHO__LocVarDiff.html#ga1f76dc1a9a6c0b6ccfac42b33073480c">  123</a></span>&#160;    <span class="keyword">const</span> <span class="keyword">inline</span> <span class="keywordtype">size_t</span> <a class="code" href="group__HHO__LocVarDiff.html#ga1f76dc1a9a6c0b6ccfac42b33073480c">get_nhighorder_dofs</a>() { <span class="keywordflow">return</span> m_nhighorder_dofs; }</div>
<div class="line"><a name="l00125"></a><span class="lineno"><a class="line" href="group__HHO__LocVarDiff.html#gabbda77d7148aac2bf61c43ec766add33">  125</a></span>&#160;    <span class="keyword">const</span> <span class="keyword">inline</span> <span class="keywordtype">size_t</span> <a class="code" href="group__HHO__LocVarDiff.html#gabbda77d7148aac2bf61c43ec766add33">get_ntotal_cell_dofs</a>() { <span class="keywordflow">return</span> m_ntotal_cell_dofs; }</div>
<div class="line"><a name="l00127"></a><span class="lineno"><a class="line" href="group__HHO__LocVarDiff.html#gad02a8f10049abe8b2c740a60e903f8d0">  127</a></span>&#160;    <span class="keyword">const</span> <span class="keyword">inline</span> <span class="keywordtype">size_t</span> <a class="code" href="group__HHO__LocVarDiff.html#gad02a8f10049abe8b2c740a60e903f8d0">get_ntotal_edge_dofs</a>() { <span class="keywordflow">return</span> m_ntotal_edge_dofs; }</div>
<div class="line"><a name="l00129"></a><span class="lineno"><a class="line" href="group__HHO__LocVarDiff.html#gaecb29f27e40c73300e20075e8f9f5d3b">  129</a></span>&#160;    <span class="keyword">const</span> <span class="keyword">inline</span> <span class="keywordtype">size_t</span> <a class="code" href="group__HHO__LocVarDiff.html#gaecb29f27e40c73300e20075e8f9f5d3b">get_ndir_edge_dofs</a>() { <span class="keywordflow">return</span> m_ndir_edge_dofs; }</div>
<div class="line"><a name="l00131"></a><span class="lineno"><a class="line" href="group__HHO__LocVarDiff.html#ga3c58f6557feeea1edc9db4290a95bf4e">  131</a></span>&#160;    <span class="keyword">const</span> <span class="keyword">inline</span> <span class="keywordtype">size_t</span> <a class="code" href="group__HHO__LocVarDiff.html#ga3c58f6557feeea1edc9db4290a95bf4e">get_ntotal_dofs</a>() { <span class="keywordflow">return</span> m_ntotal_dofs; }</div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160; </div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;  <span class="keyword">private</span>:</div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;    Eigen::MatrixXd diffusion_operator(<a class="code" href="classHArDCore2D_1_1HybridCore.html">HybridCore</a>&amp; hho, <span class="keyword">const</span> <span class="keywordtype">size_t</span> iT, <span class="keyword">const</span> <a class="code" href="classHArDCore2D_1_1ElementQuad.html">ElementQuad</a>&amp; elquad) <span class="keyword">const</span>;</div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160; </div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;    Eigen::VectorXd load_operator(<a class="code" href="classHArDCore2D_1_1HybridCore.html">HybridCore</a>&amp; hho, <span class="keyword">const</span> <span class="keywordtype">size_t</span> iT, <span class="keyword">const</span> <a class="code" href="classHArDCore2D_1_1ElementQuad.html">ElementQuad</a> &amp;elquad) <span class="keyword">const</span>;</div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160; </div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;    <span class="comment">// Reference to the HybridCore structure</span></div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;    <a class="code" href="classHArDCore2D_1_1HybridCore.html">HybridCore</a>&amp; m_hho;</div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160; </div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;    <span class="comment">// Degrees on edges and in cells</span></div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;    <span class="keywordtype">size_t</span> m_K;</div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;    <span class="keywordtype">int</span> m_L;</div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;    <span class="keywordtype">size_t</span> m_Ldeg;</div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160; </div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;    <span class="comment">// Data</span></div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;    <span class="keyword">const</span> CellFType&lt;MatrixRd&gt; kappa;</div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;    <span class="keywordtype">size_t</span> _deg_kappa;</div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;    <span class="keyword">const</span> CellFType&lt;double&gt; source;</div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;    <span class="keyword">const</span> <a class="code" href="classBoundaryConditions.html">BoundaryConditions</a> m_BC;</div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;    <span class="keyword">const</span> <a class="code" href="group__Basis.html#gab1e36fbf129c707351e533ee43579432">FType&lt;double&gt;</a> exact_solution;</div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;    <span class="keyword">const</span> CellFType&lt;VectorRd&gt; grad_exact_solution;</div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;    <span class="keyword">const</span> std::string solver_type;</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">bool</span> m_use_threads;</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;    std::ostream &amp; m_output;</div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160; </div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;    <span class="comment">// DOFs</span></div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">size_t</span> m_nlocal_cell_dofs;</div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">size_t</span> m_nlocal_edge_dofs;</div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">size_t</span> m_nhighorder_dofs;</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">size_t</span> m_ntotal_cell_dofs;</div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">size_t</span> m_ntotal_edge_dofs;</div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">size_t</span> m_ndir_edge_dofs;</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">size_t</span> m_nnondir_edge_dofs;</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">size_t</span> m_ntotal_dofs;</div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160; </div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;    <span class="comment">// Local bilinear forms</span></div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;    std::vector&lt;Eigen::MatrixXd&gt; aT;</div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;    <span class="comment">// Global matrix (without BC accounted for), and system matrix</span></div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;    Eigen::SparseMatrix&lt;double&gt; GlobMat;</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;    Eigen::SparseMatrix&lt;double&gt; SysMat;</div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;    <span class="comment">// If static condensation (L&gt;=0): matrix to recover cell unknowns</span></div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;    <span class="comment">// If barycentric elimination (L=-1): matrix to recover cell unknowns</span></div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;    Eigen::SparseMatrix&lt;double&gt; ScBeMat;</div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;    <span class="comment">// Source terms for the system, and for recovering cell unknowns from static condensation</span></div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;    Eigen::VectorXd GlobRHS;</div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;    Eigen::VectorXd ScRHS;</div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160; </div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;    <span class="comment">// Computation statistics</span></div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;    <span class="keywordtype">size_t</span> _assembly_time;</div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;    <span class="keywordtype">size_t</span> _solving_time;</div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;    <span class="keywordtype">double</span> _solving_error;</div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;    <span class="keyword">mutable</span> std::vector&lt;size_t&gt; _itime = std::vector&lt;size_t&gt;(10, 0);</div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160; </div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;  };</div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160; </div>
<div class="line"><a name="l00189"></a><span class="lineno"><a class="line" href="group__HHO__LocVarDiff.html#ga426d431a09113a934bc5dfc574a329fe">  189</a></span>&#160;  <a class="code" href="group__HHO__LocVarDiff.html#ga426d431a09113a934bc5dfc574a329fe">HHO_LocVarDiff::HHO_LocVarDiff</a>(<a class="code" href="classHArDCore2D_1_1HybridCore.html">HybridCore</a>&amp; hho, <span class="keywordtype">size_t</span> K, <span class="keywordtype">int</span> L, CellFType&lt;MatrixRd&gt; kappa, <span class="keywordtype">size_t</span> deg_kappa, CellFType&lt;double&gt; source, <a class="code" href="classBoundaryConditions.html">BoundaryConditions</a> BC, <a class="code" href="group__Basis.html#gab1e36fbf129c707351e533ee43579432">FType&lt;double&gt;</a> exact_solution, CellFType&lt;VectorRd&gt; grad_exact_solution, std::string solver_type, <span class="keywordtype">bool</span> use_threads, std::ostream &amp; output)</div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;    : m_hho(hho),</div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;      m_K(K),</div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;      m_L(L),</div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;      m_Ldeg(std::max(L,0)),</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;      kappa(kappa),</div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;      _deg_kappa(deg_kappa),</div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;      source(source),</div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;      m_BC(BC),</div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;      exact_solution(exact_solution),</div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;      grad_exact_solution(grad_exact_solution),</div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;      solver_type(solver_type),</div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;      m_use_threads(use_threads),</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;      m_output(output),</div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;      m_nlocal_cell_dofs(DimPoly&lt;<a class="code" href="classHArDCore2D_1_1Cell.html">Cell</a>&gt;(m_Ldeg)),</div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;      m_nlocal_edge_dofs(DimPoly&lt;<a class="code" href="classHArDCore2D_1_1Edge.html">Edge</a>&gt;(m_K)),</div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;      m_nhighorder_dofs(DimPoly&lt;<a class="code" href="classHArDCore2D_1_1Cell.html">Cell</a>&gt;(m_K+1)),</div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;      m_ntotal_cell_dofs(m_nlocal_cell_dofs * m_hho.get_mesh()-&gt;n_cells()),</div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;      m_ntotal_edge_dofs(m_nlocal_edge_dofs * m_hho.get_mesh()-&gt;n_edges()),</div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;      m_ndir_edge_dofs(m_nlocal_edge_dofs * m_BC.n_dir_edges()),</div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;      m_nnondir_edge_dofs(m_nlocal_edge_dofs * m_hho.get_mesh()-&gt;n_edges() - m_ndir_edge_dofs),</div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;      m_ntotal_dofs(m_ntotal_cell_dofs + m_ntotal_edge_dofs),</div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;      GlobRHS(Eigen::VectorXd::Zero(m_ntotal_edge_dofs)),</div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;      ScRHS(Eigen::VectorXd::Zero(m_ntotal_cell_dofs))</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160; {</div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;      m_output &lt;&lt; <span class="stringliteral">&quot;[HHO_LocVarDiff] Initializing&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;      GlobMat.resize(m_ntotal_edge_dofs, m_ntotal_edge_dofs);        </div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;      ScBeMat.resize(m_ntotal_cell_dofs, m_ntotal_edge_dofs);</div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;    <span class="comment">// Do nothing</span></div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;  }</div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160; </div>
<div class="line"><a name="l00220"></a><span class="lineno"><a class="line" href="group__HHO__LocVarDiff.html#ga5a556b259e62cf0474e2f933da569b15">  220</a></span>&#160;  <span class="keywordtype">void</span> <a class="code" href="group__HHO__LocVarDiff.html#ga5a556b259e62cf0474e2f933da569b15">HHO_LocVarDiff::assemble</a>(<a class="code" href="classHArDCore2D_1_1HybridCore.html">HybridCore</a> &amp;hho) {</div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160; </div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;    boost::timer::cpu_timer timer;  <span class="comment">// Time the matrix assembly</span></div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;    timer.start();</div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;    <span class="keyword">const</span> <a class="code" href="classHArDCore2D_1_1Mesh.html">Mesh</a>* mesh = hho.<a class="code" href="group__HybridCore.html#ga8e87aec0e4162f6307eef0c04216a6cd">get_mesh</a>();</div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160; </div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;    <span class="comment">//--------------- PREPARE SYSTEM ------------------------//</span></div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160; </div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;    <span class="comment">// Global triplets for: system matrix, static condensaion/barycentric elimination</span></div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;    std::vector&lt;Eigen::Triplet&lt;double&gt;&gt; triplets_GlobMat;</div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;    std::vector&lt;Eigen::Triplet&lt;double&gt;&gt; triplets_ScBe;</div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160; </div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;    <span class="comment">// Local bilinear form, triplets and source term (one per cell)</span></div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;    aT.resize(mesh-&gt;<a class="code" href="group__Mesh.html#ga2202a0715196c41356692d8adcfe3893">n_cells</a>());</div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;    std::vector&lt;std::vector&lt;Eigen::Triplet&lt;double&gt;&gt;&gt; cell_triplets_GlobMat;</div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;    std::vector&lt;std::vector&lt;Eigen::Triplet&lt;double&gt;&gt;&gt; cell_triplets_ScBe;</div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;    std::vector&lt;Eigen::VectorXd&gt; cell_source(mesh-&gt;<a class="code" href="group__Mesh.html#ga2202a0715196c41356692d8adcfe3893">n_cells</a>());</div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;    cell_triplets_GlobMat.resize(mesh-&gt;<a class="code" href="group__Mesh.html#ga2202a0715196c41356692d8adcfe3893">n_cells</a>());</div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;    cell_triplets_ScBe.resize(mesh-&gt;<a class="code" href="group__Mesh.html#ga2202a0715196c41356692d8adcfe3893">n_cells</a>());</div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;    <span class="keywordtype">size_t</span> size_triplets_GlobMat = 0;</div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;    <span class="keywordtype">size_t</span> size_triplets_ScBe = 0;</div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160; </div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;    <span class="comment">//-------------- ASSEMBLE LOCAL CONTRIBUTIONS -------------//</span></div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;    </div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;    <span class="comment">// Function to create local contribution between cell start and cell end-1</span></div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;    std::function&lt;void(<span class="keywordtype">size_t</span>, <span class="keywordtype">size_t</span>)&gt; construct_all_local_contributions</div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;      = [&amp;](<span class="keywordtype">size_t</span> start, <span class="keywordtype">size_t</span> end)-&gt;<span class="keywordtype">void</span></div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;      {</div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> iT = start; iT &lt; end; iT++) {</div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;          <a class="code" href="classHArDCore2D_1_1Cell.html">Cell</a>* iCell = mesh-&gt;<a class="code" href="group__Mesh.html#gae07b938c57cf57e3bb9c76d3df1eb549">cell</a>(iT);</div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160; </div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;          <span class="comment">// Total number of edge degrees of freedom local to this cell (adjacent edges to the cell)</span></div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;          <span class="keywordtype">size_t</span> nlocal_edges = iCell-&gt;<a class="code" href="group__Mesh.html#ga1b0586610a05e1a7a64bbe11f59e9b19">n_edges</a>();</div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;          <span class="keywordtype">size_t</span> edge_dofs = nlocal_edges * m_nlocal_edge_dofs;</div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160; </div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;          <span class="comment">// Local bilinear form and source term</span></div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;          <span class="keywordtype">size_t</span> doeT = std::max( std::max(m_K,m_Ldeg) + m_K+1 , 2*m_K + _deg_kappa );</div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;          <span class="keywordtype">size_t</span> doeF = 2*m_K + 1;</div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;          <a class="code" href="classHArDCore2D_1_1ElementQuad.html">ElementQuad</a> elquad(hho, iT, doeT, doeF);</div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160; </div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;          aT[iT] = diffusion_operator(hho, iT, elquad);</div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;          Eigen::VectorXd bT = load_operator(hho, iT, elquad);</div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160; </div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;          <span class="comment">// Local matrix and right-hand side on the edge unknowns</span></div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;          Eigen::MatrixXd MatF = Eigen::MatrixXd::Zero(edge_dofs,edge_dofs);</div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;          cell_source[iT] = Eigen::VectorXd::Zero(edge_dofs);</div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160; </div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;          <span class="keywordflow">if</span> (m_L&gt;=0) {</div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;            <span class="comment">// STATIC CONDENSATION OF ELEMENT UNKNOWNS</span></div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160; </div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;            <span class="comment">// Perform static condensation</span></div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;            Eigen::MatrixXd ATT = aT[iT].topLeftCorner(m_nlocal_cell_dofs, m_nlocal_cell_dofs);</div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;            Eigen::MatrixXd ATF = aT[iT].topRightCorner(m_nlocal_cell_dofs, edge_dofs);</div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;            Eigen::MatrixXd AFF = aT[iT].bottomRightCorner(edge_dofs, edge_dofs);</div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160; </div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;            Eigen::PartialPivLU&lt;Eigen::MatrixXd&gt; invATT;</div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;            invATT.compute(ATT);</div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;                </div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;            Eigen::MatrixXd invATT_ATF = invATT.solve(ATF);</div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;            Eigen::VectorXd invATT_bTcell = invATT.solve(bT.head(m_nlocal_cell_dofs));</div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;            MatF = AFF - ATF.transpose() * invATT_ATF;</div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;                </div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;            cell_source[iT] = bT.tail(edge_dofs) - ATF.transpose() * invATT_bTcell;</div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;                      </div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;            <span class="comment">// Assemble local triplets for static condensation operator</span></div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;            ScRHS.segment(iT * m_nlocal_cell_dofs, m_nlocal_cell_dofs) = invATT_bTcell;</div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; m_nlocal_cell_dofs; i++) {</div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;              <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> jlF = 0; jlF &lt; nlocal_edges; jlF++) {</div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;                <span class="keyword">const</span> <span class="keywordtype">size_t</span> jF = iCell-&gt;<a class="code" href="group__Mesh.html#ga85defed1382a8af8227e89f00434603e">edge</a>(jlF)-&gt;<a class="code" href="group__Mesh.html#ga774e975ebad5e6bdccf549215293d624">global_index</a>();</div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;                <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> jk = 0; jk &lt; m_nlocal_edge_dofs; jk++) {</div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;                  <span class="keyword">const</span> <span class="keywordtype">size_t</span> jLocal = jlF * m_nlocal_edge_dofs + jk;</div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;                  <span class="keyword">const</span> <span class="keywordtype">size_t</span> jGlobal = jF * m_nlocal_edge_dofs + jk;</div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;                  cell_triplets_ScBe[iT].emplace_back(iT * m_nlocal_cell_dofs + i, jGlobal, invATT_ATF(i, jLocal));</div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;                }</div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;              }</div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;            }</div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;            size_triplets_ScBe += cell_triplets_ScBe[iT].size();</div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160; </div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;          } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;            <span class="comment">// BARYCENTRIC ELIMINATION OF ELEMENT UNKNOWNS</span></div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;            <span class="comment">// Create reduction matrix: 1+nlocal_edges * nlocal_edges matrix with the coefficients on the first row, and the identity below. When multiplied by the edge unknowns, return cell and edge unknowns</span></div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;            <span class="comment">// Note that the basis functions are constant, but not necessarily assumed to be one (which is not the case after orthonormalisation for example), which is why we have to adjust the first row.</span></div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;            Eigen::MatrixXd red_matT = Eigen::MatrixXd::Zero(1+nlocal_edges,nlocal_edges);</div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;            red_matT.row(0) = hho.<a class="code" href="group__HybridCore.html#ga06825c5d156026d465a2798389aa952b">compute_weights</a>(iT);</div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;            VectorRd xT = iCell-&gt;<a class="code" href="group__Mesh.html#ga66b278b12266d5c5bfee8699886cc89b">center_mass</a>();</div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;            <span class="keywordtype">double</span> phiT_cst = hho.<a class="code" href="group__HybridCore.html#gafb3e4d056b781b2fff5e46466d47e0f3">CellBasis</a>(iT).<a class="code" href="group__Basis.html#ga15a1f56b9bb54f849ebaf4a66f75907d">function</a>(0, xT);</div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> ilF = 0; ilF &lt; nlocal_edges; ilF++){</div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;              VectorRd xF = iCell-&gt;<a class="code" href="group__Mesh.html#ga85defed1382a8af8227e89f00434603e">edge</a>(ilF)-&gt;<a class="code" href="group__Mesh.html#ga41ebc04d2b292197a02a9afd25a76a18">center_mass</a>();</div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;              <span class="keywordtype">size_t</span> iF = iCell-&gt;<a class="code" href="group__Mesh.html#ga85defed1382a8af8227e89f00434603e">edge</a>(ilF)-&gt;<a class="code" href="group__Mesh.html#ga774e975ebad5e6bdccf549215293d624">global_index</a>();</div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;              <span class="keywordtype">double</span> phiF_cst = hho.<a class="code" href="group__HybridCore.html#ga9394b577ae67c9aa2289095bfedc38e2">EdgeBasis</a>(iF).<a class="code" href="group__Basis.html#ga15a1f56b9bb54f849ebaf4a66f75907d">function</a>(0, xF);</div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;              red_matT(0,ilF) *= phiF_cst / phiT_cst;</div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;            }</div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;            red_matT.bottomRightCorner(nlocal_edges,nlocal_edges) = Eigen::MatrixXd::Identity(nlocal_edges,nlocal_edges);</div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160; </div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;            cell_source[iT] = red_matT.transpose() * bT;</div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;            MatF = red_matT.transpose() * aT[iT] * red_matT;</div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160; </div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;            <span class="comment">// Assemble local triplets for barycentric combination to recover cell unknown</span></div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> jlF = 0; jlF &lt; nlocal_edges; jlF++) {</div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;              <span class="keyword">const</span> <span class="keywordtype">size_t</span> jF = iCell-&gt;<a class="code" href="group__Mesh.html#ga85defed1382a8af8227e89f00434603e">edge</a>(jlF)-&gt;<a class="code" href="group__Mesh.html#ga774e975ebad5e6bdccf549215293d624">global_index</a>();</div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;              <span class="keyword">const</span> <span class="keywordtype">size_t</span> jGlobal = jF * m_nlocal_edge_dofs;</div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;              cell_triplets_ScBe[iT].emplace_back(iT, jGlobal, red_matT(0,jlF));</div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;            }</div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;            size_triplets_ScBe += cell_triplets_ScBe[iT].size();</div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160; </div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;          }</div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160; </div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;          <span class="comment">// Assemble local triplets for scheme&#39;s matrix and source term</span></div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;          <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> ilF = 0; ilF &lt; nlocal_edges; ilF++) {</div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;            <span class="keyword">const</span> <span class="keywordtype">size_t</span> iF = iCell-&gt;<a class="code" href="group__Mesh.html#ga85defed1382a8af8227e89f00434603e">edge</a>(ilF)-&gt;<a class="code" href="group__Mesh.html#ga774e975ebad5e6bdccf549215293d624">global_index</a>();</div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> ik = 0; ik &lt; m_nlocal_edge_dofs; ik++) {</div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;              <span class="keyword">const</span> <span class="keywordtype">size_t</span> iLocal = ilF * m_nlocal_edge_dofs + ik;</div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;              <span class="keyword">const</span> <span class="keywordtype">size_t</span> iGlobal = iF * m_nlocal_edge_dofs + ik;</div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;              <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> jlF = 0; jlF &lt; nlocal_edges; jlF++) {</div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;                <span class="keyword">const</span> <span class="keywordtype">size_t</span> jF = iCell-&gt;<a class="code" href="group__Mesh.html#ga85defed1382a8af8227e89f00434603e">edge</a>(jlF)-&gt;<a class="code" href="group__Mesh.html#ga774e975ebad5e6bdccf549215293d624">global_index</a>();</div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;                <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> jk = 0; jk &lt; m_nlocal_edge_dofs; jk++) {</div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;                  <span class="keyword">const</span> <span class="keywordtype">size_t</span> jLocal = jlF * m_nlocal_edge_dofs + jk;</div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;                  <span class="keyword">const</span> <span class="keywordtype">size_t</span> jGlobal = jF * m_nlocal_edge_dofs + jk;</div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;                  cell_triplets_GlobMat[iT].emplace_back(iGlobal, jGlobal, MatF(iLocal, jLocal));</div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;                }</div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;              }</div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;            }</div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;          }</div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;          size_triplets_GlobMat += cell_triplets_GlobMat[iT].size();</div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;      </div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;        }</div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;    };    <span class="comment">// End function to construct local contributions</span></div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160; </div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;    <span class="comment">// Running the local constructions in parallel</span></div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;    parallel_for(mesh-&gt;<a class="code" href="group__Mesh.html#ga2202a0715196c41356692d8adcfe3893">n_cells</a>(), construct_all_local_contributions, m_use_threads);</div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160; </div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;    <span class="comment">// Assemble local contribution into global matrix</span></div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;    triplets_ScBe.reserve(size_triplets_ScBe);</div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;    triplets_GlobMat.reserve(size_triplets_GlobMat);</div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> iT = 0; iT &lt; mesh-&gt;<a class="code" href="group__Mesh.html#ga2202a0715196c41356692d8adcfe3893">n_cells</a>(); iT++){</div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; cell_triplets_ScBe[iT].size(); i++){</div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;        triplets_ScBe.push_back(cell_triplets_ScBe[iT][i]);</div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;      }</div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; cell_triplets_GlobMat[iT].size(); i++){</div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;        triplets_GlobMat.push_back(cell_triplets_GlobMat[iT][i]);</div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;      }</div>
<div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;      <a class="code" href="classHArDCore2D_1_1Cell.html">Cell</a>&amp; T = *mesh-&gt;<a class="code" href="group__Mesh.html#gae07b938c57cf57e3bb9c76d3df1eb549">cell</a>(iT);      </div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> ilF = 0; ilF &lt; T.n_edges(); ilF++) {</div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;        <span class="keyword">const</span> <span class="keywordtype">size_t</span> iF = T.edge(ilF)-&gt;global_index();</div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> ik = 0; ik &lt; m_nlocal_edge_dofs; ik++) {</div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;          <span class="keyword">const</span> <span class="keywordtype">size_t</span> iLocal = ilF * m_nlocal_edge_dofs + ik;</div>
<div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;          <span class="keyword">const</span> <span class="keywordtype">size_t</span> iGlobal = iF * m_nlocal_edge_dofs + ik;</div>
<div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;          GlobRHS(iGlobal) += cell_source[iT](iLocal);</div>
<div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;        }</div>
<div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;      }</div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;    }</div>
<div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160; </div>
<div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;    <span class="keywordflow">if</span> (m_BC.<a class="code" href="group__BoundaryConditions.html#gac3609733d5e7e43e9240d0a8b05d17ba">name</a>()==<span class="stringliteral">&quot;Neumann&quot;</span>){</div>
<div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;      <span class="comment">// Neumann BC: remove a row in the matrix and fix the first degree of freedom</span></div>
<div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;      triplets_GlobMat.erase(std::remove_if(std::begin(triplets_GlobMat), std::end(triplets_GlobMat),</div>
<div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;              [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; x) { <span class="keywordflow">return</span> (x.row() == 0); }), std::end(triplets_GlobMat));</div>
<div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;      triplets_GlobMat.emplace_back(0, 0, 1);</div>
<div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;      GlobRHS(0) = 0;</div>
<div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;    }</div>
<div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160; </div>
<div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;    <span class="comment">// Assemble the global linear system (without BC), and matrix to recover statically-condensed cell dofs</span></div>
<div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;    GlobMat.setFromTriplets(std::begin(triplets_GlobMat), std::end(triplets_GlobMat));</div>
<div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;    ScBeMat.setFromTriplets(std::begin(triplets_ScBe), std::end(triplets_ScBe));</div>
<div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160; </div>
<div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;    <span class="comment">// Record assembly time </span></div>
<div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;  <span class="comment">//    _assembly_time = timer.elapsed().user + timer.elapsed().system;</span></div>
<div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;    _assembly_time = timer.elapsed().wall;</div>
<div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160; </div>
<div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;  }</div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160; </div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;  <a class="code" href="classHArDCore2D_1_1UVector.html">UVector</a> HHO_LocVarDiff::solve(<a class="code" href="classHArDCore2D_1_1HybridCore.html">HybridCore</a>&amp; hho) {</div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;    <span class="keyword">const</span> <a class="code" href="classHArDCore2D_1_1Mesh.html">Mesh</a>* mesh = hho.<a class="code" href="group__HybridCore.html#ga8e87aec0e4162f6307eef0c04216a6cd">get_mesh</a>();</div>
<div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;    boost::timer::cpu_timer timer;  <span class="comment">// Time the matrix assembly</span></div>
<div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;    timer.start();</div>
<div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160; </div>
<div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;    <span class="comment">//-------------- TREATMENT OF BOUNDARY CONDITIONS -------------//</span></div>
<div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160; </div>
<div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;    <span class="comment">// If Dirichlet, the final system is only posed on the interior edge unknowns and we have to subtract from the source</span></div>
<div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;    <span class="comment">//    term the contribution of the boundary values</span></div>
<div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;    <span class="comment">// If Neumann, the final system is posed on all edge unknowns</span></div>
<div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160; </div>
<div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;    <span class="keywordtype">size_t</span> n_unknowns = 0;</div>
<div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;    <span class="keywordtype">size_t</span> n_fixed_dofs = 0;</div>
<div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;    Eigen::VectorXd B;</div>
<div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;    Eigen::VectorXd UDir;</div>
<div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160; </div>
<div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;    <span class="keywordflow">if</span> (m_BC.<a class="code" href="group__BoundaryConditions.html#gac3609733d5e7e43e9240d0a8b05d17ba">name</a>() != <span class="stringliteral">&quot;Neumann&quot;</span>){</div>
<div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;      <span class="comment">// Dirichlet boundary conditions</span></div>
<div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;      n_unknowns = m_nnondir_edge_dofs;</div>
<div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;      n_fixed_dofs = m_ndir_edge_dofs;</div>
<div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;      SysMat = GlobMat.topLeftCorner(n_unknowns, n_unknowns);</div>
<div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;    </div>
<div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;      <span class="comment">// Boundary value: UDir corresponds to the L2 projection of the exact solution on the polynomial spaces on the Dirichlet edges (last BC.n_dir_edges() edges)</span></div>
<div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;      UDir = Eigen::VectorXd::Zero(n_fixed_dofs);</div>
<div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;      <span class="keywordtype">size_t</span> n_dir_edges = m_BC.<a class="code" href="group__BoundaryConditions.html#gad3c69b47183027c427ff6404875da645">n_dir_edges</a>();</div>
<div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;      <span class="keywordtype">size_t</span> n_nondir_edges = mesh-&gt;<a class="code" href="group__Mesh.html#ga55a1cd5db98bbce8c73ab86b4527859c">n_edges</a>() - n_dir_edges; </div>
<div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> idF = 0; idF &lt; n_dir_edges; idF++){</div>
<div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;        <a class="code" href="classHArDCore2D_1_1Edge.html">Edge</a>* edge = mesh-&gt;<a class="code" href="group__Mesh.html#gacad7cdf3d2c00fa6fc23ff77c63c7d1a">edge</a>(n_nondir_edges + idF);</div>
<div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;        <span class="keywordtype">size_t</span> iF = edge-&gt;<a class="code" href="group__Mesh.html#ga774e975ebad5e6bdccf549215293d624">global_index</a>();</div>
<div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;        QuadratureRule quadF = <a class="code" href="group__Quadratures.html#gad8f643134b5bea1e323e14c5ac42aa74">generate_quadrature_rule</a>(*edge, 2*m_K+2);</div>
<div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;        boost::multi_array&lt;double, 2&gt; phiF_quadF = <a class="code" href="group__Basis.html#ga687c3c9504c4b10c5a18654530980086">evaluate_quad&lt;Function&gt;::compute</a>(hho.<a class="code" href="group__HybridCore.html#ga9394b577ae67c9aa2289095bfedc38e2">EdgeBasis</a>(iF), quadF);</div>
<div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;        UDir.segment(idF * m_nlocal_edge_dofs, m_nlocal_edge_dofs) = l2_projection&lt;HybridCore::PolyEdgeBasisType&gt;(exact_solution, hho.<a class="code" href="group__HybridCore.html#ga9394b577ae67c9aa2289095bfedc38e2">EdgeBasis</a>(iF), quadF, phiF_quadF);</div>
<div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;      }</div>
<div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160; </div>
<div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;      B = GlobRHS.segment(0, n_unknowns) - GlobMat.topRightCorner(n_unknowns, n_fixed_dofs) * UDir;</div>
<div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160; </div>
<div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;    } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;      <span class="comment">// We will solve the complete system</span></div>
<div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;      n_unknowns = m_ntotal_edge_dofs;</div>
<div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;      SysMat = GlobMat;</div>
<div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;      B = GlobRHS;</div>
<div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;      UDir = Eigen::VectorXd::Zero(n_fixed_dofs);</div>
<div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;    }</div>
<div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160; </div>
<div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;    <span class="comment">//-------------- SOLVE CONDENSED SYSTEM -------------//</span></div>
<div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160; </div>
<div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;    Eigen::VectorXd xF = Eigen::VectorXd::Zero(n_unknowns);</div>
<div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160; </div>
<div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;    <span class="comment">//  if (solver_type == &quot;ma41&quot;) {</span></div>
<div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;    <span class="comment">//    Eigen::MA41&lt;Eigen::SparseMatrix&lt;double&gt;, Eigen::VectorXd&gt; solver;</span></div>
<div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;    <span class="comment">//    solver.analyzePattern(SysMat);</span></div>
<div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;    <span class="comment">//    solver.factorize(SysMat);</span></div>
<div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;    <span class="comment">//    xF = solver.solve(B);</span></div>
<div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;    <span class="comment">//  } else {</span></div>
<div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;    Eigen::BiCGSTAB&lt;Eigen::SparseMatrix&lt;double&gt; &gt; solver;</div>
<div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;    solver.compute(SysMat);</div>
<div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;    xF = solver.solve(B);</div>
<div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;    std::cout &lt;&lt; <span class="stringliteral">&quot;  [solver] #iterations: &quot;</span> &lt;&lt; solver.iterations() &lt;&lt; <span class="stringliteral">&quot;, estimated error: &quot;</span> &lt;&lt; solver.error() &lt;&lt; std::endl;</div>
<div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;    <span class="comment">//  }</span></div>
<div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;    _solving_error = (SysMat * xF - B).norm();</div>
<div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;    <span class="comment">// Recover the fixed boundary values, cell unknowns (from static condensation/barycentric elimination)</span></div>
<div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;    Eigen::VectorXd Xh = Eigen::VectorXd::Zero(m_ntotal_dofs);</div>
<div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;    Xh.tail(n_fixed_dofs) = UDir;</div>
<div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;    Xh.segment(m_ntotal_cell_dofs, n_unknowns) = xF;</div>
<div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;    <span class="keywordflow">if</span> (m_L&gt;=0) {</div>
<div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;      Xh.head(m_ntotal_cell_dofs) = ScRHS - ScBeMat * Xh.tail(m_ntotal_edge_dofs);</div>
<div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;    } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;      Xh.head(m_ntotal_cell_dofs) = ScBeMat * Xh.tail(m_ntotal_edge_dofs);</div>
<div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;    }</div>
<div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160; </div>
<div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;    <span class="comment">// Only Neumann: translate to get the proper average</span></div>
<div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;    <span class="keywordflow">if</span> (m_BC.<a class="code" href="group__BoundaryConditions.html#gac3609733d5e7e43e9240d0a8b05d17ba">name</a>()==<span class="stringliteral">&quot;Neumann&quot;</span>){</div>
<div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;      <span class="comment">// Compute average to translate</span></div>
<div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;      <span class="keywordtype">double</span> average = 0.;</div>
<div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;      <span class="keywordtype">double</span> total_measure = 0;</div>
<div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> iT = 0; iT &lt; mesh-&gt;<a class="code" href="group__Mesh.html#ga2202a0715196c41356692d8adcfe3893">n_cells</a>(); iT++){</div>
<div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;        <a class="code" href="classHArDCore2D_1_1Cell.html">Cell</a>&amp; T = *mesh-&gt;<a class="code" href="group__Mesh.html#gae07b938c57cf57e3bb9c76d3df1eb549">cell</a>(iT);</div>
<div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;        total_measure += T.measure();</div>
<div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;        <a class="code" href="classHArDCore2D_1_1Family.html">HybridCore::PolyCellBasisType</a> basisT = hho.<a class="code" href="group__HybridCore.html#gafb3e4d056b781b2fff5e46466d47e0f3">CellBasis</a>(iT);</div>
<div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;        QuadratureRule quadT = <a class="code" href="group__Quadratures.html#gad8f643134b5bea1e323e14c5ac42aa74">generate_quadrature_rule</a>(T, 2*m_K);</div>
<div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;        boost::multi_array&lt;double, 2&gt; phiT_quadT = <a class="code" href="group__Basis.html#ga687c3c9504c4b10c5a18654530980086">evaluate_quad&lt;Function&gt;::compute</a>(basisT, quadT);</div>
<div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; basisT.<a class="code" href="group__Basis.html#ga385bf99cf8c3888a150ed53f410ae39f">dimension</a>(); i++){</div>
<div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;          <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> iqn = 0; iqn &lt; quadT.size(); iqn++){</div>
<div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;            average += quadT[iqn].w * Xh(iT * m_nlocal_cell_dofs + i) * basisT.<a class="code" href="group__Basis.html#ga15a1f56b9bb54f849ebaf4a66f75907d">function</a>(i, quadT[iqn].vector());</div>
<div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;          }</div>
<div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;        }</div>
<div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;      }</div>
<div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;      <span class="keywordtype">double</span> average_exact_sol = 0.0;</div>
<div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;      <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; T : mesh-&gt;<a class="code" href="group__Mesh.html#gabae9df200fe23a302b3d01e4ff13f921">get_cells</a>()){</div>
<div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;        QuadratureRule quadT = <a class="code" href="group__Quadratures.html#gad8f643134b5bea1e323e14c5ac42aa74">generate_quadrature_rule</a>(*T, 2 * m_Ldeg + 2);</div>
<div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;        <span class="keywordflow">for</span> (<a class="code" href="structHArDCore2D_1_1QuadratureNode.html">QuadratureNode</a>&amp; qT : quadT){</div>
<div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;          average_exact_sol += qT.w * exact_solution(qT.vector());</div>
<div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;        }</div>
<div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;      }</div>
<div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;      average_exact_sol /= total_measure;</div>
<div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160; </div>
<div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;      <span class="comment">// Translate the cells and edges</span></div>
<div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;      <span class="comment">// We compute the interpolant of the constant function &quot;average_exact_sol - average&quot; </span></div>
<div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;      <span class="comment">// and we translate Xh by that amount</span></div>
<div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;      std::function&lt;double(VectorRd)&gt; AveDiff = [&amp;average_exact_sol,&amp;average](VectorRd x)-&gt;<span class="keywordtype">double</span></div>
<div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;  { <span class="keywordflow">return</span> average_exact_sol - average;};</div>
<div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160; </div>
<div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;      <a class="code" href="classHArDCore2D_1_1UVector.html">UVector</a> Cst = hho.<a class="code" href="group__HybridCore.html#ga7d6af50952aa59143ac364dd1dc4118e">interpolate</a>(AveDiff, m_L, m_K, 2*m_K+3);</div>
<div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;      Xh += Cst.<a class="code" href="group__HybridCore.html#ga38b36a187519471f6cbe4719f14c5bd1">asVectorXd</a>();</div>
<div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;    }</div>
<div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160; </div>
<div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;    _solving_time = timer.elapsed().user + timer.elapsed().system;  <span class="comment">// Record the final solving time</span></div>
<div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160; </div>
<div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="classHArDCore2D_1_1UVector.html">UVector</a>(Xh, *hho.<a class="code" href="group__HybridCore.html#ga8e87aec0e4162f6307eef0c04216a6cd">get_mesh</a>(), m_L, m_K);</div>
<div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;  }</div>
<div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160; </div>
<div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;  <span class="comment">//******************************** </span></div>
<div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;  <span class="comment">//    local diffusion matrix </span></div>
<div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;  <span class="comment">//********************************</span></div>
<div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160; </div>
<div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;  Eigen::MatrixXd HHO_LocVarDiff::diffusion_operator(<a class="code" href="classHArDCore2D_1_1HybridCore.html">HybridCore</a> &amp;hho, <span class="keyword">const</span> <span class="keywordtype">size_t</span> iT, <span class="keyword">const</span> <a class="code" href="classHArDCore2D_1_1ElementQuad.html">ElementQuad</a> &amp;elquad)<span class="keyword"> const </span></div>
<div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;<span class="keyword">  </span>{</div>
<div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160; </div>
<div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;    boost::timer::cpu_timer timeint;</div>
<div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160; </div>
<div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;    <span class="keyword">const</span> <span class="keyword">auto</span> mesh = hho.<a class="code" href="group__HybridCore.html#ga8e87aec0e4162f6307eef0c04216a6cd">get_mesh</a>();</div>
<div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">size_t</span> dimPKcell = <a class="code" href="group__HybridCore.html#ga320f4be89026a2059fe48d1286a9aebf">DimPoly&lt;Cell&gt;</a>(m_K);</div>
<div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">size_t</span> dimPKcell_vec = mesh-&gt;<a class="code" href="group__Mesh.html#gaecd909db5f3ab863010382cf6b71ec58">dim</a>() * dimPKcell;</div>
<div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;    <a class="code" href="classHArDCore2D_1_1Cell.html">Cell</a>* cell = mesh-&gt;<a class="code" href="group__Mesh.html#gae07b938c57cf57e3bb9c76d3df1eb549">cell</a>(iT);</div>
<div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">size_t</span> nedgesT = cell-&gt;<a class="code" href="group__Mesh.html#ga1b0586610a05e1a7a64bbe11f59e9b19">n_edges</a>();</div>
<div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160; </div>
<div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;    <span class="comment">// Total number of degrees of freedom local to this cell (cell and its adjacent edges)</span></div>
<div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;    <span class="keywordtype">size_t</span> local_dofs = m_nlocal_cell_dofs + nedgesT * m_nlocal_edge_dofs;</div>
<div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160; </div>
<div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;    <span class="comment">//-------------------  Initialisatons: quadratures, mass matrices... --------------------//</span></div>
<div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160; </div>
<div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;    <span class="comment">// Note: representing the gradient reconstruction GT supposes a basis for (P^k)^d. This basis can be</span></div>
<div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;    <span class="comment">//   built from the basis (phi_i)_i of P^k, by working component-by-component:</span></div>
<div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;    <span class="comment">//    (phi_1 e_1, ..., phi_N e_1, phi_1 e_2, ..., phi_N e_2, ...),</span></div>
<div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;    <span class="comment">//    where e_1=[1 0], e_2=[0 1]... is the canonical basis of R^d</span></div>
<div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;    <span class="comment">//  Hence, the first dimPKcell functions are on the first component of R^d, the next dimPKcell on the second</span></div>
<div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;    <span class="comment">//    component etc.</span></div>
<div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;    <span class="comment">//  We do not explicitly build this basis function, but we compute the values of these functions at the</span></div>
<div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;    <span class="comment">//    quadrature nodes, using the values computed for the scalar basis functions</span></div>
<div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160; </div>
<div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160; </div>
<div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;    <span class="comment">// QUADRATURES</span></div>
<div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;    <span class="comment">// Cell quadrature nodes, and values of cell basis functions (up to degree K+1) and gradients thereof.</span></div>
<div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;    QuadratureRule quadT = elquad.<a class="code" href="group__HybridCore.html#ga213822f156a19022e6bff238d438606d">get_quadT</a>();</div>
<div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;    boost::multi_array&lt;double, 2&gt; phiT_quadT = elquad.<a class="code" href="group__HybridCore.html#ga87443a1da538a16841f08e5a8c1dd8ee">get_phiT_quadT</a>();</div>
<div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;    boost::multi_array&lt;VectorRd, 2&gt; dphiT_quadT = elquad.<a class="code" href="group__HybridCore.html#ga4962e2d0b866a3016b574f24c0d15940">get_dphiT_quadT</a>();</div>
<div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160; </div>
<div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;    <span class="comment">// Vector basis functions (up to degree K) at the quadrature nodes. </span></div>
<div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;    boost::multi_array&lt;VectorRd, 2&gt; vec_phiT_quadT = elquad.<a class="code" href="group__HybridCore.html#ga3c549d43c0a5171d0c14f6b56ffc843d">get_vec_phiT_quadT</a>(m_K);</div>
<div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;    </div>
<div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;    <span class="comment">// Diffusion tensor at the quadrature nodes</span></div>
<div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;    std::vector&lt;MatrixRd&gt; kappaT_quadT(quadT.size());</div>
<div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;    std::transform(quadT.begin(), quadT.end(), kappaT_quadT.begin(),</div>
<div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;       [<span class="keyword">this</span>,&amp;cell](<a class="code" href="structHArDCore2D_1_1QuadratureNode.html">QuadratureNode</a> qr) -&gt; Eigen::MatrixXd { return kappa(qr.vector(), cell); });</div>
<div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160; </div>
<div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;    <span class="comment">// MASS MATRICES</span></div>
<div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;    <span class="comment">// Scalar cell mass matrix (phi_i,phi_j)_T up to degree max(L,K) * (K+1), and </span></div>
<div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;    <span class="comment">// Vector cell mass matrix (Phi_i,Phi_j)_T up to degree K*K [this one is block diagonal]</span></div>
<div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;    <span class="keywordtype">size_t</span> maxdimPKL = std::max(m_nlocal_cell_dofs, dimPKcell);</div>
<div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160; </div>
<div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;    _itime[0] += timeint.elapsed().user + timeint.elapsed().system;</div>
<div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;    timeint.start();</div>
<div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160; </div>
<div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;    Eigen::MatrixXd MTT = <a class="code" href="group__Basis.html#ga56ea5a2eec9e5f2534c5ea34c6f8e973">compute_gram_matrix</a>(phiT_quadT, phiT_quadT, quadT, maxdimPKL, m_nhighorder_dofs, <span class="stringliteral">&quot;sym&quot;</span>);</div>
<div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;    Eigen::MatrixXd VecMTT = Eigen::MatrixXd::Zero(dimPKcell_vec, dimPKcell_vec);</div>
<div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> r=0; r &lt; mesh-&gt;<a class="code" href="group__Mesh.html#gaecd909db5f3ab863010382cf6b71ec58">dim</a>(); r++){</div>
<div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;      VecMTT.block(r*dimPKcell, r*dimPKcell, dimPKcell, dimPKcell) = MTT.topLeftCorner(dimPKcell, dimPKcell);</div>
<div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;    } </div>
<div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160; </div>
<div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;    <span class="comment">// Edge mass matrices:</span></div>
<div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;    <span class="comment">// MFF[ilF]: edge-edge mass on edge with local number ilF, up to degree K*K</span></div>
<div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;    <span class="comment">// MFT[ilF]: edge-cell mass on edge with local number ilF, up to degree K*(K+1)</span></div>
<div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;    <span class="comment">// MTT_on_F[ilF]: cell-cell mass on edge with local number ilF, up to degree K*L</span></div>
<div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;    std::vector&lt;Eigen::MatrixXd&gt; MFF(nedgesT, Eigen::MatrixXd::Zero(m_nlocal_edge_dofs, m_nlocal_edge_dofs));</div>
<div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;    std::vector&lt;Eigen::MatrixXd&gt; MFT(nedgesT, Eigen::MatrixXd::Zero(m_nlocal_edge_dofs, m_nhighorder_dofs));</div>
<div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;    std::vector&lt;Eigen::MatrixXd&gt; MTT_on_F(nedgesT, Eigen::MatrixXd::Zero(dimPKcell, m_nlocal_cell_dofs));</div>
<div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160; </div>
<div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> ilF = 0; ilF &lt; nedgesT; ilF++) {</div>
<div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160; </div>
<div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;      <span class="comment">// Edge quadrature nodes and values of cell and edge basis functions (and gradients) at these nodes</span></div>
<div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;      <span class="keyword">auto</span> quadF = elquad.<a class="code" href="group__HybridCore.html#ga08c8a69abf1995ea353668beb8c5b19b">get_quadF</a>(ilF);</div>
<div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;      boost::multi_array&lt;double, 2&gt; phiT_quadF = elquad.<a class="code" href="group__HybridCore.html#gab8d725c09a9086bfe42688d0f34d1669">get_phiT_quadF</a>(ilF);</div>
<div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;      boost::multi_array&lt;double, 2&gt; phiF_quadF = elquad.<a class="code" href="group__HybridCore.html#ga0289327a67759deb2c311e75d4f6ce55">get_phiF_quadF</a>(ilF);</div>
<div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160; </div>
<div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;      <span class="comment">// Mass matrices</span></div>
<div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;      MFF[ilF] = <a class="code" href="group__Basis.html#ga56ea5a2eec9e5f2534c5ea34c6f8e973">compute_gram_matrix</a>(phiF_quadF, phiF_quadF, quadF, <span class="stringliteral">&quot;sym&quot;</span>);</div>
<div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;      MFT[ilF] = <a class="code" href="group__Basis.html#ga56ea5a2eec9e5f2534c5ea34c6f8e973">compute_gram_matrix</a>(phiF_quadF, phiT_quadF, quadF, <span class="stringliteral">&quot;nonsym&quot;</span>);</div>
<div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;      MTT_on_F[ilF] = <a class="code" href="group__Basis.html#ga56ea5a2eec9e5f2534c5ea34c6f8e973">compute_gram_matrix</a>(phiT_quadF, phiT_quadF, quadF, dimPKcell, m_nlocal_cell_dofs, <span class="stringliteral">&quot;nonsym&quot;</span>);</div>
<div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;    }</div>
<div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160; </div>
<div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;    _itime[1] += timeint.elapsed().user + timeint.elapsed().system;</div>
<div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;    timeint.start();</div>
<div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160; </div>
<div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;    <span class="comment">// STIFNESS mass-matrices (and the like): (\nabla phi_i,\nabla phi_j)_T up to degree (K+1)*(K+1)</span></div>
<div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;    <span class="comment">//  and (\nabla phi_i, Phi_j)_T up to degree (K+1)*K</span></div>
<div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;    Eigen::MatrixXd StiffT = <a class="code" href="group__Basis.html#ga56ea5a2eec9e5f2534c5ea34c6f8e973">compute_gram_matrix</a>(dphiT_quadT, dphiT_quadT, quadT, <span class="stringliteral">&quot;sym&quot;</span>);  </div>
<div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;    Eigen::MatrixXd MdphiT_PhiT = <a class="code" href="group__Basis.html#ga56ea5a2eec9e5f2534c5ea34c6f8e973">compute_gram_matrix</a>(dphiT_quadT, vec_phiT_quadT, quadT, <span class="stringliteral">&quot;nonsym&quot;</span>);</div>
<div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160; </div>
<div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;    _itime[2] += timeint.elapsed().user + timeint.elapsed().system;</div>
<div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;    timeint.start();</div>
<div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160; </div>
<div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;    <span class="comment">//-------------------- Compute GT, matrix of full gradient reconstruction ---------//</span></div>
<div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160; </div>
<div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;    <span class="comment">// Right-hand side, starting with volumetric term (Phi_i, \nabla phi_j)_T</span></div>
<div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;    Eigen::MatrixXd RHS_GT = Eigen::MatrixXd::Zero(dimPKcell_vec, local_dofs);</div>
<div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;    RHS_GT.topLeftCorner(dimPKcell_vec, m_nlocal_cell_dofs) = (MdphiT_PhiT.topLeftCorner(m_nlocal_cell_dofs, dimPKcell_vec)).transpose();</div>
<div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160; </div>
<div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;    <span class="comment">// Boundary terms</span></div>
<div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> r=0; r &lt; mesh-&gt;<a class="code" href="group__Mesh.html#gaecd909db5f3ab863010382cf6b71ec58">dim</a>(); r++){</div>
<div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> ilF = 0; ilF &lt; nedgesT; ilF++) {</div>
<div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;        <span class="comment">// Offset for edge unknowns</span></div>
<div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;        <span class="keyword">const</span> <span class="keywordtype">size_t</span> offset_F = m_nlocal_cell_dofs + ilF * m_nlocal_edge_dofs;</div>
<div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;        <span class="keyword">const</span> <span class="keyword">auto</span>&amp; nTF = cell-&gt;<a class="code" href="group__Mesh.html#gaad9bc371c5c2669b3d3948e353f714f8">edge_normal</a>(ilF);</div>
<div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160; </div>
<div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;        <span class="comment">// Contribution of cell unknowns, and then edge unknowns on F</span></div>
<div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;        RHS_GT.block(r*dimPKcell, 0, dimPKcell, m_nlocal_cell_dofs) -= nTF(r) * MTT_on_F[ilF];</div>
<div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;        RHS_GT.block(r*dimPKcell, offset_F, dimPKcell, m_nlocal_edge_dofs) += </div>
<div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;          nTF(r) * (MFT[ilF].topLeftCorner(m_nlocal_edge_dofs, dimPKcell)).transpose();</div>
<div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;      }</div>
<div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;    }</div>
<div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160; </div>
<div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;    <span class="comment">// Compute GT</span></div>
<div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;    Eigen::MatrixXd GT = (VecMTT.ldlt()).solve(RHS_GT);</div>
<div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160; </div>
<div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;    <span class="comment">//------------- Consistent contribution (K GT, GT)_T to the local bilinear form ------//</span></div>
<div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160; </div>
<div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160; </div>
<div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;    <span class="comment">//  Weighted mass matrix  (K Phi_i, Phi_j)_T of the basis (Phi_i)_i of (P^k)^d</span></div>
<div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;    <span class="comment">// We start by creating K Phi_i at the quadrature nodes</span></div>
<div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;    boost::multi_array&lt;VectorRd, 2&gt; kappa_vec_phiT_quadT;</div>
<div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;    kappa_vec_phiT_quadT.resize( boost::extents[dimPKcell_vec][quadT.size()] );</div>
<div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; dimPKcell_vec; i++){</div>
<div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> iqn = 0; iqn &lt; quadT.size(); iqn++){</div>
<div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;        kappa_vec_phiT_quadT[i][iqn] = kappaT_quadT[iqn] * vec_phiT_quadT[i][iqn];</div>
<div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;      }</div>
<div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;    }</div>
<div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;    _itime[3] += timeint.elapsed().user + timeint.elapsed().system;</div>
<div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;    timeint.start();</div>
<div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160; </div>
<div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;    Eigen::MatrixXd kappaVecMTT = <a class="code" href="group__Basis.html#ga56ea5a2eec9e5f2534c5ea34c6f8e973">compute_gram_matrix</a>(kappa_vec_phiT_quadT, vec_phiT_quadT, quadT, vec_phiT_quadT.shape()[0], vec_phiT_quadT.shape()[0], <span class="stringliteral">&quot;sym&quot;</span>);</div>
<div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160; </div>
<div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;    _itime[4] += timeint.elapsed().user + timeint.elapsed().system;</div>
<div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;    timeint.start();</div>
<div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160; </div>
<div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;    Eigen::MatrixXd ATF = GT.transpose() * kappaVecMTT * GT;</div>
<div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160; </div>
<div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160; </div>
<div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;    <span class="comment">//------------- Compute PT, matrix of potential reconstruction, using GT ------//</span></div>
<div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160; </div>
<div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;    <span class="comment">// We write that \nabla pT = projection on \nabla P^{k+1} of GT, and add the closure relation:</span></div>
<div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;    <span class="comment">// (nabla pT v, nabla w)_T + lambda_T(p_T v,1)_T(w,1)_T = (GT v,\nabla w)_T + lambda_T(v_T,1)_T(w,1)_T</span></div>
<div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160; </div>
<div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;    <span class="comment">// Right-hand side, starting with volumetric term</span></div>
<div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;    Eigen::MatrixXd RHS_PT = MdphiT_PhiT * GT;</div>
<div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160; </div>
<div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;    <span class="comment">// Vector LT of (phi_j,1)_T for phi_j up to degree K+1, and LT^t*LT, for the closure relation</span></div>
<div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;    Eigen::VectorXd LT = (MTT.row(0)).transpose();</div>
<div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;    Eigen::MatrixXd LTtLT = LT * (LT.transpose());</div>
<div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;    <span class="keywordtype">double</span> scalT = StiffT.trace() / std::pow(LT.norm(), 2);</div>
<div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160; </div>
<div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;    <span class="comment">// Add closure relation and compute PT</span></div>
<div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;    RHS_PT.topLeftCorner(m_nhighorder_dofs, m_nlocal_cell_dofs) += </div>
<div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;      scalT * LTtLT.topLeftCorner(m_nhighorder_dofs, m_nlocal_cell_dofs);</div>
<div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;    Eigen::MatrixXd PT = ((StiffT + scalT*LTtLT).ldlt()).solve(RHS_PT);</div>
<div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160; </div>
<div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160; </div>
<div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;    <span class="comment">//-------------------- Compute stabilisation term sT ---------//</span></div>
<div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160; </div>
<div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;    Eigen::MatrixXd STF = Eigen::MatrixXd::Zero(local_dofs, local_dofs);</div>
<div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160; </div>
<div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;    <span class="comment">// Cell residual delta_T^l = pi_T^l (rT uT) - u_T</span></div>
<div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160; </div>
<div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;    Eigen::MatrixXd MTT_LKp1 = MTT.topLeftCorner(m_nlocal_cell_dofs, m_nhighorder_dofs);</div>
<div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;    Eigen::MatrixXd MTT_LL = MTT.topLeftCorner(m_nlocal_cell_dofs, m_nlocal_cell_dofs);</div>
<div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;    Eigen::MatrixXd deltaTL = MTT_LL.ldlt().solve( MTT_LKp1 * PT );</div>
<div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;    deltaTL.topLeftCorner(m_nlocal_cell_dofs, m_nlocal_cell_dofs) -= Eigen::MatrixXd::Identity(m_nlocal_cell_dofs, m_nlocal_cell_dofs);</div>
<div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160; </div>
<div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> ilF = 0; ilF &lt; nedgesT; ilF++) {</div>
<div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;      <span class="comment">// Two options for stabilisation: diameter of edge, or ratio measure cell/measure edge</span></div>
<div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;     <span class="keywordtype">double</span> dTF = cell-&gt;<a class="code" href="group__Mesh.html#ga85defed1382a8af8227e89f00434603e">edge</a>(ilF)-&gt;<a class="code" href="group__Mesh.html#gad558804a7493cb6a6d968f48bb4f4742">diam</a>();</div>
<div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;    <span class="comment">//   double dTF = cell-&gt;measure() / cell-&gt;edge(ilF)-&gt;measure();</span></div>
<div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160; </div>
<div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;      VectorRd xF = cell-&gt;<a class="code" href="group__Mesh.html#ga85defed1382a8af8227e89f00434603e">edge</a>(ilF)-&gt;<a class="code" href="group__Mesh.html#ga41ebc04d2b292197a02a9afd25a76a18">center_mass</a>();</div>
<div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160; </div>
<div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;    <span class="comment">//   auto kappa_TF = kappa(xF, cell).trace();</span></div>
<div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160; </div>
<div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;      <span class="keyword">const</span> VectorRd &amp;nTF = cell-&gt;<a class="code" href="group__Mesh.html#gaad9bc371c5c2669b3d3948e353f714f8">edge_normal</a>(ilF);</div>
<div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;      <span class="keyword">const</span> <span class="keywordtype">double</span> kappa_TF = (kappa(xF, cell) * nTF).dot(nTF);</div>
<div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160; </div>
<div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;      <span class="comment">// Edge residual delta_TF^k = pi_F^k (rT uT) - u_F</span></div>
<div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;      Eigen::MatrixXd MFFinv = MFF[ilF].inverse();</div>
<div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;      Eigen::MatrixXd deltaTFK = MFFinv * MFT[ilF] * PT;</div>
<div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;      deltaTFK.block(0, m_nlocal_cell_dofs + ilF * m_nlocal_edge_dofs, m_nlocal_edge_dofs, m_nlocal_edge_dofs) -=</div>
<div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;        Eigen::MatrixXd::Identity(m_nlocal_edge_dofs, m_nlocal_edge_dofs);</div>
<div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160; </div>
<div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;      <span class="comment">// Stabilisation term: here, we actually project deltaTL on P^k(F) so, for l=k+1, it actually corresponds to the stabilisation used in HDG methods (see Section 5.1.6 of HHO book)</span></div>
<div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;      Eigen::MatrixXd deltaTFK_minus_deltaTL = deltaTFK - MFFinv * MFT[ilF].topLeftCorner(m_nlocal_edge_dofs, m_nlocal_cell_dofs) * deltaTL;</div>
<div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160; </div>
<div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;      STF += (kappa_TF / dTF) * deltaTFK_minus_deltaTL.transpose() * MFF[ilF] *  deltaTFK_minus_deltaTL;</div>
<div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;    }</div>
<div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160; </div>
<div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;    _itime[5] += timeint.elapsed().user + timeint.elapsed().system;</div>
<div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160; </div>
<div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;    <span class="comment">// Adjust local bilinear form with stabilisation term</span></div>
<div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;    ATF += mesh-&gt;<a class="code" href="group__Mesh.html#gaecd909db5f3ab863010382cf6b71ec58">dim</a>() * STF;</div>
<div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160; </div>
<div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;    <span class="keywordflow">return</span> ATF;</div>
<div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160; </div>
<div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160;  }</div>
<div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160; </div>
<div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160; </div>
<div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;  <span class="comment">//******************************** </span></div>
<div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;  <span class="comment">//    local load term </span></div>
<div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;  <span class="comment">//********************************</span></div>
<div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160; </div>
<div class="line"><a name="l00705"></a><span class="lineno">  705</span>&#160;  Eigen::VectorXd HHO_LocVarDiff::load_operator(<a class="code" href="classHArDCore2D_1_1HybridCore.html">HybridCore</a> &amp;hho, <span class="keyword">const</span> <span class="keywordtype">size_t</span> iT, <span class="keyword">const</span> <a class="code" href="classHArDCore2D_1_1ElementQuad.html">ElementQuad</a> &amp;elquad)<span class="keyword"> const </span>{</div>
<div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;    <span class="comment">// Load for the cell DOFs (first indices) and edge DOFs (last indices)</span></div>
<div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;    <span class="keyword">const</span> <span class="keyword">auto</span> mesh = hho.<a class="code" href="group__HybridCore.html#ga8e87aec0e4162f6307eef0c04216a6cd">get_mesh</a>();</div>
<div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;    <a class="code" href="classHArDCore2D_1_1Cell.html">Cell</a>* cell = mesh-&gt;<a class="code" href="group__Mesh.html#gae07b938c57cf57e3bb9c76d3df1eb549">cell</a>(iT);</div>
<div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;    <span class="keywordtype">size_t</span> cell_edge_dofs = m_nlocal_cell_dofs + cell-&gt;<a class="code" href="group__Mesh.html#ga1b0586610a05e1a7a64bbe11f59e9b19">n_edges</a>()*m_nlocal_edge_dofs;</div>
<div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;    Eigen::VectorXd b = Eigen::VectorXd::Zero(cell_edge_dofs);</div>
<div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160; </div>
<div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;    <span class="comment">// Quadrature nodes and values of cell basis functions at these nodes</span></div>
<div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160;    <span class="keyword">auto</span> quadT = elquad.<a class="code" href="group__HybridCore.html#ga213822f156a19022e6bff238d438606d">get_quadT</a>();</div>
<div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;    <span class="keywordtype">size_t</span> nbq = quadT.size();</div>
<div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;    boost::multi_array&lt;double, 2&gt; phiT_quadT = elquad.<a class="code" href="group__HybridCore.html#ga87443a1da538a16841f08e5a8c1dd8ee">get_phiT_quadT</a>();</div>
<div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160; </div>
<div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;    <span class="comment">// Value of source times quadrature weights at the quadrature nodes</span></div>
<div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;    Eigen::ArrayXd weight_source_quad = Eigen::ArrayXd::Zero(nbq);</div>
<div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> iqn = 0; iqn &lt; nbq; iqn++){</div>
<div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;      weight_source_quad(iqn) = quadT[iqn].w * source(quadT[iqn].vector(), cell);</div>
<div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;    }</div>
<div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160; </div>
<div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i &lt; m_nlocal_cell_dofs; i++){</div>
<div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> iqn = 0; iqn &lt; quadT.size(); iqn++){</div>
<div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;        b(i) += weight_source_quad[iqn] * phiT_quadT[i][iqn];</div>
<div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;      }</div>
<div class="line"><a name="l00727"></a><span class="lineno">  727</span>&#160;    }</div>
<div class="line"><a name="l00728"></a><span class="lineno">  728</span>&#160; </div>
<div class="line"><a name="l00729"></a><span class="lineno">  729</span>&#160;    <span class="comment">// Boundary values, if we have a boundary cell</span></div>
<div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;    <span class="keywordflow">if</span> (cell-&gt;<a class="code" href="group__Mesh.html#ga710ded03b7741c8377e0b2dda2395b46">is_boundary</a>()){</div>
<div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;      <span class="comment">// Boundary values only on boundary Neumann edges</span></div>
<div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> ilF = 0; ilF &lt; cell-&gt;<a class="code" href="group__Mesh.html#ga1b0586610a05e1a7a64bbe11f59e9b19">n_edges</a>(); ilF++) {</div>
<div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;        <a class="code" href="classHArDCore2D_1_1Edge.html">Edge</a>* F = cell-&gt;<a class="code" href="group__Mesh.html#ga85defed1382a8af8227e89f00434603e">edge</a>(ilF);</div>
<div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;        <span class="keywordflow">if</span> (m_BC.<a class="code" href="group__BoundaryConditions.html#gabaeb77c2484042f248639f1806fe8e72">type</a>(*F)==<span class="stringliteral">&quot;neu&quot;</span>){</div>
<div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;          <span class="keyword">const</span> <span class="keywordtype">size_t</span> iF = F-&gt;<a class="code" href="group__Mesh.html#ga774e975ebad5e6bdccf549215293d624">global_index</a>(); </div>
<div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160;          <span class="comment">// BC on boundary edges</span></div>
<div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160;          <span class="keywordflow">if</span> (F-&gt;<a class="code" href="group__Mesh.html#ga10424f4b99793ab359b5dd099f9255ee">is_boundary</a>()){</div>
<div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;            <span class="comment">// Offset for edge unknowns</span></div>
<div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;            <span class="keyword">const</span> <span class="keywordtype">size_t</span> offset_F = m_nlocal_cell_dofs + ilF * m_nlocal_edge_dofs;</div>
<div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;            <span class="comment">// Normal to the edge and bases function</span></div>
<div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;            <span class="keyword">const</span> <span class="keyword">auto</span>&amp; nTF = cell-&gt;<a class="code" href="group__Mesh.html#gaad9bc371c5c2669b3d3948e353f714f8">edge_normal</a>(ilF);</div>
<div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;            <span class="keyword">const</span> <span class="keyword">auto</span>&amp; basisF = hho.<a class="code" href="group__HybridCore.html#ga9394b577ae67c9aa2289095bfedc38e2">EdgeBasis</a>(iF);</div>
<div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;            <span class="comment">// for each DOF of the boundary edge</span></div>
<div class="line"><a name="l00744"></a><span class="lineno">  744</span>&#160;            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; m_nlocal_edge_dofs; i++){</div>
<div class="line"><a name="l00745"></a><span class="lineno">  745</span>&#160;              QuadratureRule quadF = <a class="code" href="group__Quadratures.html#gad8f643134b5bea1e323e14c5ac42aa74">generate_quadrature_rule</a>(*F, 2*m_K+2);</div>
<div class="line"><a name="l00746"></a><span class="lineno">  746</span>&#160;              std::function&lt;double(VectorRd)&gt; Kgrad_n = [&amp;](VectorRd p){</div>
<div class="line"><a name="l00747"></a><span class="lineno">  747</span>&#160;                <span class="keywordflow">return</span> nTF.dot(kappa(p,cell) * grad_exact_solution(p,cell)) * basisF.function(i,p);</div>
<div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;              };</div>
<div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;              <span class="keywordflow">for</span> (<a class="code" href="structHArDCore2D_1_1QuadratureNode.html">QuadratureNode</a>&amp; qF : quadF){</div>
<div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;                b(offset_F + i) += qF.w * Kgrad_n(qF.vector());</div>
<div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160;              }</div>
<div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;            }</div>
<div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160;          }</div>
<div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;        }</div>
<div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;      }</div>
<div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;    }</div>
<div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160; </div>
<div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;    <span class="keywordflow">return</span> b;</div>
<div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;  }</div>
<div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160; </div>
<div class="line"><a name="l00761"></a><span class="lineno"><a class="line" href="group__HHO__LocVarDiff.html#ga11896824f2d3a743fd7caabeb396f158">  761</a></span>&#160;  <span class="keywordtype">double</span> <a class="code" href="group__HHO__LocVarDiff.html#ga11896824f2d3a743fd7caabeb396f158">HHO_LocVarDiff::EnergyNorm</a>(<a class="code" href="classHArDCore2D_1_1HybridCore.html">HybridCore</a>&amp; hho, <span class="keyword">const</span> <a class="code" href="classHArDCore2D_1_1UVector.html">UVector</a> Xh) {</div>
<div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;    <span class="keyword">const</span> <span class="keyword">auto</span> mesh = hho.<a class="code" href="group__HybridCore.html#ga8e87aec0e4162f6307eef0c04216a6cd">get_mesh</a>();</div>
<div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;    <span class="keywordtype">double</span> value = 0.0;</div>
<div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160; </div>
<div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> iT = 0; iT &lt; mesh-&gt;<a class="code" href="group__Mesh.html#ga2202a0715196c41356692d8adcfe3893">n_cells</a>(); iT++) {</div>
<div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;      Eigen::VectorXd XTF = Xh.<a class="code" href="group__HybridCore.html#ga24a0a68f8f1e8bdc4845bee48b7ce8d2">restr</a>(iT);</div>
<div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;      value += XTF.transpose() * aT[iT] * XTF;</div>
<div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;    }</div>
<div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160; </div>
<div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;    <span class="keywordflow">return</span> sqrt(value);</div>
<div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;  }</div>
<div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160; </div>
<div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160; </div>
<div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160;} <span class="comment">// end of namespace HArDCore2D</span></div>
<div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160; </div>
<div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;<span class="preprocessor">#endif //_HHO_LOCVARDIFF_HPP</span></div>
</div><!-- fragment --></div><!-- contents -->
<div class="ttc" id="agroup__Mesh_html_ga55a1cd5db98bbce8c73ab86b4527859c"><div class="ttname"><a href="group__Mesh.html#ga55a1cd5db98bbce8c73ab86b4527859c">HArDCore2D::Mesh::n_edges</a></div><div class="ttdeci">size_t n_edges() const</div><div class="ttdoc">number of edges in the mesh</div><div class="ttdef"><b>Definition:</b> mesh.hpp:154</div></div>
<div class="ttc" id="aclassHArDCore2D_1_1ElementQuad_html"><div class="ttname"><a href="classHArDCore2D_1_1ElementQuad.html">HArDCore2D::ElementQuad</a></div><div class="ttdef"><b>Definition:</b> elementquad.hpp:49</div></div>
<div class="ttc" id="agroup__HHO__LocVarDiff_html_ga3c58f6557feeea1edc9db4290a95bf4e"><div class="ttname"><a href="group__HHO__LocVarDiff.html#ga3c58f6557feeea1edc9db4290a95bf4e">HArDCore2D::HHO_LocVarDiff::get_ntotal_dofs</a></div><div class="ttdeci">const size_t get_ntotal_dofs()</div><div class="ttdoc">Total number of degrees of freedom over the entire mesh.</div><div class="ttdef"><b>Definition:</b> HHO_LocVarDiff.hpp:131</div></div>
<div class="ttc" id="agroup__Mesh_html_gad558804a7493cb6a6d968f48bb4f4742"><div class="ttname"><a href="group__Mesh.html#gad558804a7493cb6a6d968f48bb4f4742">HArDCore2D::Edge::diam</a></div><div class="ttdeci">double diam() const</div><div class="ttdoc">length of the edge</div><div class="ttdef"><b>Definition:</b> edge.cpp:76</div></div>
<div class="ttc" id="agroup__Mesh_html_gaecd909db5f3ab863010382cf6b71ec58"><div class="ttname"><a href="group__Mesh.html#gaecd909db5f3ab863010382cf6b71ec58">HArDCore2D::Mesh::dim</a></div><div class="ttdeci">size_t dim() const</div><div class="ttdoc">dimension of the mesh (2)</div><div class="ttdef"><b>Definition:</b> mesh.hpp:157</div></div>
<div class="ttc" id="aclassHArDCore2D_1_1Cell_html"><div class="ttname"><a href="classHArDCore2D_1_1Cell.html">HArDCore2D::Cell</a></div><div class="ttdoc">The Cell class provides description of a cell.</div><div class="ttdef"><b>Definition:</b> cell.hpp:31</div></div>
<div class="ttc" id="agroup__HHO__LocVarDiff_html_gafef8cb4110ec3b95f3c83090fe26d598"><div class="ttname"><a href="group__HHO__LocVarDiff.html#gafef8cb4110ec3b95f3c83090fe26d598">HArDCore2D::HHO_LocVarDiff::get_SysMat</a></div><div class="ttdeci">Eigen::SparseMatrix&lt; double &gt; get_SysMat()</div><div class="ttdoc">Return the (statically condensed) matrix system.</div><div class="ttdef"><b>Definition:</b> HHO_LocVarDiff.hpp:93</div></div>
<div class="ttc" id="agroup__Mesh_html_ga41ebc04d2b292197a02a9afd25a76a18"><div class="ttname"><a href="group__Mesh.html#ga41ebc04d2b292197a02a9afd25a76a18">HArDCore2D::Edge::center_mass</a></div><div class="ttdeci">Vector2d center_mass() const</div><div class="ttdoc">get the midpoint of the edge</div><div class="ttdef"><b>Definition:</b> edge.hpp:90</div></div>
<div class="ttc" id="agroup__HHO__LocVarDiff_html_ga9648b003ca1d519794bcc5407c8ce606"><div class="ttname"><a href="group__HHO__LocVarDiff.html#ga9648b003ca1d519794bcc5407c8ce606">HArDCore2D::HHO_LocVarDiff::get_solving_error</a></div><div class="ttdeci">double get_solving_error() const</div><div class="ttdoc">residual after solving the scheme</div><div class="ttdef"><b>Definition:</b> HHO_LocVarDiff.hpp:108</div></div>
<div class="ttc" id="agroup__HHO__LocVarDiff_html_gab6713bb636cc108b62d04e0c87a4fdf8"><div class="ttname"><a href="group__HHO__LocVarDiff.html#gab6713bb636cc108b62d04e0c87a4fdf8">HArDCore2D::HHO_LocVarDiff::get_nlocal_edge_dofs</a></div><div class="ttdeci">const size_t get_nlocal_edge_dofs()</div><div class="ttdoc">Number of DOFs on each edge.</div><div class="ttdef"><b>Definition:</b> HHO_LocVarDiff.hpp:121</div></div>
<div class="ttc" id="agroup__Basis_html_ga15a1f56b9bb54f849ebaf4a66f75907d"><div class="ttname"><a href="group__Basis.html#ga15a1f56b9bb54f849ebaf4a66f75907d">HArDCore2D::Family::function</a></div><div class="ttdeci">FunctionValue function(size_t i, const VectorRd &amp;x) const</div><div class="ttdoc">Evaluate the i-th function at point x.</div><div class="ttdef"><b>Definition:</b> basis.hpp:345</div></div>
<div class="ttc" id="aclassHArDCore2D_1_1Mesh_html"><div class="ttname"><a href="classHArDCore2D_1_1Mesh.html">HArDCore2D::Mesh</a></div><div class="ttdoc">The Mesh class provides description of a mesh.</div><div class="ttdef"><b>Definition:</b> mesh.hpp:60</div></div>
<div class="ttc" id="agroup__Basis_html_ga56ea5a2eec9e5f2534c5ea34c6f8e973"><div class="ttname"><a href="group__Basis.html#ga56ea5a2eec9e5f2534c5ea34c6f8e973">HArDCore2D::compute_gram_matrix</a></div><div class="ttdeci">Eigen::MatrixXd compute_gram_matrix(const boost::multi_array&lt; VectorRd, 2 &gt; &amp;B1, const boost::multi_array&lt; double, 2 &gt; &amp;B2, const QuadratureRule &amp;qr)</div><div class="ttdoc">Compute the Gram-like matrix given a family of vector-valued and one of scalar-valued functions by te...</div><div class="ttdef"><b>Definition:</b> basis.cpp:170</div></div>
<div class="ttc" id="aclassHArDCore2D_1_1HybridCore_html"><div class="ttname"><a href="classHArDCore2D_1_1HybridCore.html">HArDCore2D::HybridCore</a></div><div class="ttdef"><b>Definition:</b> hybridcore.hpp:167</div></div>
<div class="ttc" id="agroup__HHO__LocVarDiff_html_ga426d431a09113a934bc5dfc574a329fe"><div class="ttname"><a href="group__HHO__LocVarDiff.html#ga426d431a09113a934bc5dfc574a329fe">HArDCore2D::HHO_LocVarDiff::HHO_LocVarDiff</a></div><div class="ttdeci">HHO_LocVarDiff(HybridCore &amp;hho, size_t K, int L, CellFType&lt; MatrixRd &gt; kappa, size_t deg_kappa, CellFType&lt; double &gt; source, BoundaryConditions BC, FType&lt; double &gt; exact_solution, CellFType&lt; VectorRd &gt; grad_exact_solution, std::string solver_type, bool use_threads, std::ostream &amp;output=std::cout)</div><div class="ttdoc">Constructor of the class.</div><div class="ttdef"><b>Definition:</b> HHO_LocVarDiff.hpp:189</div></div>
<div class="ttc" id="agroup__Basis_html_gab1e36fbf129c707351e533ee43579432"><div class="ttname"><a href="group__Basis.html#gab1e36fbf129c707351e533ee43579432">HArDCore2D::FType</a></div><div class="ttdeci">std::function&lt; T(const VectorRd &amp;)&gt; FType</div><div class="ttdoc">type for function of point. T is the type of value of the function</div><div class="ttdef"><b>Definition:</b> basis.hpp:62</div></div>
<div class="ttc" id="aclassHArDCore2D_1_1Edge_html"><div class="ttname"><a href="classHArDCore2D_1_1Edge.html">HArDCore2D::Edge</a></div><div class="ttdoc">The Edge class provides description of an edge.</div><div class="ttdef"><b>Definition:</b> edge.hpp:31</div></div>
<div class="ttc" id="agroup__Basis_html_ga687c3c9504c4b10c5a18654530980086"><div class="ttname"><a href="group__Basis.html#ga687c3c9504c4b10c5a18654530980086">HArDCore2D::evaluate_quad::compute</a></div><div class="ttdeci">static boost::multi_array&lt; typename detail::basis_evaluation_traits&lt; BasisType, BasisFunction &gt;::ReturnValue, 2 &gt; compute(const BasisType &amp;basis, const QuadratureRule &amp;quad)</div><div class="ttdoc">Generic basis evaluation.</div><div class="ttdef"><b>Definition:</b> basis.hpp:1919</div></div>
<div class="ttc" id="agroup__BoundaryConditions_html_gabaeb77c2484042f248639f1806fe8e72"><div class="ttname"><a href="group__BoundaryConditions.html#gabaeb77c2484042f248639f1806fe8e72">BoundaryConditions::type</a></div><div class="ttdeci">const std::string type(const Edge &amp;edge) const</div><div class="ttdoc">Test the boundary condition of an edge.</div><div class="ttdef"><b>Definition:</b> BoundaryConditions.cpp:41</div></div>
<div class="ttc" id="agroup__HHO__LocVarDiff_html_ga1f76dc1a9a6c0b6ccfac42b33073480c"><div class="ttname"><a href="group__HHO__LocVarDiff.html#ga1f76dc1a9a6c0b6ccfac42b33073480c">HArDCore2D::HHO_LocVarDiff::get_nhighorder_dofs</a></div><div class="ttdeci">const size_t get_nhighorder_dofs()</div><div class="ttdoc">Number of DOFs per cell for high-order (K+1) polynomials.</div><div class="ttdef"><b>Definition:</b> HHO_LocVarDiff.hpp:123</div></div>
<div class="ttc" id="agroup__HybridCore_html_ga3c549d43c0a5171d0c14f6b56ffc843d"><div class="ttname"><a href="group__HybridCore.html#ga3c549d43c0a5171d0c14f6b56ffc843d">HArDCore2D::ElementQuad::get_vec_phiT_quadT</a></div><div class="ttdeci">boost::multi_array&lt; VectorRd, 2 &gt; get_vec_phiT_quadT(size_t degree) const</div><div class="ttdoc">Builds on the fly the values of vector cell basis functions at cell quadrature nodes....</div><div class="ttdef"><b>Definition:</b> elementquad.cpp:62</div></div>
<div class="ttc" id="agroup__Mesh_html_ga1b0586610a05e1a7a64bbe11f59e9b19"><div class="ttname"><a href="group__Mesh.html#ga1b0586610a05e1a7a64bbe11f59e9b19">HArDCore2D::Cell::n_edges</a></div><div class="ttdeci">size_t n_edges() const</div><div class="ttdoc">returns number of edges of the cell</div><div class="ttdef"><b>Definition:</b> cell.hpp:108</div></div>
<div class="ttc" id="agroup__Mesh_html_ga2202a0715196c41356692d8adcfe3893"><div class="ttname"><a href="group__Mesh.html#ga2202a0715196c41356692d8adcfe3893">HArDCore2D::Mesh::n_cells</a></div><div class="ttdeci">size_t n_cells() const</div><div class="ttdoc">number of cells in the mesh</div><div class="ttdef"><b>Definition:</b> mesh.hpp:153</div></div>
<div class="ttc" id="agroup__HybridCore_html_gafb3e4d056b781b2fff5e46466d47e0f3"><div class="ttname"><a href="group__HybridCore.html#gafb3e4d056b781b2fff5e46466d47e0f3">HArDCore2D::HybridCore::CellBasis</a></div><div class="ttdeci">const PolyCellBasisType &amp; CellBasis(size_t iT) const</div><div class="ttdoc">Return cell basis for element with global index iT.</div><div class="ttdef"><b>Definition:</b> hybridcore.hpp:199</div></div>
<div class="ttc" id="agroup__Mesh_html_ga66b278b12266d5c5bfee8699886cc89b"><div class="ttname"><a href="group__Mesh.html#ga66b278b12266d5c5bfee8699886cc89b">HArDCore2D::Cell::center_mass</a></div><div class="ttdeci">Vector2d center_mass() const</div><div class="ttdoc">returns the center of mass of the cell</div><div class="ttdef"><b>Definition:</b> cell.hpp:103</div></div>
<div class="ttc" id="agroup__HybridCore_html_ga38b36a187519471f6cbe4719f14c5bd1"><div class="ttname"><a href="group__HybridCore.html#ga38b36a187519471f6cbe4719f14c5bd1">HArDCore2D::UVector::asVectorXd</a></div><div class="ttdeci">Eigen::VectorXd &amp; asVectorXd() const</div><div class="ttdoc">Return the values as an Eigen vector.</div><div class="ttdef"><b>Definition:</b> hybridcore.hpp:92</div></div>
<div class="ttc" id="agroup__HHO__LocVarDiff_html_gad02a8f10049abe8b2c740a60e903f8d0"><div class="ttname"><a href="group__HHO__LocVarDiff.html#gad02a8f10049abe8b2c740a60e903f8d0">HArDCore2D::HHO_LocVarDiff::get_ntotal_edge_dofs</a></div><div class="ttdeci">const size_t get_ntotal_edge_dofs()</div><div class="ttdoc">Total number of edge DOFs over the entire mesh.</div><div class="ttdef"><b>Definition:</b> HHO_LocVarDiff.hpp:127</div></div>
<div class="ttc" id="agroup__HybridCore_html_ga06825c5d156026d465a2798389aa952b"><div class="ttname"><a href="group__HybridCore.html#ga06825c5d156026d465a2798389aa952b">HArDCore2D::HybridCore::compute_weights</a></div><div class="ttdeci">Eigen::VectorXd compute_weights(size_t iT) const</div><div class="ttdoc">Computes the weights to get cell values from edge values when l=-1.</div><div class="ttdef"><b>Definition:</b> hybridcore.cpp:138</div></div>
<div class="ttc" id="agroup__HybridCore_html_ga213822f156a19022e6bff238d438606d"><div class="ttname"><a href="group__HybridCore.html#ga213822f156a19022e6bff238d438606d">HArDCore2D::ElementQuad::get_quadT</a></div><div class="ttdeci">const QuadratureRule &amp; get_quadT() const</div><div class="ttdoc">Returns quadrature rules in cell.</div><div class="ttdef"><b>Definition:</b> elementquad.hpp:61</div></div>
<div class="ttc" id="agroup__HHO__LocVarDiff_html_gaecb29f27e40c73300e20075e8f9f5d3b"><div class="ttname"><a href="group__HHO__LocVarDiff.html#gaecb29f27e40c73300e20075e8f9f5d3b">HArDCore2D::HHO_LocVarDiff::get_ndir_edge_dofs</a></div><div class="ttdeci">const size_t get_ndir_edge_dofs()</div><div class="ttdoc">Total number of edge DOFs for Dirichlet edges.</div><div class="ttdef"><b>Definition:</b> HHO_LocVarDiff.hpp:129</div></div>
<div class="ttc" id="aclassHArDCore2D_1_1Family_html"><div class="ttname"><a href="classHArDCore2D_1_1Family.html">HArDCore2D::Family</a></div><div class="ttdef"><b>Definition:</b> basis.hpp:306</div></div>
<div class="ttc" id="agroup__HHO__LocVarDiff_html_gabbda77d7148aac2bf61c43ec766add33"><div class="ttname"><a href="group__HHO__LocVarDiff.html#gabbda77d7148aac2bf61c43ec766add33">HArDCore2D::HHO_LocVarDiff::get_ntotal_cell_dofs</a></div><div class="ttdeci">const size_t get_ntotal_cell_dofs()</div><div class="ttdoc">Total number of cell DOFs over the entire mesh.</div><div class="ttdef"><b>Definition:</b> HHO_LocVarDiff.hpp:125</div></div>
<div class="ttc" id="aclassHArDCore2D_1_1HHO__LocVarDiff_html"><div class="ttname"><a href="classHArDCore2D_1_1HHO__LocVarDiff.html">HArDCore2D::HHO_LocVarDiff</a></div><div class="ttdoc">The HHO_LocVarDiff class provides tools to implement the HHO method for the diffusion problem.</div><div class="ttdef"><b>Definition:</b> HHO_LocVarDiff.hpp:65</div></div>
<div class="ttc" id="agroup__Mesh_html_gae07b938c57cf57e3bb9c76d3df1eb549"><div class="ttname"><a href="group__Mesh.html#gae07b938c57cf57e3bb9c76d3df1eb549">HArDCore2D::Mesh::cell</a></div><div class="ttdeci">Cell * cell(size_t iC) const</div><div class="ttdoc">get a constant pointer to a cell using its global index</div><div class="ttdef"><b>Definition:</b> mesh.cpp:47</div></div>
<div class="ttc" id="agroup__Mesh_html_ga10424f4b99793ab359b5dd099f9255ee"><div class="ttname"><a href="group__Mesh.html#ga10424f4b99793ab359b5dd099f9255ee">HArDCore2D::Edge::is_boundary</a></div><div class="ttdeci">bool is_boundary() const</div><div class="ttdoc">getter to see if edge is boundary edge</div><div class="ttdef"><b>Definition:</b> edge.hpp:88</div></div>
<div class="ttc" id="aclassHArDCore2D_1_1UVector_html"><div class="ttname"><a href="classHArDCore2D_1_1UVector.html">HArDCore2D::UVector</a></div><div class="ttdef"><b>Definition:</b> hybridcore.hpp:81</div></div>
<div class="ttc" id="agroup__Mesh_html_ga85defed1382a8af8227e89f00434603e"><div class="ttname"><a href="group__Mesh.html#ga85defed1382a8af8227e89f00434603e">HArDCore2D::Cell::edge</a></div><div class="ttdeci">Edge * edge(size_t iL) const</div><div class="ttdoc">returns the iL-th edge of the cell</div><div class="ttdef"><b>Definition:</b> cell.cpp:58</div></div>
<div class="ttc" id="agroup__BoundaryConditions_html_gad3c69b47183027c427ff6404875da645"><div class="ttname"><a href="group__BoundaryConditions.html#gad3c69b47183027c427ff6404875da645">BoundaryConditions::n_dir_edges</a></div><div class="ttdeci">const size_t n_dir_edges() const</div><div class="ttdoc">Returns the number of Dirichlet edges.</div><div class="ttdef"><b>Definition:</b> BoundaryConditions.hpp:70</div></div>
<div class="ttc" id="agroup__Quadratures_html_gad8f643134b5bea1e323e14c5ac42aa74"><div class="ttname"><a href="group__Quadratures.html#gad8f643134b5bea1e323e14c5ac42aa74">HArDCore2D::generate_quadrature_rule</a></div><div class="ttdeci">QuadratureRule generate_quadrature_rule(const Cell &amp;T, const int doe, const bool force_split)</div><div class="ttdoc">Generate quadrature rule on mesh element.</div><div class="ttdef"><b>Definition:</b> quadraturerule.cpp:10</div></div>
<div class="ttc" id="agroup__Mesh_html_gaad9bc371c5c2669b3d3948e353f714f8"><div class="ttname"><a href="group__Mesh.html#gaad9bc371c5c2669b3d3948e353f714f8">HArDCore2D::Cell::edge_normal</a></div><div class="ttdeci">Vector2d edge_normal(size_t i) const</div><div class="ttdoc">returns the outer normal to the i-th edge</div><div class="ttdef"><b>Definition:</b> cell.cpp:112</div></div>
<div class="ttc" id="agroup__HHO__LocVarDiff_html_ga5a556b259e62cf0474e2f933da569b15"><div class="ttname"><a href="group__HHO__LocVarDiff.html#ga5a556b259e62cf0474e2f933da569b15">HArDCore2D::HHO_LocVarDiff::assemble</a></div><div class="ttdeci">void assemble(HybridCore &amp;hho)</div><div class="ttdoc">Assemble and solve the scheme.</div><div class="ttdef"><b>Definition:</b> HHO_LocVarDiff.hpp:220</div></div>
<div class="ttc" id="agroup__HHO__LocVarDiff_html_ga61e65ce589db4203515ae8e1f5c30d0f"><div class="ttname"><a href="group__HHO__LocVarDiff.html#ga61e65ce589db4203515ae8e1f5c30d0f">HArDCore2D::HHO_LocVarDiff::get_itime</a></div><div class="ttdeci">double get_itime(size_t idx) const</div><div class="ttdoc">various intermediate assembly times</div><div class="ttdef"><b>Definition:</b> HHO_LocVarDiff.hpp:113</div></div>
<div class="ttc" id="agroup__Mesh_html_gabae9df200fe23a302b3d01e4ff13f921"><div class="ttname"><a href="group__Mesh.html#gabae9df200fe23a302b3d01e4ff13f921">HArDCore2D::Mesh::get_cells</a></div><div class="ttdeci">std::vector&lt; Cell * &gt; get_cells() const</div><div class="ttdoc">lists the cells in the mesh.</div><div class="ttdef"><b>Definition:</b> mesh.hpp:218</div></div>
<div class="ttc" id="agroup__Basis_html_ga385bf99cf8c3888a150ed53f410ae39f"><div class="ttname"><a href="group__Basis.html#ga385bf99cf8c3888a150ed53f410ae39f">HArDCore2D::Family::dimension</a></div><div class="ttdeci">size_t dimension() const</div><div class="ttdoc">Dimension of the family. This is actually the number of functions in the family, not necessarily line...</div><div class="ttdef"><b>Definition:</b> basis.hpp:339</div></div>
<div class="ttc" id="agroup__HHO__LocVarDiff_html_ga9c37d2cf2744465d0bf50ff02fe185f9"><div class="ttname"><a href="group__HHO__LocVarDiff.html#ga9c37d2cf2744465d0bf50ff02fe185f9">HArDCore2D::HHO_LocVarDiff::get_assembly_time</a></div><div class="ttdeci">double get_assembly_time() const</div><div class="ttdoc">cpu time to assemble the scheme</div><div class="ttdef"><b>Definition:</b> HHO_LocVarDiff.hpp:98</div></div>
<div class="ttc" id="agroup__HybridCore_html_ga08c8a69abf1995ea353668beb8c5b19b"><div class="ttname"><a href="group__HybridCore.html#ga08c8a69abf1995ea353668beb8c5b19b">HArDCore2D::ElementQuad::get_quadF</a></div><div class="ttdeci">const QuadratureRule &amp; get_quadF(size_t ilF) const</div><div class="ttdoc">Returns quadrature rules on edge with local number ilF.</div><div class="ttdef"><b>Definition:</b> elementquad.hpp:67</div></div>
<div class="ttc" id="agroup__HybridCore_html_ga0289327a67759deb2c311e75d4f6ce55"><div class="ttname"><a href="group__HybridCore.html#ga0289327a67759deb2c311e75d4f6ce55">HArDCore2D::ElementQuad::get_phiF_quadF</a></div><div class="ttdeci">const boost::multi_array&lt; double, 2 &gt; get_phiF_quadF(size_t ilF) const</div><div class="ttdoc">Returns values of edge basis functions at edge quadrature nodes, for edge with local number ilF.</div><div class="ttdef"><b>Definition:</b> elementquad.hpp:91</div></div>
<div class="ttc" id="agroup__HHO__LocVarDiff_html_gad184ecd99c5da4172395a210d0289c12"><div class="ttname"><a href="group__HHO__LocVarDiff.html#gad184ecd99c5da4172395a210d0289c12">HArDCore2D::HHO_LocVarDiff::get_solving_time</a></div><div class="ttdeci">double get_solving_time() const</div><div class="ttdoc">cpu time to solve the scheme</div><div class="ttdef"><b>Definition:</b> HHO_LocVarDiff.hpp:103</div></div>
<div class="ttc" id="agroup__HybridCore_html_ga4962e2d0b866a3016b574f24c0d15940"><div class="ttname"><a href="group__HybridCore.html#ga4962e2d0b866a3016b574f24c0d15940">HArDCore2D::ElementQuad::get_dphiT_quadT</a></div><div class="ttdeci">const boost::multi_array&lt; VectorRd, 2 &gt; &amp; get_dphiT_quadT() const</div><div class="ttdoc">Returns values of gradients of cell basis functions at cell quadrature nodes.</div><div class="ttdef"><b>Definition:</b> elementquad.hpp:79</div></div>
<div class="ttc" id="agroup__HybridCore_html_gab8d725c09a9086bfe42688d0f34d1669"><div class="ttname"><a href="group__HybridCore.html#gab8d725c09a9086bfe42688d0f34d1669">HArDCore2D::ElementQuad::get_phiT_quadF</a></div><div class="ttdeci">const boost::multi_array&lt; double, 2 &gt; &amp; get_phiT_quadF(size_t ilF) const</div><div class="ttdoc">Returns values of cell basis functions at edge quadrature nodes, for edge with local number ilF.</div><div class="ttdef"><b>Definition:</b> elementquad.hpp:85</div></div>
<div class="ttc" id="agroup__Mesh_html_ga774e975ebad5e6bdccf549215293d624"><div class="ttname"><a href="group__Mesh.html#ga774e975ebad5e6bdccf549215293d624">HArDCore2D::Edge::global_index</a></div><div class="ttdeci">size_t global_index() const</div><div class="ttdoc">returns the edge global index</div><div class="ttdef"><b>Definition:</b> edge.hpp:86</div></div>
<div class="ttc" id="agroup__HybridCore_html_ga9394b577ae67c9aa2289095bfedc38e2"><div class="ttname"><a href="group__HybridCore.html#ga9394b577ae67c9aa2289095bfedc38e2">HArDCore2D::HybridCore::EdgeBasis</a></div><div class="ttdeci">const PolyEdgeBasisType &amp; EdgeBasis(size_t iE) const</div><div class="ttdoc">Return edge basis for edge with global index iE.</div><div class="ttdef"><b>Definition:</b> hybridcore.hpp:207</div></div>
<div class="ttc" id="agroup__HybridCore_html_ga320f4be89026a2059fe48d1286a9aebf"><div class="ttname"><a href="group__HybridCore.html#ga320f4be89026a2059fe48d1286a9aebf">HArDCore2D::DimPoly&lt; Cell &gt;</a></div><div class="ttdeci">const size_t DimPoly&lt; Cell &gt;(const int m)</div><div class="ttdoc">Compute the size of the basis of 2-variate polynomials up to degree m.</div><div class="ttdef"><b>Definition:</b> hybridcore.hpp:63</div></div>
<div class="ttc" id="agroup__Mesh_html_gacad7cdf3d2c00fa6fc23ff77c63c7d1a"><div class="ttname"><a href="group__Mesh.html#gacad7cdf3d2c00fa6fc23ff77c63c7d1a">HArDCore2D::Mesh::edge</a></div><div class="ttdeci">Edge * edge(size_t iE) const</div><div class="ttdoc">get a constant pointer to an edge using its global index</div><div class="ttdef"><b>Definition:</b> mesh.cpp:55</div></div>
<div class="ttc" id="agroup__HybridCore_html_ga24a0a68f8f1e8bdc4845bee48b7ce8d2"><div class="ttname"><a href="group__HybridCore.html#ga24a0a68f8f1e8bdc4845bee48b7ce8d2">HArDCore2D::UVector::restr</a></div><div class="ttdeci">Eigen::VectorXd restr(size_t iT) const</div><div class="ttdoc">Extract the restriction of the unknowns corresponding to cell iT and its edges.</div><div class="ttdef"><b>Definition:</b> hybridcore.cpp:29</div></div>
<div class="ttc" id="aclassBoundaryConditions_html"><div class="ttname"><a href="classBoundaryConditions.html">BoundaryConditions</a></div><div class="ttdoc">The BoundaryConditions class provides definition of boundary conditions.</div><div class="ttdef"><b>Definition:</b> BoundaryConditions.hpp:45</div></div>
<div class="ttc" id="agroup__BoundaryConditions_html_gac3609733d5e7e43e9240d0a8b05d17ba"><div class="ttname"><a href="group__BoundaryConditions.html#gac3609733d5e7e43e9240d0a8b05d17ba">BoundaryConditions::name</a></div><div class="ttdeci">const std::string name() const</div><div class="ttdoc">Returns the complete name of the boundary condition.</div><div class="ttdef"><b>Definition:</b> BoundaryConditions.hpp:80</div></div>
<div class="ttc" id="agroup__HHO__LocVarDiff_html_ga11896824f2d3a743fd7caabeb396f158"><div class="ttname"><a href="group__HHO__LocVarDiff.html#ga11896824f2d3a743fd7caabeb396f158">HArDCore2D::HHO_LocVarDiff::EnergyNorm</a></div><div class="ttdeci">double EnergyNorm(HybridCore &amp;hho, const UVector Xh)</div><div class="ttdoc">Discrete energy norm (associated to the diffusion operator) of an hybrid function.</div><div class="ttdef"><b>Definition:</b> HHO_LocVarDiff.hpp:761</div></div>
<div class="ttc" id="agroup__Mesh_html_ga710ded03b7741c8377e0b2dda2395b46"><div class="ttname"><a href="group__Mesh.html#ga710ded03b7741c8377e0b2dda2395b46">HArDCore2D::Cell::is_boundary</a></div><div class="ttdeci">bool is_boundary() const</div><div class="ttdoc">returns true if cell touches the boundary</div><div class="ttdef"><b>Definition:</b> cell.hpp:104</div></div>
<div class="ttc" id="agroup__HybridCore_html_ga87443a1da538a16841f08e5a8c1dd8ee"><div class="ttname"><a href="group__HybridCore.html#ga87443a1da538a16841f08e5a8c1dd8ee">HArDCore2D::ElementQuad::get_phiT_quadT</a></div><div class="ttdeci">const boost::multi_array&lt; double, 2 &gt; &amp; get_phiT_quadT() const</div><div class="ttdoc">Returns values of cell basis functions at cell quadrature nodes.</div><div class="ttdef"><b>Definition:</b> elementquad.hpp:73</div></div>
<div class="ttc" id="agroup__HybridCore_html_ga7d6af50952aa59143ac364dd1dc4118e"><div class="ttname"><a href="group__HybridCore.html#ga7d6af50952aa59143ac364dd1dc4118e">HArDCore2D::HybridCore::interpolate</a></div><div class="ttdeci">UVector interpolate(const ContinuousFunction &amp;f, const int deg_cell, const size_t deg_edge, size_t doe) const</div><div class="ttdoc">Compute the interpolant in the discrete space of a continuous function.</div><div class="ttdef"><b>Definition:</b> hybridcore.hpp:279</div></div>
<div class="ttc" id="astructHArDCore2D_1_1QuadratureNode_html"><div class="ttname"><a href="structHArDCore2D_1_1QuadratureNode.html">HArDCore2D::QuadratureNode</a></div><div class="ttdoc">Description of one node and one weight from a quadrature rule.</div><div class="ttdef"><b>Definition:</b> quadraturerule.hpp:40</div></div>
<div class="ttc" id="agroup__HHO__LocVarDiff_html_ga4f40caa5b5d827f078f32fdfa888ed4e"><div class="ttname"><a href="group__HHO__LocVarDiff.html#ga4f40caa5b5d827f078f32fdfa888ed4e">HArDCore2D::HHO_LocVarDiff::get_nlocal_cell_dofs</a></div><div class="ttdeci">const size_t get_nlocal_cell_dofs()</div><div class="ttdoc">Number of DOFs in each cell.</div><div class="ttdef"><b>Definition:</b> HHO_LocVarDiff.hpp:119</div></div>
<div class="ttc" id="agroup__HybridCore_html_ga8e87aec0e4162f6307eef0c04216a6cd"><div class="ttname"><a href="group__HybridCore.html#ga8e87aec0e4162f6307eef0c04216a6cd">HArDCore2D::HybridCore::get_mesh</a></div><div class="ttdeci">const Mesh * get_mesh() const</div><div class="ttdoc">Returns a pointer to the mesh.</div><div class="ttdef"><b>Definition:</b> hybridcore.hpp:190</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
