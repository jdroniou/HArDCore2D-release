<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HArD::Core2D: Quadratures</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HArD::Core2D
   </div>
   <div id="projectbrief">Hybrid Arbitrary Degree::Core 2D - Library to implement 2D schemes with edge and cell polynomials as unknowns</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Quadratures</div>  </div>
</div><!--header-->
<div class="contents">

<p>Classes providing quadratures on edges and in cells.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHArDCore2D_1_1VecHash.html">HArDCore2D::VecHash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash function for VectorZd type.  <a href="structHArDCore2D_1_1VecHash.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1QuadRuleEdge.html">HArDCore2D::QuadRuleEdge</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1LegendreGauss.html">HArDCore2D::LegendreGauss</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHArDCore2D_1_1QuadratureNode.html">HArDCore2D::QuadratureNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Description of one node and one weight from a quadrature rule.  <a href="structHArDCore2D_1_1QuadratureNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga4255c52c7d9ac1165c0a37da8970feb6"><td class="memItemLeft" align="right" valign="top">typedef std::unordered_map&lt; <a class="el" href="group__Basis.html#ga2bc880baa1a6163014c7f37345bf8ac6">VectorZd</a>, double, <a class="el" href="structHArDCore2D_1_1VecHash.html">VecHash</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#ga4255c52c7d9ac1165c0a37da8970feb6">HArDCore2D::MonomialCellIntegralsType</a></td></tr>
<tr class="memdesc:ga4255c52c7d9ac1165c0a37da8970feb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for list of integrals of monomials.  <a href="group__Quadratures.html#ga4255c52c7d9ac1165c0a37da8970feb6">More...</a><br /></td></tr>
<tr class="separator:ga4255c52c7d9ac1165c0a37da8970feb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d89d9fdcd5599eefd37c35fbf28bd94"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#ga1d89d9fdcd5599eefd37c35fbf28bd94">HArDCore2D::MonomialEdgeIntegralsType</a></td></tr>
<tr class="memdesc:ga1d89d9fdcd5599eefd37c35fbf28bd94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for list of edge integrals of monomials.  <a href="group__Quadratures.html#ga1d89d9fdcd5599eefd37c35fbf28bd94">More...</a><br /></td></tr>
<tr class="separator:ga1d89d9fdcd5599eefd37c35fbf28bd94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08203d5fcf31125f46ed733ebfeac838"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="structHArDCore2D_1_1QuadratureNode.html">QuadratureNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#ga08203d5fcf31125f46ed733ebfeac838">HArDCore2D::QuadratureRule</a></td></tr>
<tr class="separator:ga08203d5fcf31125f46ed733ebfeac838"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7acbdfebfab831a76a7f71f558808e3f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#ga7acbdfebfab831a76a7f71f558808e3f">HArDCore2D::VecHash::operator()</a> (const <a class="el" href="group__Basis.html#ga2bc880baa1a6163014c7f37345bf8ac6">VectorZd</a> &amp;p) const</td></tr>
<tr class="separator:ga7acbdfebfab831a76a7f71f558808e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a6efbbf6ebaedd4e582f4ee965ec41d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Quadratures.html#ga4255c52c7d9ac1165c0a37da8970feb6">MonomialCellIntegralsType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#ga8a6efbbf6ebaedd4e582f4ee965ec41d">HArDCore2D::IntegrateCellMonomials</a> (const Cell &amp;<a class="el" href="mmread_8m.html#a688dbf4d8b443317cfd5b5abbc137402">T</a>, const size_t maxdeg)</td></tr>
<tr class="memdesc:ga8a6efbbf6ebaedd4e582f4ee965ec41d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute all integrals on a cell of monomials up to a total degree, using vertex values.  <a href="group__Quadratures.html#ga8a6efbbf6ebaedd4e582f4ee965ec41d">More...</a><br /></td></tr>
<tr class="separator:ga8a6efbbf6ebaedd4e582f4ee965ec41d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60f346b650d4c9ee3b872c72da9c9dbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Quadratures.html#ga4255c52c7d9ac1165c0a37da8970feb6">MonomialCellIntegralsType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#ga60f346b650d4c9ee3b872c72da9c9dbf">HArDCore2D::CheckIntegralsDegree</a> (const Cell &amp;<a class="el" href="mmread_8m.html#a688dbf4d8b443317cfd5b5abbc137402">T</a>, const size_t degree, const <a class="el" href="group__Quadratures.html#ga4255c52c7d9ac1165c0a37da8970feb6">MonomialCellIntegralsType</a> &amp;mono_int_map={})</td></tr>
<tr class="memdesc:ga60f346b650d4c9ee3b872c72da9c9dbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the degree of an existing list of monomial integrals is sufficient, other re-compute and return a proper list.  <a href="group__Quadratures.html#ga60f346b650d4c9ee3b872c72da9c9dbf">More...</a><br /></td></tr>
<tr class="separator:ga60f346b650d4c9ee3b872c72da9c9dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73858a4ddac05720e2ccb5001fc6ef97"><td class="memTemplParams" colspan="2">template&lt;typename BasisType &gt; </td></tr>
<tr class="memitem:ga73858a4ddac05720e2ccb5001fc6ef97"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#ga73858a4ddac05720e2ccb5001fc6ef97">HArDCore2D::transformGM</a> (const <a class="el" href="classHArDCore2D_1_1Family.html">Family</a>&lt; BasisType &gt; &amp;family_basis, const char RC, const Eigen::MatrixXd &amp;anc_GM)</td></tr>
<tr class="memdesc:ga73858a4ddac05720e2ccb5001fc6ef97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a Gram Matrix from an ancestor to a family basis.  <a href="group__Quadratures.html#ga73858a4ddac05720e2ccb5001fc6ef97">More...</a><br /></td></tr>
<tr class="separator:ga73858a4ddac05720e2ccb5001fc6ef97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8187bfc7c4a27405f770a77bb8831535"><td class="memTemplParams" colspan="2">template&lt;typename BasisType &gt; </td></tr>
<tr class="memitem:ga8187bfc7c4a27405f770a77bb8831535"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#ga8187bfc7c4a27405f770a77bb8831535">HArDCore2D::transformGM</a> (const <a class="el" href="classHArDCore2D_1_1RestrictedBasis.html">RestrictedBasis</a>&lt; BasisType &gt; &amp;restr_basis, const char RC, const Eigen::MatrixXd &amp;anc_GM)</td></tr>
<tr class="memdesc:ga8187bfc7c4a27405f770a77bb8831535"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a Gram Matrix from an ancestor to a restricted basis.  <a href="group__Quadratures.html#ga8187bfc7c4a27405f770a77bb8831535">More...</a><br /></td></tr>
<tr class="separator:ga8187bfc7c4a27405f770a77bb8831535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5426168676064ac8913c7d2c2431270a"><td class="memTemplParams" colspan="2">template&lt;typename BasisType &gt; </td></tr>
<tr class="memitem:ga5426168676064ac8913c7d2c2431270a"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#ga5426168676064ac8913c7d2c2431270a">HArDCore2D::transformGM</a> (const <a class="el" href="classHArDCore2D_1_1ShiftedBasis.html">ShiftedBasis</a>&lt; BasisType &gt; &amp;shifted_basis, const char RC, const Eigen::MatrixXd &amp;anc_GM)</td></tr>
<tr class="memdesc:ga5426168676064ac8913c7d2c2431270a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a Gram Matrix from an ancestor to a shifted basis.  <a href="group__Quadratures.html#ga5426168676064ac8913c7d2c2431270a">More...</a><br /></td></tr>
<tr class="separator:ga5426168676064ac8913c7d2c2431270a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad42da5a4d0c9a05bd319723d55775266"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#gad42da5a4d0c9a05bd319723d55775266">HArDCore2D::GramMatrix</a> (const Cell &amp;<a class="el" href="mmread_8m.html#a688dbf4d8b443317cfd5b5abbc137402">T</a>, const <a class="el" href="classHArDCore2D_1_1MonomialScalarBasisCell.html">MonomialScalarBasisCell</a> &amp;basis1, const <a class="el" href="classHArDCore2D_1_1MonomialScalarBasisCell.html">MonomialScalarBasisCell</a> &amp;basis2, <a class="el" href="group__Quadratures.html#ga4255c52c7d9ac1165c0a37da8970feb6">MonomialCellIntegralsType</a> mono_int_map={})</td></tr>
<tr class="memdesc:gad42da5a4d0c9a05bd319723d55775266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Gram Matrix of a pair of local scalar monomial bases.  <a href="group__Quadratures.html#gad42da5a4d0c9a05bd319723d55775266">More...</a><br /></td></tr>
<tr class="separator:gad42da5a4d0c9a05bd319723d55775266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c2c614308b041e3f2f1616c69ee2061"><td class="memTemplParams" colspan="2">template&lt;typename BasisType &gt; </td></tr>
<tr class="memitem:ga2c2c614308b041e3f2f1616c69ee2061"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#ga2c2c614308b041e3f2f1616c69ee2061">HArDCore2D::GramMatrix</a> (const Cell &amp;<a class="el" href="mmread_8m.html#a688dbf4d8b443317cfd5b5abbc137402">T</a>, const BasisType &amp;basis, <a class="el" href="group__Quadratures.html#ga4255c52c7d9ac1165c0a37da8970feb6">MonomialCellIntegralsType</a> mono_int_map={})</td></tr>
<tr class="memdesc:ga2c2c614308b041e3f2f1616c69ee2061"><td class="mdescLeft">&#160;</td><td class="mdescRight">This overload to simplify the call to GramMatrix in case the two bases are the same.  <a href="group__Quadratures.html#ga2c2c614308b041e3f2f1616c69ee2061">More...</a><br /></td></tr>
<tr class="separator:ga2c2c614308b041e3f2f1616c69ee2061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9d48397f244f7630124d4b4f0a38573"><td class="memTemplParams" colspan="2">template&lt;typename BasisType1 , typename BasisType2 , size_t N&gt; </td></tr>
<tr class="memitem:gae9d48397f244f7630124d4b4f0a38573"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#gae9d48397f244f7630124d4b4f0a38573">HArDCore2D::GramMatrix</a> (const Cell &amp;<a class="el" href="mmread_8m.html#a688dbf4d8b443317cfd5b5abbc137402">T</a>, const <a class="el" href="classHArDCore2D_1_1TensorizedVectorFamily.html">TensorizedVectorFamily</a>&lt; BasisType1, N &gt; &amp;basis1, const <a class="el" href="classHArDCore2D_1_1TensorizedVectorFamily.html">TensorizedVectorFamily</a>&lt; BasisType2, N &gt; &amp;basis2, <a class="el" href="group__Quadratures.html#ga4255c52c7d9ac1165c0a37da8970feb6">MonomialCellIntegralsType</a> mono_int_map={})</td></tr>
<tr class="memdesc:gae9d48397f244f7630124d4b4f0a38573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template to compute the Gram Matrix of any pair of tensorized scalar bases.  <a href="group__Quadratures.html#gae9d48397f244f7630124d4b4f0a38573">More...</a><br /></td></tr>
<tr class="separator:gae9d48397f244f7630124d4b4f0a38573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43c5fc43fd8083f5693fea6b7f96777c"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#ga43c5fc43fd8083f5693fea6b7f96777c">HArDCore2D::GramMatrix</a> (const Cell &amp;<a class="el" href="mmread_8m.html#a688dbf4d8b443317cfd5b5abbc137402">T</a>, const <a class="el" href="classHArDCore2D_1_1RolyComplBasisCell.html">RolyComplBasisCell</a> &amp;basis1, const <a class="el" href="classHArDCore2D_1_1RolyComplBasisCell.html">RolyComplBasisCell</a> &amp;basis2, <a class="el" href="group__Quadratures.html#ga4255c52c7d9ac1165c0a37da8970feb6">MonomialCellIntegralsType</a> mono_int_map={})</td></tr>
<tr class="memdesc:ga43c5fc43fd8083f5693fea6b7f96777c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Gram Matrix of a pair of RolyCompl bases.  <a href="group__Quadratures.html#ga43c5fc43fd8083f5693fea6b7f96777c">More...</a><br /></td></tr>
<tr class="separator:ga43c5fc43fd8083f5693fea6b7f96777c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa49eb423dc2b11b34801402220dd5546"><td class="memTemplParams" colspan="2">template&lt;typename BasisType1 , size_t N&gt; </td></tr>
<tr class="memitem:gaa49eb423dc2b11b34801402220dd5546"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#gaa49eb423dc2b11b34801402220dd5546">HArDCore2D::GramMatrix</a> (const Cell &amp;<a class="el" href="mmread_8m.html#a688dbf4d8b443317cfd5b5abbc137402">T</a>, const <a class="el" href="classHArDCore2D_1_1RolyComplBasisCell.html">RolyComplBasisCell</a> &amp;rolycompl_basis, const <a class="el" href="classHArDCore2D_1_1TensorizedVectorFamily.html">TensorizedVectorFamily</a>&lt; BasisType1, N &gt; &amp;tens_family, <a class="el" href="group__Quadratures.html#ga4255c52c7d9ac1165c0a37da8970feb6">MonomialCellIntegralsType</a> mono_int_map={})</td></tr>
<tr class="memdesc:gaa49eb423dc2b11b34801402220dd5546"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template to compute the Gram Matrix of a RolyCompl basis and a tensorized scalar basis.  <a href="group__Quadratures.html#gaa49eb423dc2b11b34801402220dd5546">More...</a><br /></td></tr>
<tr class="separator:gaa49eb423dc2b11b34801402220dd5546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16f1961718e9c2fc7d1145d64adc4bf8"><td class="memTemplParams" colspan="2">template&lt;typename BasisType1 , size_t N&gt; </td></tr>
<tr class="memitem:ga16f1961718e9c2fc7d1145d64adc4bf8"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#ga16f1961718e9c2fc7d1145d64adc4bf8">HArDCore2D::GramMatrix</a> (const Cell &amp;<a class="el" href="mmread_8m.html#a688dbf4d8b443317cfd5b5abbc137402">T</a>, const <a class="el" href="classHArDCore2D_1_1TensorizedVectorFamily.html">TensorizedVectorFamily</a>&lt; BasisType1, N &gt; &amp;tens_family, const <a class="el" href="classHArDCore2D_1_1RolyComplBasisCell.html">RolyComplBasisCell</a> &amp;rolycompl_basis, <a class="el" href="group__Quadratures.html#ga4255c52c7d9ac1165c0a37da8970feb6">MonomialCellIntegralsType</a> mono_int_map={})</td></tr>
<tr class="memdesc:ga16f1961718e9c2fc7d1145d64adc4bf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template to compute the Gram Matrix of a tensorized scalar basis and a RolyCompl basis.  <a href="group__Quadratures.html#ga16f1961718e9c2fc7d1145d64adc4bf8">More...</a><br /></td></tr>
<tr class="separator:ga16f1961718e9c2fc7d1145d64adc4bf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed4a8b8845e12623b679076ad2224bb7"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#gaed4a8b8845e12623b679076ad2224bb7">HArDCore2D::GramMatrix</a> (const Cell &amp;<a class="el" href="mmread_8m.html#a688dbf4d8b443317cfd5b5abbc137402">T</a>, const <a class="el" href="classHArDCore2D_1_1GolyComplBasisCell.html">GolyComplBasisCell</a> &amp;basis1, const <a class="el" href="classHArDCore2D_1_1GolyComplBasisCell.html">GolyComplBasisCell</a> &amp;basis2, <a class="el" href="group__Quadratures.html#ga4255c52c7d9ac1165c0a37da8970feb6">MonomialCellIntegralsType</a> mono_int_map={})</td></tr>
<tr class="memdesc:gaed4a8b8845e12623b679076ad2224bb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gram Matrix of a pair of GolyCompl bases.  <a href="group__Quadratures.html#gaed4a8b8845e12623b679076ad2224bb7">More...</a><br /></td></tr>
<tr class="separator:gaed4a8b8845e12623b679076ad2224bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88aa870647c37965633a03996c000cd2"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#ga88aa870647c37965633a03996c000cd2">HArDCore2D::GMRolyComplScalar</a> (const Cell &amp;<a class="el" href="mmread_8m.html#a688dbf4d8b443317cfd5b5abbc137402">T</a>, const <a class="el" href="classHArDCore2D_1_1RolyComplBasisCell.html">RolyComplBasisCell</a> &amp;rolycompl_basis, const <a class="el" href="classHArDCore2D_1_1MonomialScalarBasisCell.html">MonomialScalarBasisCell</a> &amp;mono_basis, const size_t m, <a class="el" href="group__Quadratures.html#ga4255c52c7d9ac1165c0a37da8970feb6">MonomialCellIntegralsType</a> mono_int_map)</td></tr>
<tr class="memdesc:ga88aa870647c37965633a03996c000cd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Gram Matrix of the mth component of a RolyCompl Basis and a monomial basis.  <a href="group__Quadratures.html#ga88aa870647c37965633a03996c000cd2">More...</a><br /></td></tr>
<tr class="separator:ga88aa870647c37965633a03996c000cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fe74b21dbcf4950c56050bc3210d791"><td class="memTemplParams" colspan="2">template&lt;typename BasisType &gt; </td></tr>
<tr class="memitem:ga7fe74b21dbcf4950c56050bc3210d791"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#ga7fe74b21dbcf4950c56050bc3210d791">HArDCore2D::GMRolyComplScalar</a> (const Cell &amp;<a class="el" href="mmread_8m.html#a688dbf4d8b443317cfd5b5abbc137402">T</a>, const <a class="el" href="classHArDCore2D_1_1RolyComplBasisCell.html">RolyComplBasisCell</a> &amp;basis1, const BasisType &amp;basis2, const size_t m, <a class="el" href="group__Quadratures.html#ga4255c52c7d9ac1165c0a37da8970feb6">MonomialCellIntegralsType</a> mono_int_map)</td></tr>
<tr class="memdesc:ga7fe74b21dbcf4950c56050bc3210d791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic template to compute the Gram Matrix of the mth component of a RolyCompl Basis and any basis.  <a href="group__Quadratures.html#ga7fe74b21dbcf4950c56050bc3210d791">More...</a><br /></td></tr>
<tr class="separator:ga7fe74b21dbcf4950c56050bc3210d791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50e8f7086d44b7ecff671732ec7a686b"><td class="memTemplParams" colspan="2">template&lt;typename BasisType &gt; </td></tr>
<tr class="memitem:ga50e8f7086d44b7ecff671732ec7a686b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#ga50e8f7086d44b7ecff671732ec7a686b">HArDCore2D::useAncestor</a> ()</td></tr>
<tr class="memdesc:ga50e8f7086d44b7ecff671732ec7a686b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the ancestor of a basis will be used to compute a Gram matrix for this basis.  <a href="group__Quadratures.html#ga50e8f7086d44b7ecff671732ec7a686b">More...</a><br /></td></tr>
<tr class="separator:ga50e8f7086d44b7ecff671732ec7a686b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddbeb84aa508db65d7d8bf5723d2de40"><td class="memTemplParams" colspan="2">template&lt;typename BasisType1 , typename BasisType2 &gt; </td></tr>
<tr class="memitem:gaddbeb84aa508db65d7d8bf5723d2de40"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#gaddbeb84aa508db65d7d8bf5723d2de40">HArDCore2D::GramMatrix</a> (const Cell &amp;<a class="el" href="mmread_8m.html#a688dbf4d8b443317cfd5b5abbc137402">T</a>, const BasisType1 &amp;basis1, const BasisType2 &amp;basis2, <a class="el" href="group__Quadratures.html#ga4255c52c7d9ac1165c0a37da8970feb6">MonomialCellIntegralsType</a> mono_int_map={})</td></tr>
<tr class="memdesc:gaddbeb84aa508db65d7d8bf5723d2de40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic template to compute the Gram Matrix of any pair of bases.  <a href="group__Quadratures.html#gaddbeb84aa508db65d7d8bf5723d2de40">More...</a><br /></td></tr>
<tr class="separator:gaddbeb84aa508db65d7d8bf5723d2de40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62df9455eba21fadd7a3bb612cc824fd"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#ga62df9455eba21fadd7a3bb612cc824fd">HArDCore2D::GMScalarDerivative</a> (const Cell &amp;<a class="el" href="mmread_8m.html#a688dbf4d8b443317cfd5b5abbc137402">T</a>, const <a class="el" href="classHArDCore2D_1_1MonomialScalarBasisCell.html">MonomialScalarBasisCell</a> &amp;basis1, const <a class="el" href="classHArDCore2D_1_1MonomialScalarBasisCell.html">MonomialScalarBasisCell</a> &amp;basis2, const size_t m, <a class="el" href="group__Quadratures.html#ga4255c52c7d9ac1165c0a37da8970feb6">MonomialCellIntegralsType</a> mono_int_map={})</td></tr>
<tr class="memdesc:ga62df9455eba21fadd7a3bb612cc824fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Gram Matrix of a pair of local scalar monomial bases, taking a partial derivative of the first (w.r.t. the homogeneous coordinates, without scaling)  <a href="group__Quadratures.html#ga62df9455eba21fadd7a3bb612cc824fd">More...</a><br /></td></tr>
<tr class="separator:ga62df9455eba21fadd7a3bb612cc824fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga185787c20259379014daf6cf8891d1bc"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#ga185787c20259379014daf6cf8891d1bc">HArDCore2D::GMScalarDerivative</a> (const Cell &amp;<a class="el" href="mmread_8m.html#a688dbf4d8b443317cfd5b5abbc137402">T</a>, const <a class="el" href="classHArDCore2D_1_1MonomialScalarBasisCell.html">MonomialScalarBasisCell</a> &amp;basis1, const <a class="el" href="classHArDCore2D_1_1MonomialScalarBasisCell.html">MonomialScalarBasisCell</a> &amp;basis2, const size_t m, const size_t l, <a class="el" href="group__Quadratures.html#ga4255c52c7d9ac1165c0a37da8970feb6">MonomialCellIntegralsType</a> mono_int_map={})</td></tr>
<tr class="memdesc:ga185787c20259379014daf6cf8891d1bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Gram Matrix of a pair of local scalar monomial bases, taking partial derivatives of each of them (w.r.t. the homogeneous coordinates, without scaling)  <a href="group__Quadratures.html#ga185787c20259379014daf6cf8891d1bc">More...</a><br /></td></tr>
<tr class="separator:ga185787c20259379014daf6cf8891d1bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1a862ee9dfdf66d4324a3e301f355c8"><td class="memTemplParams" colspan="2">template&lt;typename BasisType1 , typename BasisType2 &gt; </td></tr>
<tr class="memitem:gaa1a862ee9dfdf66d4324a3e301f355c8"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#gaa1a862ee9dfdf66d4324a3e301f355c8">HArDCore2D::GMScalarDerivative</a> (const Cell &amp;<a class="el" href="mmread_8m.html#a688dbf4d8b443317cfd5b5abbc137402">T</a>, const BasisType1 &amp;basis1, const BasisType2 &amp;basis2, const size_t m, <a class="el" href="group__Quadratures.html#ga4255c52c7d9ac1165c0a37da8970feb6">MonomialCellIntegralsType</a> mono_int_map={})</td></tr>
<tr class="memdesc:gaa1a862ee9dfdf66d4324a3e301f355c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic template to compute the Gram Matrix of any pair of scalar bases, taking a partial derivative of the first (w.r.t. the homogeneous coordinates, without scaling)  <a href="group__Quadratures.html#gaa1a862ee9dfdf66d4324a3e301f355c8">More...</a><br /></td></tr>
<tr class="separator:gaa1a862ee9dfdf66d4324a3e301f355c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15f404c82e3763df19dc0f42d054fd7f"><td class="memTemplParams" colspan="2">template&lt;typename BasisType1 , typename BasisType2 &gt; </td></tr>
<tr class="memitem:ga15f404c82e3763df19dc0f42d054fd7f"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#ga15f404c82e3763df19dc0f42d054fd7f">HArDCore2D::GMScalarDerivative</a> (const Cell &amp;<a class="el" href="mmread_8m.html#a688dbf4d8b443317cfd5b5abbc137402">T</a>, const BasisType1 &amp;basis1, const BasisType2 &amp;basis2, const size_t m, const size_t l, <a class="el" href="group__Quadratures.html#ga4255c52c7d9ac1165c0a37da8970feb6">MonomialCellIntegralsType</a> mono_int_map={})</td></tr>
<tr class="memdesc:ga15f404c82e3763df19dc0f42d054fd7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic template to compute the Gram Matrix of any pair of scalar bases, taking partial derivatives of each of them (w.r.t. the homogeneous coordinates, without scaling)  <a href="group__Quadratures.html#ga15f404c82e3763df19dc0f42d054fd7f">More...</a><br /></td></tr>
<tr class="separator:ga15f404c82e3763df19dc0f42d054fd7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8529fc82b243f13a785e65dd7bfc68a0"><td class="memTemplParams" colspan="2">template&lt;typename BasisType1 , typename BasisType2 , size_t N&gt; </td></tr>
<tr class="memitem:ga8529fc82b243f13a785e65dd7bfc68a0"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#ga8529fc82b243f13a785e65dd7bfc68a0">HArDCore2D::GramMatrix</a> (const Cell &amp;<a class="el" href="mmread_8m.html#a688dbf4d8b443317cfd5b5abbc137402">T</a>, const <a class="el" href="classHArDCore2D_1_1GradientBasis.html">GradientBasis</a>&lt; BasisType1 &gt; &amp;grad_basis, const <a class="el" href="classHArDCore2D_1_1TensorizedVectorFamily.html">TensorizedVectorFamily</a>&lt; BasisType2, N &gt; &amp;tens_family, <a class="el" href="group__Quadratures.html#ga4255c52c7d9ac1165c0a37da8970feb6">MonomialCellIntegralsType</a> mono_int_map={})</td></tr>
<tr class="memdesc:ga8529fc82b243f13a785e65dd7bfc68a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template to compute the Gram Matrix of a gradient basis and a tensorized scalar basis.  <a href="group__Quadratures.html#ga8529fc82b243f13a785e65dd7bfc68a0">More...</a><br /></td></tr>
<tr class="separator:ga8529fc82b243f13a785e65dd7bfc68a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f73d95c30b86a8372fbb8b1e2e0c08a"><td class="memTemplParams" colspan="2">template&lt;typename BasisType1 , typename BasisType2 , size_t N&gt; </td></tr>
<tr class="memitem:ga3f73d95c30b86a8372fbb8b1e2e0c08a"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#ga3f73d95c30b86a8372fbb8b1e2e0c08a">HArDCore2D::GramMatrix</a> (const Cell &amp;<a class="el" href="mmread_8m.html#a688dbf4d8b443317cfd5b5abbc137402">T</a>, const <a class="el" href="classHArDCore2D_1_1TensorizedVectorFamily.html">TensorizedVectorFamily</a>&lt; BasisType1, N &gt; &amp;tens_family, const <a class="el" href="classHArDCore2D_1_1GradientBasis.html">GradientBasis</a>&lt; BasisType2 &gt; &amp;grad_basis, <a class="el" href="group__Quadratures.html#ga4255c52c7d9ac1165c0a37da8970feb6">MonomialCellIntegralsType</a> mono_int_map={})</td></tr>
<tr class="memdesc:ga3f73d95c30b86a8372fbb8b1e2e0c08a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template to compute the Gram Matrix of a tensorized scalar basis and a gradient basis.  <a href="group__Quadratures.html#ga3f73d95c30b86a8372fbb8b1e2e0c08a">More...</a><br /></td></tr>
<tr class="separator:ga3f73d95c30b86a8372fbb8b1e2e0c08a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbd5897527898e51c459bc762edcc990"><td class="memTemplParams" colspan="2">template&lt;typename BasisType1 , typename BasisType2 &gt; </td></tr>
<tr class="memitem:gadbd5897527898e51c459bc762edcc990"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#gadbd5897527898e51c459bc762edcc990">HArDCore2D::GramMatrix</a> (const Cell &amp;<a class="el" href="mmread_8m.html#a688dbf4d8b443317cfd5b5abbc137402">T</a>, const <a class="el" href="classHArDCore2D_1_1GradientBasis.html">GradientBasis</a>&lt; BasisType1 &gt; &amp;grad_basis1, const <a class="el" href="classHArDCore2D_1_1GradientBasis.html">GradientBasis</a>&lt; BasisType2 &gt; &amp;grad_basis2, <a class="el" href="group__Quadratures.html#ga4255c52c7d9ac1165c0a37da8970feb6">MonomialCellIntegralsType</a> mono_int_map={})</td></tr>
<tr class="memdesc:gadbd5897527898e51c459bc762edcc990"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template to compute the Gram Matrix of a gradient basis and another gradient basis.  <a href="group__Quadratures.html#gadbd5897527898e51c459bc762edcc990">More...</a><br /></td></tr>
<tr class="separator:gadbd5897527898e51c459bc762edcc990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17710ae071fd2a88fba78507057d72a4"><td class="memTemplParams" colspan="2">template&lt;typename BasisType1 , typename BasisType2 &gt; </td></tr>
<tr class="memitem:ga17710ae071fd2a88fba78507057d72a4"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#ga17710ae071fd2a88fba78507057d72a4">HArDCore2D::GramMatrix</a> (const Cell &amp;<a class="el" href="mmread_8m.html#a688dbf4d8b443317cfd5b5abbc137402">T</a>, const <a class="el" href="classHArDCore2D_1_1CurlBasis.html">CurlBasis</a>&lt; BasisType1 &gt; &amp;basis1, const <a class="el" href="classHArDCore2D_1_1CurlBasis.html">CurlBasis</a>&lt; BasisType2 &gt; &amp;basis2, <a class="el" href="group__Quadratures.html#ga4255c52c7d9ac1165c0a37da8970feb6">MonomialCellIntegralsType</a> mono_int_map={})</td></tr>
<tr class="memdesc:ga17710ae071fd2a88fba78507057d72a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic template to compute the Gram Matrix of a pair of Curl bases.  <a href="group__Quadratures.html#ga17710ae071fd2a88fba78507057d72a4">More...</a><br /></td></tr>
<tr class="separator:ga17710ae071fd2a88fba78507057d72a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbf2996d778a016cca5de0a433ed810c"><td class="memTemplParams" colspan="2">template&lt;typename BasisType1 , typename BasisType2 &gt; </td></tr>
<tr class="memitem:gafbf2996d778a016cca5de0a433ed810c"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#gafbf2996d778a016cca5de0a433ed810c">HArDCore2D::GramMatrix</a> (const Cell &amp;<a class="el" href="mmread_8m.html#a688dbf4d8b443317cfd5b5abbc137402">T</a>, const <a class="el" href="classHArDCore2D_1_1CurlBasis.html">CurlBasis</a>&lt; BasisType1 &gt; &amp;curl_basis, const <a class="el" href="classHArDCore2D_1_1TensorizedVectorFamily.html">TensorizedVectorFamily</a>&lt; BasisType2, 2 &gt; &amp;tens_family, <a class="el" href="group__Quadratures.html#ga4255c52c7d9ac1165c0a37da8970feb6">MonomialCellIntegralsType</a> mono_int_map={})</td></tr>
<tr class="memdesc:gafbf2996d778a016cca5de0a433ed810c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template to compute the Gram Matrix of a curl basis and a tensorized scalar basis.  <a href="group__Quadratures.html#gafbf2996d778a016cca5de0a433ed810c">More...</a><br /></td></tr>
<tr class="separator:gafbf2996d778a016cca5de0a433ed810c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf23238b30a3a668643d281bb4d1058a"><td class="memTemplParams" colspan="2">template&lt;typename BasisType1 , typename BasisType2 , size_t N&gt; </td></tr>
<tr class="memitem:gabf23238b30a3a668643d281bb4d1058a"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#gabf23238b30a3a668643d281bb4d1058a">HArDCore2D::GramMatrix</a> (const Cell &amp;<a class="el" href="mmread_8m.html#a688dbf4d8b443317cfd5b5abbc137402">T</a>, const <a class="el" href="classHArDCore2D_1_1TensorizedVectorFamily.html">TensorizedVectorFamily</a>&lt; BasisType1, N &gt; &amp;tens_family, const <a class="el" href="classHArDCore2D_1_1CurlBasis.html">CurlBasis</a>&lt; BasisType2 &gt; &amp;curl_basis, <a class="el" href="group__Quadratures.html#ga4255c52c7d9ac1165c0a37da8970feb6">MonomialCellIntegralsType</a> mono_int_map={})</td></tr>
<tr class="memdesc:gabf23238b30a3a668643d281bb4d1058a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template to compute the Gram Matrix of a tensorized scalar basis and a gradient basis.  <a href="group__Quadratures.html#gabf23238b30a3a668643d281bb4d1058a">More...</a><br /></td></tr>
<tr class="separator:gabf23238b30a3a668643d281bb4d1058a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ce8130be73467716a0860ef973ac9c2"><td class="memTemplParams" colspan="2">template&lt;typename BasisType1 , typename BasisType2 &gt; </td></tr>
<tr class="memitem:ga8ce8130be73467716a0860ef973ac9c2"><td class="memTemplItemLeft" align="right" valign="top">boost::disable_if&lt; boost::is_same&lt; BasisType2, <a class="el" href="group__Quadratures.html#ga4255c52c7d9ac1165c0a37da8970feb6">MonomialCellIntegralsType</a> &gt;, Eigen::MatrixXd &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#ga8ce8130be73467716a0860ef973ac9c2">HArDCore2D::GramMatrix</a> (const Cell &amp;<a class="el" href="mmread_8m.html#a688dbf4d8b443317cfd5b5abbc137402">T</a>, const <a class="el" href="classHArDCore2D_1_1DivergenceBasis.html">DivergenceBasis</a>&lt; BasisType1 &gt; &amp;basis1, const BasisType2 &amp;basis2, <a class="el" href="group__Quadratures.html#ga4255c52c7d9ac1165c0a37da8970feb6">MonomialCellIntegralsType</a> mono_int_map={})</td></tr>
<tr class="memdesc:ga8ce8130be73467716a0860ef973ac9c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic template to compute the Gram Matrix of a Divergence basis and any other basis.  <a href="group__Quadratures.html#ga8ce8130be73467716a0860ef973ac9c2">More...</a><br /></td></tr>
<tr class="separator:ga8ce8130be73467716a0860ef973ac9c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad86d675b9a66959c9af5672e6bbd1840"><td class="memTemplParams" colspan="2">template&lt;typename BasisType1 , typename Basis2 &gt; </td></tr>
<tr class="memitem:gad86d675b9a66959c9af5672e6bbd1840"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#gad86d675b9a66959c9af5672e6bbd1840">HArDCore2D::GramMatrix</a> (const Cell &amp;<a class="el" href="mmread_8m.html#a688dbf4d8b443317cfd5b5abbc137402">T</a>, const BasisType1 &amp;basis1, const <a class="el" href="classHArDCore2D_1_1DivergenceBasis.html">DivergenceBasis</a>&lt; Basis2 &gt; &amp;basis2, <a class="el" href="group__Quadratures.html#ga4255c52c7d9ac1165c0a37da8970feb6">MonomialCellIntegralsType</a> mono_int_map={})</td></tr>
<tr class="memdesc:gad86d675b9a66959c9af5672e6bbd1840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template to compute the Gram Matrix of any basis and a Divergence basis.  <a href="group__Quadratures.html#gad86d675b9a66959c9af5672e6bbd1840">More...</a><br /></td></tr>
<tr class="separator:gad86d675b9a66959c9af5672e6bbd1840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f61ecdc92b839db14767e7a33f0ac18"><td class="memTemplParams" colspan="2">template&lt;typename BasisType1 &gt; </td></tr>
<tr class="memitem:ga7f61ecdc92b839db14767e7a33f0ac18"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#ga7f61ecdc92b839db14767e7a33f0ac18">HArDCore2D::GramMatrixDiv</a> (const Cell &amp;<a class="el" href="mmread_8m.html#a688dbf4d8b443317cfd5b5abbc137402">T</a>, const <a class="el" href="classHArDCore2D_1_1TensorizedVectorFamily.html">TensorizedVectorFamily</a>&lt; BasisType1, 2 &gt; &amp;basis1, const <a class="el" href="classHArDCore2D_1_1MonomialScalarBasisCell.html">MonomialScalarBasisCell</a> &amp;basis2, <a class="el" href="group__Quadratures.html#ga4255c52c7d9ac1165c0a37da8970feb6">MonomialCellIntegralsType</a> mono_int_map={})</td></tr>
<tr class="memdesc:ga7f61ecdc92b839db14767e7a33f0ac18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template to compute the Gram Matrix of a Divergence&lt;Tensorized&gt; basis and a monomial scalar basis.  <a href="group__Quadratures.html#ga7f61ecdc92b839db14767e7a33f0ac18">More...</a><br /></td></tr>
<tr class="separator:ga7f61ecdc92b839db14767e7a33f0ac18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccf0b34c06ff46478c7453db832aa5f7"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#gaccf0b34c06ff46478c7453db832aa5f7">HArDCore2D::GramMatrixDiv</a> (const Cell &amp;<a class="el" href="mmread_8m.html#a688dbf4d8b443317cfd5b5abbc137402">T</a>, const <a class="el" href="classHArDCore2D_1_1RolyComplBasisCell.html">RolyComplBasisCell</a> &amp;basis1, const <a class="el" href="classHArDCore2D_1_1MonomialScalarBasisCell.html">MonomialScalarBasisCell</a> &amp;basis2, <a class="el" href="group__Quadratures.html#ga4255c52c7d9ac1165c0a37da8970feb6">MonomialCellIntegralsType</a> mono_int_map={})</td></tr>
<tr class="memdesc:gaccf0b34c06ff46478c7453db832aa5f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Gram Matrix of a Divergence&lt;RolyCompl&gt; basis and a monomial scalar basis.  <a href="group__Quadratures.html#gaccf0b34c06ff46478c7453db832aa5f7">More...</a><br /></td></tr>
<tr class="separator:gaccf0b34c06ff46478c7453db832aa5f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ce073e602b788098cdf24efab030ede"><td class="memTemplParams" colspan="2">template&lt;typename BasisType1 , typename BasisType2 &gt; </td></tr>
<tr class="memitem:ga7ce073e602b788098cdf24efab030ede"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#ga7ce073e602b788098cdf24efab030ede">HArDCore2D::GramMatrixDiv</a> (const Cell &amp;<a class="el" href="mmread_8m.html#a688dbf4d8b443317cfd5b5abbc137402">T</a>, const BasisType1 &amp;basis1, const BasisType2 &amp;basis2, <a class="el" href="group__Quadratures.html#ga4255c52c7d9ac1165c0a37da8970feb6">MonomialCellIntegralsType</a> mono_int_map={})</td></tr>
<tr class="memdesc:ga7ce073e602b788098cdf24efab030ede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template to compute the Gram Matrix of the divergence of any basis and any other basis.  <a href="group__Quadratures.html#ga7ce073e602b788098cdf24efab030ede">More...</a><br /></td></tr>
<tr class="separator:ga7ce073e602b788098cdf24efab030ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64ad96ee99f7b62a7ef1757b12701323"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Quadratures.html#ga1d89d9fdcd5599eefd37c35fbf28bd94">MonomialEdgeIntegralsType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#ga64ad96ee99f7b62a7ef1757b12701323">HArDCore2D::IntegrateEdgeMonomials</a> (const Edge &amp;E, const size_t maxdeg)</td></tr>
<tr class="memdesc:ga64ad96ee99f7b62a7ef1757b12701323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute all integrals of edge monomials up to a total degree.  <a href="group__Quadratures.html#ga64ad96ee99f7b62a7ef1757b12701323">More...</a><br /></td></tr>
<tr class="separator:ga64ad96ee99f7b62a7ef1757b12701323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga638b9609e4b26cf2fbd164018b12bccd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Quadratures.html#ga1d89d9fdcd5599eefd37c35fbf28bd94">MonomialEdgeIntegralsType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#ga638b9609e4b26cf2fbd164018b12bccd">HArDCore2D::CheckIntegralsDegree</a> (const Edge &amp;E, const size_t degree, const <a class="el" href="group__Quadratures.html#ga1d89d9fdcd5599eefd37c35fbf28bd94">MonomialEdgeIntegralsType</a> &amp;mono_int_map={})</td></tr>
<tr class="memdesc:ga638b9609e4b26cf2fbd164018b12bccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the degree of an existing list of monomial integrals is sufficient, other re-compute and return a proper list.  <a href="group__Quadratures.html#ga638b9609e4b26cf2fbd164018b12bccd">More...</a><br /></td></tr>
<tr class="separator:ga638b9609e4b26cf2fbd164018b12bccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6978f567aa9a5cadb0b49bfcc2f6c5bf"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#ga6978f567aa9a5cadb0b49bfcc2f6c5bf">HArDCore2D::GramMatrix</a> (const Edge &amp;E, const <a class="el" href="classHArDCore2D_1_1MonomialScalarBasisEdge.html">MonomialScalarBasisEdge</a> &amp;basis1, const <a class="el" href="classHArDCore2D_1_1MonomialScalarBasisEdge.html">MonomialScalarBasisEdge</a> &amp;basis2, <a class="el" href="group__Quadratures.html#ga1d89d9fdcd5599eefd37c35fbf28bd94">MonomialEdgeIntegralsType</a> mono_int_map={})</td></tr>
<tr class="memdesc:ga6978f567aa9a5cadb0b49bfcc2f6c5bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Gram Matrix of a pair of local scalar monomial bases.  <a href="group__Quadratures.html#ga6978f567aa9a5cadb0b49bfcc2f6c5bf">More...</a><br /></td></tr>
<tr class="separator:ga6978f567aa9a5cadb0b49bfcc2f6c5bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34fc04e0390fca0496bf102a704a01cf"><td class="memTemplParams" colspan="2">template&lt;typename BasisType1 , typename BasisType2 &gt; </td></tr>
<tr class="memitem:ga34fc04e0390fca0496bf102a704a01cf"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#ga34fc04e0390fca0496bf102a704a01cf">HArDCore2D::GramMatrix</a> (const Edge &amp;E, const BasisType1 &amp;basis1, const BasisType2 &amp;basis2, <a class="el" href="group__Quadratures.html#ga1d89d9fdcd5599eefd37c35fbf28bd94">MonomialEdgeIntegralsType</a> mono_int_map={})</td></tr>
<tr class="memdesc:ga34fc04e0390fca0496bf102a704a01cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic template to compute the Gram Matrix of any pair of bases.  <a href="group__Quadratures.html#ga34fc04e0390fca0496bf102a704a01cf">More...</a><br /></td></tr>
<tr class="separator:ga34fc04e0390fca0496bf102a704a01cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd68df6b58e403a6bd8537d6bbd72ad9"><td class="memTemplParams" colspan="2">template&lt;typename BasisType &gt; </td></tr>
<tr class="memitem:gabd68df6b58e403a6bd8537d6bbd72ad9"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#gabd68df6b58e403a6bd8537d6bbd72ad9">HArDCore2D::GramMatrix</a> (const Edge &amp;E, const BasisType &amp;basis, <a class="el" href="group__Quadratures.html#ga1d89d9fdcd5599eefd37c35fbf28bd94">MonomialEdgeIntegralsType</a> mono_int_map={})</td></tr>
<tr class="memdesc:gabd68df6b58e403a6bd8537d6bbd72ad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This overload to simplify the call to GramMatrix in case the two bases are the same.  <a href="group__Quadratures.html#gabd68df6b58e403a6bd8537d6bbd72ad9">More...</a><br /></td></tr>
<tr class="separator:gabd68df6b58e403a6bd8537d6bbd72ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95718eefc0efe913a4bb4b2ce2a95856"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#ga95718eefc0efe913a4bb4b2ce2a95856">HArDCore2D::GMDer</a> (const Edge &amp;E, const <a class="el" href="classHArDCore2D_1_1MonomialScalarBasisEdge.html">MonomialScalarBasisEdge</a> &amp;basis1, const <a class="el" href="classHArDCore2D_1_1MonomialScalarBasisEdge.html">MonomialScalarBasisEdge</a> &amp;basis2, <a class="el" href="group__Quadratures.html#ga1d89d9fdcd5599eefd37c35fbf28bd94">MonomialEdgeIntegralsType</a> mono_int_map={})</td></tr>
<tr class="memdesc:ga95718eefc0efe913a4bb4b2ce2a95856"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Gram Matrix of the derivative of a monomial basis with another monomial basis.  <a href="group__Quadratures.html#ga95718eefc0efe913a4bb4b2ce2a95856">More...</a><br /></td></tr>
<tr class="separator:ga95718eefc0efe913a4bb4b2ce2a95856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefd49a7b35f77c7c50a784e977186240"><td class="memTemplParams" colspan="2">template&lt;typename BasisType1 , typename BasisType2 &gt; </td></tr>
<tr class="memitem:gaefd49a7b35f77c7c50a784e977186240"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#gaefd49a7b35f77c7c50a784e977186240">HArDCore2D::GMDer</a> (const Edge &amp;E, const BasisType1 &amp;basis1, const BasisType2 &amp;basis2, <a class="el" href="group__Quadratures.html#ga1d89d9fdcd5599eefd37c35fbf28bd94">MonomialEdgeIntegralsType</a> mono_int_map={})</td></tr>
<tr class="memdesc:gaefd49a7b35f77c7c50a784e977186240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic template for GMDer with derived bases.  <a href="group__Quadratures.html#gaefd49a7b35f77c7c50a784e977186240">More...</a><br /></td></tr>
<tr class="separator:gaefd49a7b35f77c7c50a784e977186240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87117c05c9d43b8399fe6808319f3ca9"><td class="memTemplParams" colspan="2">template&lt;typename BasisType1 , typename BasisType2 &gt; </td></tr>
<tr class="memitem:ga87117c05c9d43b8399fe6808319f3ca9"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#ga87117c05c9d43b8399fe6808319f3ca9">HArDCore2D::GramMatrix</a> (const Edge &amp;E, const <a class="el" href="classHArDCore2D_1_1GradientBasis.html">GradientBasis</a>&lt; BasisType1 &gt; &amp;basis1, const BasisType2 &amp;basis2, <a class="el" href="group__Quadratures.html#ga1d89d9fdcd5599eefd37c35fbf28bd94">MonomialEdgeIntegralsType</a> mono_int_map={})</td></tr>
<tr class="memdesc:ga87117c05c9d43b8399fe6808319f3ca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Gram Matrix of a gradient basis (considering the tangential gradient as a scalar) and a scalar basis.  <a href="group__Quadratures.html#ga87117c05c9d43b8399fe6808319f3ca9">More...</a><br /></td></tr>
<tr class="separator:ga87117c05c9d43b8399fe6808319f3ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f769fe1855d993dc8c669866176cf33"><td class="memTemplParams" colspan="2">template&lt;typename BasisType1 , typename BasisType2 &gt; </td></tr>
<tr class="memitem:ga5f769fe1855d993dc8c669866176cf33"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#ga5f769fe1855d993dc8c669866176cf33">HArDCore2D::GramMatrix</a> (const Edge &amp;E, const BasisType1 &amp;basis1, const <a class="el" href="classHArDCore2D_1_1GradientBasis.html">GradientBasis</a>&lt; BasisType2 &gt; &amp;basis2, <a class="el" href="group__Quadratures.html#ga1d89d9fdcd5599eefd37c35fbf28bd94">MonomialEdgeIntegralsType</a> mono_int_map={})</td></tr>
<tr class="memdesc:ga5f769fe1855d993dc8c669866176cf33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Gram Matrix of a scalar basis and a gradient basis (considering the tangential gradient as a scalar)  <a href="group__Quadratures.html#ga5f769fe1855d993dc8c669866176cf33">More...</a><br /></td></tr>
<tr class="separator:ga5f769fe1855d993dc8c669866176cf33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb254b22a706f3781b2b8a7b3fafa288"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#gabb254b22a706f3781b2b8a7b3fafa288">HArDCore2D::QuadRuleEdge::QuadRuleEdge</a> (size_t doe, bool warn)</td></tr>
<tr class="separator:gabb254b22a706f3781b2b8a7b3fafa288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b5c5c3ca8408bc40a5c150f48ee2ca8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#ga4b5c5c3ca8408bc40a5c150f48ee2ca8">HArDCore2D::QuadRuleEdge::~QuadRuleEdge</a> ()</td></tr>
<tr class="separator:ga4b5c5c3ca8408bc40a5c150f48ee2ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf245dd9ab99a15742641d81f5508041a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#gaf245dd9ab99a15742641d81f5508041a">HArDCore2D::QuadRuleEdge::nq</a> ()</td></tr>
<tr class="separator:gaf245dd9ab99a15742641d81f5508041a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b03cf6a6800470a027f570d44338a1f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#ga1b03cf6a6800470a027f570d44338a1f">HArDCore2D::QuadRuleEdge::xq</a> (size_t <a class="el" href="mmread_8m.html#aeca839551793b48163d805c13e7ecf30">i</a>)</td></tr>
<tr class="separator:ga1b03cf6a6800470a027f570d44338a1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac272eee335dc95a46787e1a054b38cb7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#gac272eee335dc95a46787e1a054b38cb7">HArDCore2D::QuadRuleEdge::yq</a> (size_t <a class="el" href="mmread_8m.html#aeca839551793b48163d805c13e7ecf30">i</a>)</td></tr>
<tr class="separator:gac272eee335dc95a46787e1a054b38cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fc5a686c8018dbea8ec3a120ad6d9bc"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#ga3fc5a686c8018dbea8ec3a120ad6d9bc">HArDCore2D::QuadRuleEdge::wq</a> (size_t <a class="el" href="mmread_8m.html#aeca839551793b48163d805c13e7ecf30">i</a>)</td></tr>
<tr class="separator:ga3fc5a686c8018dbea8ec3a120ad6d9bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56ca5d37f1c93f74aba256e310392d00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#ga56ca5d37f1c93f74aba256e310392d00">HArDCore2D::QuadRuleEdge::setup</a> (double xV[], double yV[])</td></tr>
<tr class="separator:ga56ca5d37f1c93f74aba256e310392d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4df4c78f50b0116cb68151073a45e08a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#ga4df4c78f50b0116cb68151073a45e08a">HArDCore2D::LegendreGauss::LegendreGauss</a> (size_t doe)</td></tr>
<tr class="separator:ga4df4c78f50b0116cb68151073a45e08a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cab982a50db6cc4f4ff1d7ed71deb09"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#ga4cab982a50db6cc4f4ff1d7ed71deb09">HArDCore2D::LegendreGauss::~LegendreGauss</a> ()</td></tr>
<tr class="separator:ga4cab982a50db6cc4f4ff1d7ed71deb09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa60072df54f7acc9bad7362e4d6f6f72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#gaa60072df54f7acc9bad7362e4d6f6f72">HArDCore2D::LegendreGauss::sub_rule_01</a> ()</td></tr>
<tr class="separator:gaa60072df54f7acc9bad7362e4d6f6f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b20f2cc13f96879fe731e3411e118cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#ga3b20f2cc13f96879fe731e3411e118cf">HArDCore2D::LegendreGauss::sub_rule_02</a> ()</td></tr>
<tr class="separator:ga3b20f2cc13f96879fe731e3411e118cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ee58d8688bfaaa7952cd7f70e06ad05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#ga0ee58d8688bfaaa7952cd7f70e06ad05">HArDCore2D::LegendreGauss::sub_rule_03</a> ()</td></tr>
<tr class="separator:ga0ee58d8688bfaaa7952cd7f70e06ad05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55751cb4eed2cd44b12fe7bcc505097a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#ga55751cb4eed2cd44b12fe7bcc505097a">HArDCore2D::LegendreGauss::sub_rule_04</a> ()</td></tr>
<tr class="separator:ga55751cb4eed2cd44b12fe7bcc505097a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4e7cbaed5cea19a7490501e67bf728b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#gaa4e7cbaed5cea19a7490501e67bf728b">HArDCore2D::LegendreGauss::sub_rule_05</a> ()</td></tr>
<tr class="separator:gaa4e7cbaed5cea19a7490501e67bf728b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff68078ed4cdc77372609b56c3fcfc2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#gaff68078ed4cdc77372609b56c3fcfc2a">HArDCore2D::LegendreGauss::sub_rule_06</a> ()</td></tr>
<tr class="separator:gaff68078ed4cdc77372609b56c3fcfc2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70452a921cb1f1eb6e30d7436102ae01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#ga70452a921cb1f1eb6e30d7436102ae01">HArDCore2D::LegendreGauss::sub_rule_07</a> ()</td></tr>
<tr class="separator:ga70452a921cb1f1eb6e30d7436102ae01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50b4238c7cade3272efe46641e1d2d3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#ga50b4238c7cade3272efe46641e1d2d3f">HArDCore2D::LegendreGauss::sub_rule_08</a> ()</td></tr>
<tr class="separator:ga50b4238c7cade3272efe46641e1d2d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6a8077dd8cf9fc76ed1234b93691049"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#gae6a8077dd8cf9fc76ed1234b93691049">HArDCore2D::LegendreGauss::sub_rule_09</a> ()</td></tr>
<tr class="separator:gae6a8077dd8cf9fc76ed1234b93691049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad37934da18110fd078f1950a575fd3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#gaad37934da18110fd078f1950a575fd3d">HArDCore2D::LegendreGauss::sub_rule_10</a> ()</td></tr>
<tr class="separator:gaad37934da18110fd078f1950a575fd3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b7095506bd1d218c28f5778c6dea545"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#ga6b7095506bd1d218c28f5778c6dea545">HArDCore2D::LegendreGauss::sub_rule_11</a> ()</td></tr>
<tr class="separator:ga6b7095506bd1d218c28f5778c6dea545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1251635135ab00a28e128a058288e440"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#ga1251635135ab00a28e128a058288e440">HArDCore2D::LegendreGauss::npts</a> ()</td></tr>
<tr class="separator:ga1251635135ab00a28e128a058288e440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2800eb7a7c2648b1edb77231ef42608a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#ga2800eb7a7c2648b1edb77231ef42608a">HArDCore2D::LegendreGauss::wq</a> (size_t <a class="el" href="mmread_8m.html#aeca839551793b48163d805c13e7ecf30">i</a>)</td></tr>
<tr class="separator:ga2800eb7a7c2648b1edb77231ef42608a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa10e032f4ea04323773b23177b4124ee"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#gaa10e032f4ea04323773b23177b4124ee">HArDCore2D::LegendreGauss::tq</a> (size_t <a class="el" href="mmread_8m.html#aeca839551793b48163d805c13e7ecf30">i</a>)</td></tr>
<tr class="separator:gaa10e032f4ea04323773b23177b4124ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae76e5c50d31061d72d153133718428bb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#gae76e5c50d31061d72d153133718428bb">HArDCore2D::QuadratureNode::QuadratureNode</a> (double <a class="el" href="group__Quadratures.html#ga628eb81f57259847bbc6250bc2fc7a47">x</a>, double <a class="el" href="group__Quadratures.html#gabd7b50c9a348283e18d94c9e4dba8982">y</a>, double <a class="el" href="group__Quadratures.html#ga5ff899e851df60680e721740e4176fc0">w</a>)</td></tr>
<tr class="separator:gae76e5c50d31061d72d153133718428bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27f8f3696a0be686ed1606dda2425da6"><td class="memItemLeft" align="right" valign="top">Eigen::Vector2d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#ga27f8f3696a0be686ed1606dda2425da6">HArDCore2D::QuadratureNode::vector</a> () const</td></tr>
<tr class="memdesc:ga27f8f3696a0be686ed1606dda2425da6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the quadrature point as an Eigen vector.  <a href="group__Quadratures.html#ga27f8f3696a0be686ed1606dda2425da6">More...</a><br /></td></tr>
<tr class="separator:ga27f8f3696a0be686ed1606dda2425da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8f643134b5bea1e323e14c5ac42aa74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Quadratures.html#ga08203d5fcf31125f46ed733ebfeac838">QuadratureRule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#gad8f643134b5bea1e323e14c5ac42aa74">HArDCore2D::generate_quadrature_rule</a> (const Cell &amp;<a class="el" href="mmread_8m.html#a688dbf4d8b443317cfd5b5abbc137402">T</a>, const int doe, const bool force_split=false)</td></tr>
<tr class="memdesc:gad8f643134b5bea1e323e14c5ac42aa74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate quadrature rule on mesh element.  <a href="group__Quadratures.html#gad8f643134b5bea1e323e14c5ac42aa74">More...</a><br /></td></tr>
<tr class="separator:gad8f643134b5bea1e323e14c5ac42aa74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e1f7c48ac0530bcb24e590a729bf3db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Quadratures.html#ga08203d5fcf31125f46ed733ebfeac838">QuadratureRule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#ga5e1f7c48ac0530bcb24e590a729bf3db">HArDCore2D::generate_quadrature_rule</a> (const Edge &amp;E, const int doe)</td></tr>
<tr class="memdesc:ga5e1f7c48ac0530bcb24e590a729bf3db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate quadrature rule on mesh face.  <a href="group__Quadratures.html#ga5e1f7c48ac0530bcb24e590a729bf3db">More...</a><br /></td></tr>
<tr class="separator:ga5e1f7c48ac0530bcb24e590a729bf3db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga628eb81f57259847bbc6250bc2fc7a47"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#ga628eb81f57259847bbc6250bc2fc7a47">HArDCore2D::QuadratureNode::x</a></td></tr>
<tr class="separator:ga628eb81f57259847bbc6250bc2fc7a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd7b50c9a348283e18d94c9e4dba8982"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#gabd7b50c9a348283e18d94c9e4dba8982">HArDCore2D::QuadratureNode::y</a></td></tr>
<tr class="separator:gabd7b50c9a348283e18d94c9e4dba8982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ff899e851df60680e721740e4176fc0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Quadratures.html#ga5ff899e851df60680e721740e4176fc0">HArDCore2D::QuadratureNode::w</a></td></tr>
<tr class="separator:ga5ff899e851df60680e721740e4176fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Classes providing quadratures on edges and in cells. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga4255c52c7d9ac1165c0a37da8970feb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4255c52c7d9ac1165c0a37da8970feb6">&#9670;&nbsp;</a></span>MonomialCellIntegralsType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::unordered_map&lt;<a class="el" href="group__Basis.html#ga2bc880baa1a6163014c7f37345bf8ac6">VectorZd</a>, double, <a class="el" href="structHArDCore2D_1_1VecHash.html">VecHash</a>&gt; <a class="el" href="group__Quadratures.html#ga4255c52c7d9ac1165c0a37da8970feb6">HArDCore2D::MonomialCellIntegralsType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for list of integrals of monomials. </p>

</div>
</div>
<a id="ga1d89d9fdcd5599eefd37c35fbf28bd94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d89d9fdcd5599eefd37c35fbf28bd94">&#9670;&nbsp;</a></span>MonomialEdgeIntegralsType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;double&gt; <a class="el" href="group__Quadratures.html#ga1d89d9fdcd5599eefd37c35fbf28bd94">HArDCore2D::MonomialEdgeIntegralsType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for list of edge integrals of monomials. </p>

</div>
</div>
<a id="ga08203d5fcf31125f46ed733ebfeac838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08203d5fcf31125f46ed733ebfeac838">&#9670;&nbsp;</a></span>QuadratureRule</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="structHArDCore2D_1_1QuadratureNode.html">QuadratureNode</a>&gt; <a class="el" href="group__Quadratures.html#ga08203d5fcf31125f46ed733ebfeac838">HArDCore2D::QuadratureRule</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga60f346b650d4c9ee3b872c72da9c9dbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60f346b650d4c9ee3b872c72da9c9dbf">&#9670;&nbsp;</a></span>CheckIntegralsDegree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Quadratures.html#ga4255c52c7d9ac1165c0a37da8970feb6">MonomialCellIntegralsType</a> HArDCore2D::CheckIntegralsDegree </td>
          <td>(</td>
          <td class="paramtype">const Cell &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__Quadratures.html#ga4255c52c7d9ac1165c0a37da8970feb6">MonomialCellIntegralsType</a> &amp;&#160;</td>
          <td class="paramname"><em>mono_int_map</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the degree of an existing list of monomial integrals is sufficient, other re-compute and return a proper list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Cell </td></tr>
    <tr><td class="paramname">degree</td><td>Expected degree </td></tr>
    <tr><td class="paramname">mono_int_map</td><td>Existing list, optional </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga638b9609e4b26cf2fbd164018b12bccd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga638b9609e4b26cf2fbd164018b12bccd">&#9670;&nbsp;</a></span>CheckIntegralsDegree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Quadratures.html#ga1d89d9fdcd5599eefd37c35fbf28bd94">MonomialEdgeIntegralsType</a> HArDCore2D::CheckIntegralsDegree </td>
          <td>(</td>
          <td class="paramtype">const Edge &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__Quadratures.html#ga1d89d9fdcd5599eefd37c35fbf28bd94">MonomialEdgeIntegralsType</a> &amp;&#160;</td>
          <td class="paramname"><em>mono_int_map</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the degree of an existing list of monomial integrals is sufficient, other re-compute and return a proper list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">E</td><td>Edge </td></tr>
    <tr><td class="paramname">degree</td><td>Expected degree </td></tr>
    <tr><td class="paramname">mono_int_map</td><td>Existing list, optional </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad8f643134b5bea1e323e14c5ac42aa74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8f643134b5bea1e323e14c5ac42aa74">&#9670;&nbsp;</a></span>generate_quadrature_rule() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Quadratures.html#ga08203d5fcf31125f46ed733ebfeac838">QuadratureRule</a> HArDCore2D::generate_quadrature_rule </td>
          <td>(</td>
          <td class="paramtype">const Cell &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>doe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>force_split</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate quadrature rule on mesh element. </p>
<dl class="section return"><dt>Returns</dt><dd>list of quadrature nodes and weights </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Reference to the mesh cell </td></tr>
    <tr><td class="paramname">doe</td><td>Degree of exactness </td></tr>
    <tr><td class="paramname">force_split</td><td>TRUE if we want the quadrature nodes to be computed by forcing the splitting of the cell into triangles based on its center of mass and edges (otherwise, for simple cells, quadrature nodes are computed by splitting in fewer triangles) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5e1f7c48ac0530bcb24e590a729bf3db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e1f7c48ac0530bcb24e590a729bf3db">&#9670;&nbsp;</a></span>generate_quadrature_rule() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Quadratures.html#ga08203d5fcf31125f46ed733ebfeac838">QuadratureRule</a> HArDCore2D::generate_quadrature_rule </td>
          <td>(</td>
          <td class="paramtype">const Edge &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>doe</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate quadrature rule on mesh face. </p>
<dl class="section return"><dt>Returns</dt><dd>list of quadrature nodes and weights </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">E</td><td>Reference to the mesh face </td></tr>
    <tr><td class="paramname">doe</td><td>Degree of exactness </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaefd49a7b35f77c7c50a784e977186240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaefd49a7b35f77c7c50a784e977186240">&#9670;&nbsp;</a></span>GMDer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisType1 , typename BasisType2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::GMDer </td>
          <td>(</td>
          <td class="paramtype">const Edge &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BasisType1 &amp;&#160;</td>
          <td class="paramname"><em>basis1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BasisType2 &amp;&#160;</td>
          <td class="paramname"><em>basis2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Quadratures.html#ga1d89d9fdcd5599eefd37c35fbf28bd94">MonomialEdgeIntegralsType</a>&#160;</td>
          <td class="paramname"><em>mono_int_map</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic template for GMDer with derived bases. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">E</td><td>Edge to which the basis corresponds </td></tr>
    <tr><td class="paramname">basis1</td><td>First basis (rows of the Gram matrix), to be differentiated </td></tr>
    <tr><td class="paramname">basis2</td><td>Second basis (columns of the Gram matrix) </td></tr>
    <tr><td class="paramname">mono_int_map</td><td>Optional list of integrals of monomials up to the sum of max degree of basis1 and basis2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga95718eefc0efe913a4bb4b2ce2a95856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95718eefc0efe913a4bb4b2ce2a95856">&#9670;&nbsp;</a></span>GMDer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::GMDer </td>
          <td>(</td>
          <td class="paramtype">const Edge &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHArDCore2D_1_1MonomialScalarBasisEdge.html">MonomialScalarBasisEdge</a> &amp;&#160;</td>
          <td class="paramname"><em>basis1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHArDCore2D_1_1MonomialScalarBasisEdge.html">MonomialScalarBasisEdge</a> &amp;&#160;</td>
          <td class="paramname"><em>basis2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Quadratures.html#ga1d89d9fdcd5599eefd37c35fbf28bd94">MonomialEdgeIntegralsType</a>&#160;</td>
          <td class="paramname"><em>mono_int_map</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Gram Matrix of the derivative of a monomial basis with another monomial basis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">E</td><td>Edge to which the basis corresponds </td></tr>
    <tr><td class="paramname">basis1</td><td>First basis, to be differentiated </td></tr>
    <tr><td class="paramname">basis2</td><td>Second basis </td></tr>
    <tr><td class="paramname">mono_int_map</td><td>Optional list of integrals of monomials up to the sum of max degree of basis1 and basis2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7fe74b21dbcf4950c56050bc3210d791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fe74b21dbcf4950c56050bc3210d791">&#9670;&nbsp;</a></span>GMRolyComplScalar() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::GMRolyComplScalar </td>
          <td>(</td>
          <td class="paramtype">const Cell &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHArDCore2D_1_1RolyComplBasisCell.html">RolyComplBasisCell</a> &amp;&#160;</td>
          <td class="paramname"><em>basis1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BasisType &amp;&#160;</td>
          <td class="paramname"><em>basis2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Quadratures.html#ga4255c52c7d9ac1165c0a37da8970feb6">MonomialCellIntegralsType</a>&#160;</td>
          <td class="paramname"><em>mono_int_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic template to compute the Gram Matrix of the mth component of a RolyCompl Basis and any basis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Cell to which the basis corresponds </td></tr>
    <tr><td class="paramname">basis1</td><td>First basis </td></tr>
    <tr><td class="paramname">basis2</td><td>Second basis (columns of the Gram matrix) </td></tr>
    <tr><td class="paramname">m</td><td>Differentiate basis1 with respect to the mth variable </td></tr>
    <tr><td class="paramname">mono_int_map</td><td>list of integrals of monomials up to the sum of max degree of basis1 and basis2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga88aa870647c37965633a03996c000cd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88aa870647c37965633a03996c000cd2">&#9670;&nbsp;</a></span>GMRolyComplScalar() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::GMRolyComplScalar </td>
          <td>(</td>
          <td class="paramtype">const Cell &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHArDCore2D_1_1RolyComplBasisCell.html">RolyComplBasisCell</a> &amp;&#160;</td>
          <td class="paramname"><em>rolycompl_basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHArDCore2D_1_1MonomialScalarBasisCell.html">MonomialScalarBasisCell</a> &amp;&#160;</td>
          <td class="paramname"><em>mono_basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Quadratures.html#ga4255c52c7d9ac1165c0a37da8970feb6">MonomialCellIntegralsType</a>&#160;</td>
          <td class="paramname"><em>mono_int_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Gram Matrix of the mth component of a RolyCompl Basis and a monomial basis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Cell to which the basis corresponds </td></tr>
    <tr><td class="paramname">rolycompl_basis</td><td>First basis </td></tr>
    <tr><td class="paramname">mono_basis</td><td>Second basis </td></tr>
    <tr><td class="paramname">m</td><td>Add one to the power of the mth variable </td></tr>
    <tr><td class="paramname">mono_int_map</td><td>list of integrals of monomials up to the sum of max degree of basis1 and basis2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga15f404c82e3763df19dc0f42d054fd7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15f404c82e3763df19dc0f42d054fd7f">&#9670;&nbsp;</a></span>GMScalarDerivative() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisType1 , typename BasisType2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::GMScalarDerivative </td>
          <td>(</td>
          <td class="paramtype">const Cell &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BasisType1 &amp;&#160;</td>
          <td class="paramname"><em>basis1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BasisType2 &amp;&#160;</td>
          <td class="paramname"><em>basis2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Quadratures.html#ga4255c52c7d9ac1165c0a37da8970feb6">MonomialCellIntegralsType</a>&#160;</td>
          <td class="paramname"><em>mono_int_map</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic template to compute the Gram Matrix of any pair of scalar bases, taking partial derivatives of each of them (w.r.t. the homogeneous coordinates, without scaling) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Cell to which the basis corresponds </td></tr>
    <tr><td class="paramname">basis1</td><td>First basis (rows of the Gram matrix) </td></tr>
    <tr><td class="paramname">basis2</td><td>Second basis (columns of the Gram matrix) </td></tr>
    <tr><td class="paramname">m</td><td>Differentiate basis1 with respect to the mth variable </td></tr>
    <tr><td class="paramname">l</td><td>Differentiate basis2 with respect to the lth variable </td></tr>
    <tr><td class="paramname">mono_int_map</td><td>Optional list of integrals of monomials up to the sum of max degree of basis1 and basis2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa1a862ee9dfdf66d4324a3e301f355c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1a862ee9dfdf66d4324a3e301f355c8">&#9670;&nbsp;</a></span>GMScalarDerivative() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisType1 , typename BasisType2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::GMScalarDerivative </td>
          <td>(</td>
          <td class="paramtype">const Cell &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BasisType1 &amp;&#160;</td>
          <td class="paramname"><em>basis1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BasisType2 &amp;&#160;</td>
          <td class="paramname"><em>basis2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Quadratures.html#ga4255c52c7d9ac1165c0a37da8970feb6">MonomialCellIntegralsType</a>&#160;</td>
          <td class="paramname"><em>mono_int_map</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic template to compute the Gram Matrix of any pair of scalar bases, taking a partial derivative of the first (w.r.t. the homogeneous coordinates, without scaling) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Cell to which the basis corresponds </td></tr>
    <tr><td class="paramname">basis1</td><td>First basis (rows of the Gram matrix) </td></tr>
    <tr><td class="paramname">basis2</td><td>Second basis (columns of the Gram matrix) </td></tr>
    <tr><td class="paramname">m</td><td>Differentiate basis1 with respect to the mth variable </td></tr>
    <tr><td class="paramname">mono_int_map</td><td>Optional list of integrals of monomials up to the sum of max degree of basis1 and basis2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga185787c20259379014daf6cf8891d1bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga185787c20259379014daf6cf8891d1bc">&#9670;&nbsp;</a></span>GMScalarDerivative() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::GMScalarDerivative </td>
          <td>(</td>
          <td class="paramtype">const Cell &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHArDCore2D_1_1MonomialScalarBasisCell.html">MonomialScalarBasisCell</a> &amp;&#160;</td>
          <td class="paramname"><em>basis1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHArDCore2D_1_1MonomialScalarBasisCell.html">MonomialScalarBasisCell</a> &amp;&#160;</td>
          <td class="paramname"><em>basis2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Quadratures.html#ga4255c52c7d9ac1165c0a37da8970feb6">MonomialCellIntegralsType</a>&#160;</td>
          <td class="paramname"><em>mono_int_map</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Gram Matrix of a pair of local scalar monomial bases, taking partial derivatives of each of them (w.r.t. the homogeneous coordinates, without scaling) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Cell to which the basis corresponds </td></tr>
    <tr><td class="paramname">basis1</td><td>First basis </td></tr>
    <tr><td class="paramname">basis2</td><td>Second basis </td></tr>
    <tr><td class="paramname">m</td><td>Differentiate basis1 with respect to the mth variable </td></tr>
    <tr><td class="paramname">l</td><td>Differentiate basis2 with respect to the lth variable </td></tr>
    <tr><td class="paramname">mono_int_map</td><td>Optional list of integrals of monomials up to the sum of max degree of basis1 and basis2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga62df9455eba21fadd7a3bb612cc824fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62df9455eba21fadd7a3bb612cc824fd">&#9670;&nbsp;</a></span>GMScalarDerivative() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::GMScalarDerivative </td>
          <td>(</td>
          <td class="paramtype">const Cell &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHArDCore2D_1_1MonomialScalarBasisCell.html">MonomialScalarBasisCell</a> &amp;&#160;</td>
          <td class="paramname"><em>basis1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHArDCore2D_1_1MonomialScalarBasisCell.html">MonomialScalarBasisCell</a> &amp;&#160;</td>
          <td class="paramname"><em>basis2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Quadratures.html#ga4255c52c7d9ac1165c0a37da8970feb6">MonomialCellIntegralsType</a>&#160;</td>
          <td class="paramname"><em>mono_int_map</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Gram Matrix of a pair of local scalar monomial bases, taking a partial derivative of the first (w.r.t. the homogeneous coordinates, without scaling) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Cell to which the basis corresponds </td></tr>
    <tr><td class="paramname">basis1</td><td>First basis </td></tr>
    <tr><td class="paramname">basis2</td><td>Second basis </td></tr>
    <tr><td class="paramname">m</td><td>Differentiate basis1 with respect to the mth variable </td></tr>
    <tr><td class="paramname">mono_int_map</td><td>Optional list of integrals of monomials up to the sum of max degree of basis1 and basis2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2c2c614308b041e3f2f1616c69ee2061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c2c614308b041e3f2f1616c69ee2061">&#9670;&nbsp;</a></span>GramMatrix() <span class="overload">[1/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::GramMatrix </td>
          <td>(</td>
          <td class="paramtype">const Cell &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BasisType &amp;&#160;</td>
          <td class="paramname"><em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Quadratures.html#ga4255c52c7d9ac1165c0a37da8970feb6">MonomialCellIntegralsType</a>&#160;</td>
          <td class="paramname"><em>mono_int_map</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This overload to simplify the call to GramMatrix in case the two bases are the same. </p>

</div>
</div>
<a id="gaddbeb84aa508db65d7d8bf5723d2de40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaddbeb84aa508db65d7d8bf5723d2de40">&#9670;&nbsp;</a></span>GramMatrix() <span class="overload">[2/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisType1 , typename BasisType2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::GramMatrix </td>
          <td>(</td>
          <td class="paramtype">const Cell &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BasisType1 &amp;&#160;</td>
          <td class="paramname"><em>basis1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BasisType2 &amp;&#160;</td>
          <td class="paramname"><em>basis2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Quadratures.html#ga4255c52c7d9ac1165c0a37da8970feb6">MonomialCellIntegralsType</a>&#160;</td>
          <td class="paramname"><em>mono_int_map</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic template to compute the Gram Matrix of any pair of bases. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Cell to which the basis corresponds </td></tr>
    <tr><td class="paramname">basis1</td><td>First basis (rows of the Gram matrix) </td></tr>
    <tr><td class="paramname">basis2</td><td>Second basis (columns of the Gram matrix) </td></tr>
    <tr><td class="paramname">mono_int_map</td><td>Optional list of integrals of monomials up to the sum of max degree of basis1 and basis2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad86d675b9a66959c9af5672e6bbd1840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad86d675b9a66959c9af5672e6bbd1840">&#9670;&nbsp;</a></span>GramMatrix() <span class="overload">[3/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisType1 , typename Basis2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::GramMatrix </td>
          <td>(</td>
          <td class="paramtype">const Cell &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BasisType1 &amp;&#160;</td>
          <td class="paramname"><em>basis1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHArDCore2D_1_1DivergenceBasis.html">DivergenceBasis</a>&lt; Basis2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>basis2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Quadratures.html#ga4255c52c7d9ac1165c0a37da8970feb6">MonomialCellIntegralsType</a>&#160;</td>
          <td class="paramname"><em>mono_int_map</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Template to compute the Gram Matrix of any basis and a Divergence basis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Cell to which the basis corresponds </td></tr>
    <tr><td class="paramname">basis1</td><td>First basis (tensorized basis) </td></tr>
    <tr><td class="paramname">basis2</td><td>Second basis (divergence basis) </td></tr>
    <tr><td class="paramname">mono_int_map</td><td>Optional list of integrals of monomials up to the sum of max degree of basis1 and basis2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga17710ae071fd2a88fba78507057d72a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17710ae071fd2a88fba78507057d72a4">&#9670;&nbsp;</a></span>GramMatrix() <span class="overload">[4/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisType1 , typename BasisType2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::GramMatrix </td>
          <td>(</td>
          <td class="paramtype">const Cell &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHArDCore2D_1_1CurlBasis.html">CurlBasis</a>&lt; BasisType1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>basis1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHArDCore2D_1_1CurlBasis.html">CurlBasis</a>&lt; BasisType2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>basis2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Quadratures.html#ga4255c52c7d9ac1165c0a37da8970feb6">MonomialCellIntegralsType</a>&#160;</td>
          <td class="paramname"><em>mono_int_map</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic template to compute the Gram Matrix of a pair of Curl bases. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Cell to which the basis corresponds </td></tr>
    <tr><td class="paramname">basis1</td><td>First basis </td></tr>
    <tr><td class="paramname">basis2</td><td>Second basis </td></tr>
    <tr><td class="paramname">mono_int_map</td><td>Optional list of integrals of monomials up to the sum of max degree of basis1 and basis2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafbf2996d778a016cca5de0a433ed810c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbf2996d778a016cca5de0a433ed810c">&#9670;&nbsp;</a></span>GramMatrix() <span class="overload">[5/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisType1 , typename BasisType2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::GramMatrix </td>
          <td>(</td>
          <td class="paramtype">const Cell &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHArDCore2D_1_1CurlBasis.html">CurlBasis</a>&lt; BasisType1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>curl_basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHArDCore2D_1_1TensorizedVectorFamily.html">TensorizedVectorFamily</a>&lt; BasisType2, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>tens_family</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Quadratures.html#ga4255c52c7d9ac1165c0a37da8970feb6">MonomialCellIntegralsType</a>&#160;</td>
          <td class="paramname"><em>mono_int_map</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Template to compute the Gram Matrix of a curl basis and a tensorized scalar basis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Cell to which the basis corresponds </td></tr>
    <tr><td class="paramname">curl_basis</td><td>First basis (rows of the Gram matrix) - curl basis </td></tr>
    <tr><td class="paramname">tens_family</td><td>Second basis (columns of the Gram matrix) - tensorized basis </td></tr>
    <tr><td class="paramname">mono_int_map</td><td>Optional list of integrals of monomials up to the sum of max degree of the bases </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8ce8130be73467716a0860ef973ac9c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ce8130be73467716a0860ef973ac9c2">&#9670;&nbsp;</a></span>GramMatrix() <span class="overload">[6/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisType1 , typename BasisType2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::disable_if&lt;boost::is_same&lt;BasisType2, <a class="el" href="group__Quadratures.html#ga4255c52c7d9ac1165c0a37da8970feb6">MonomialCellIntegralsType</a>&gt;, Eigen::MatrixXd&gt;::type HArDCore2D::GramMatrix </td>
          <td>(</td>
          <td class="paramtype">const Cell &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHArDCore2D_1_1DivergenceBasis.html">DivergenceBasis</a>&lt; BasisType1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>basis1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BasisType2 &amp;&#160;</td>
          <td class="paramname"><em>basis2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Quadratures.html#ga4255c52c7d9ac1165c0a37da8970feb6">MonomialCellIntegralsType</a>&#160;</td>
          <td class="paramname"><em>mono_int_map</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic template to compute the Gram Matrix of a Divergence basis and any other basis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Cell to which the basis corresponds </td></tr>
    <tr><td class="paramname">basis1</td><td>First basis (rows of the Gram matrix) </td></tr>
    <tr><td class="paramname">basis2</td><td>Second basis (columns of the Gram matrix) </td></tr>
    <tr><td class="paramname">mono_int_map</td><td>Optional list of integrals of monomials up to the sum of max degree of basis1 and basis2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaed4a8b8845e12623b679076ad2224bb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed4a8b8845e12623b679076ad2224bb7">&#9670;&nbsp;</a></span>GramMatrix() <span class="overload">[7/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::GramMatrix </td>
          <td>(</td>
          <td class="paramtype">const Cell &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHArDCore2D_1_1GolyComplBasisCell.html">GolyComplBasisCell</a> &amp;&#160;</td>
          <td class="paramname"><em>basis1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHArDCore2D_1_1GolyComplBasisCell.html">GolyComplBasisCell</a> &amp;&#160;</td>
          <td class="paramname"><em>basis2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Quadratures.html#ga4255c52c7d9ac1165c0a37da8970feb6">MonomialCellIntegralsType</a>&#160;</td>
          <td class="paramname"><em>mono_int_map</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gram Matrix of a pair of GolyCompl bases. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Cell to which the basis corresponds </td></tr>
    <tr><td class="paramname">basis1</td><td>First basis </td></tr>
    <tr><td class="paramname">basis2</td><td>Second basis </td></tr>
    <tr><td class="paramname">mono_int_map</td><td>Optional list of integrals of monomials up to the sum of max degree of basis1 and basis2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8529fc82b243f13a785e65dd7bfc68a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8529fc82b243f13a785e65dd7bfc68a0">&#9670;&nbsp;</a></span>GramMatrix() <span class="overload">[8/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisType1 , typename BasisType2 , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::GramMatrix </td>
          <td>(</td>
          <td class="paramtype">const Cell &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHArDCore2D_1_1GradientBasis.html">GradientBasis</a>&lt; BasisType1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>grad_basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHArDCore2D_1_1TensorizedVectorFamily.html">TensorizedVectorFamily</a>&lt; BasisType2, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>tens_family</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Quadratures.html#ga4255c52c7d9ac1165c0a37da8970feb6">MonomialCellIntegralsType</a>&#160;</td>
          <td class="paramname"><em>mono_int_map</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Template to compute the Gram Matrix of a gradient basis and a tensorized scalar basis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Cell to which the basis corresponds </td></tr>
    <tr><td class="paramname">grad_basis</td><td>First basis (rows of the Gram matrix) - gradient basis </td></tr>
    <tr><td class="paramname">tens_family</td><td>Second basis (columns of the Gram matrix) - tensorized basis </td></tr>
    <tr><td class="paramname">mono_int_map</td><td>Optional list of integrals of monomials up to the sum of max degree of the bases </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadbd5897527898e51c459bc762edcc990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbd5897527898e51c459bc762edcc990">&#9670;&nbsp;</a></span>GramMatrix() <span class="overload">[9/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisType1 , typename BasisType2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::GramMatrix </td>
          <td>(</td>
          <td class="paramtype">const Cell &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHArDCore2D_1_1GradientBasis.html">GradientBasis</a>&lt; BasisType1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>grad_basis1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHArDCore2D_1_1GradientBasis.html">GradientBasis</a>&lt; BasisType2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>grad_basis2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Quadratures.html#ga4255c52c7d9ac1165c0a37da8970feb6">MonomialCellIntegralsType</a>&#160;</td>
          <td class="paramname"><em>mono_int_map</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Template to compute the Gram Matrix of a gradient basis and another gradient basis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Cell to which the basis corresponds </td></tr>
    <tr><td class="paramname">grad_basis1</td><td>First basis (rows of the Gram matrix) - gradient basis </td></tr>
    <tr><td class="paramname">grad_basis2</td><td>Second basis (columns of the Gram matrix) - gradient basis </td></tr>
    <tr><td class="paramname">mono_int_map</td><td>Optional list of integrals of monomials up to the sum of max degree of the bases </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad42da5a4d0c9a05bd319723d55775266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad42da5a4d0c9a05bd319723d55775266">&#9670;&nbsp;</a></span>GramMatrix() <span class="overload">[10/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::GramMatrix </td>
          <td>(</td>
          <td class="paramtype">const Cell &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHArDCore2D_1_1MonomialScalarBasisCell.html">MonomialScalarBasisCell</a> &amp;&#160;</td>
          <td class="paramname"><em>basis1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHArDCore2D_1_1MonomialScalarBasisCell.html">MonomialScalarBasisCell</a> &amp;&#160;</td>
          <td class="paramname"><em>basis2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Quadratures.html#ga4255c52c7d9ac1165c0a37da8970feb6">MonomialCellIntegralsType</a>&#160;</td>
          <td class="paramname"><em>mono_int_map</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Gram Matrix of a pair of local scalar monomial bases. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Cell to which the basis corresponds </td></tr>
    <tr><td class="paramname">basis1</td><td>First basis </td></tr>
    <tr><td class="paramname">basis2</td><td>Second basis </td></tr>
    <tr><td class="paramname">mono_int_map</td><td>Optional list of integrals of monomials up to the sum of max degree of basis1 and basis2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga43c5fc43fd8083f5693fea6b7f96777c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43c5fc43fd8083f5693fea6b7f96777c">&#9670;&nbsp;</a></span>GramMatrix() <span class="overload">[11/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::GramMatrix </td>
          <td>(</td>
          <td class="paramtype">const Cell &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHArDCore2D_1_1RolyComplBasisCell.html">RolyComplBasisCell</a> &amp;&#160;</td>
          <td class="paramname"><em>basis1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHArDCore2D_1_1RolyComplBasisCell.html">RolyComplBasisCell</a> &amp;&#160;</td>
          <td class="paramname"><em>basis2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Quadratures.html#ga4255c52c7d9ac1165c0a37da8970feb6">MonomialCellIntegralsType</a>&#160;</td>
          <td class="paramname"><em>mono_int_map</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Gram Matrix of a pair of RolyCompl bases. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Cell to which the basis corresponds </td></tr>
    <tr><td class="paramname">basis1</td><td>First basis </td></tr>
    <tr><td class="paramname">basis2</td><td>Second basis </td></tr>
    <tr><td class="paramname">mono_int_map</td><td>Optional list of integrals of monomials up to the sum of max degree of basis1 and basis2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa49eb423dc2b11b34801402220dd5546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa49eb423dc2b11b34801402220dd5546">&#9670;&nbsp;</a></span>GramMatrix() <span class="overload">[12/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisType1 , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::GramMatrix </td>
          <td>(</td>
          <td class="paramtype">const Cell &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHArDCore2D_1_1RolyComplBasisCell.html">RolyComplBasisCell</a> &amp;&#160;</td>
          <td class="paramname"><em>rolycompl_basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHArDCore2D_1_1TensorizedVectorFamily.html">TensorizedVectorFamily</a>&lt; BasisType1, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>tens_family</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Quadratures.html#ga4255c52c7d9ac1165c0a37da8970feb6">MonomialCellIntegralsType</a>&#160;</td>
          <td class="paramname"><em>mono_int_map</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Template to compute the Gram Matrix of a RolyCompl basis and a tensorized scalar basis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Cell to which the basis corresponds </td></tr>
    <tr><td class="paramname">rolycompl_basis</td><td>First basis (RolyCompl basis) </td></tr>
    <tr><td class="paramname">tens_family</td><td>Second basis (tensorized basis) </td></tr>
    <tr><td class="paramname">mono_int_map</td><td>Optional list of integrals of monomials up to the sum of max degree of basis1 and basis2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae9d48397f244f7630124d4b4f0a38573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9d48397f244f7630124d4b4f0a38573">&#9670;&nbsp;</a></span>GramMatrix() <span class="overload">[13/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisType1 , typename BasisType2 , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::GramMatrix </td>
          <td>(</td>
          <td class="paramtype">const Cell &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHArDCore2D_1_1TensorizedVectorFamily.html">TensorizedVectorFamily</a>&lt; BasisType1, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>basis1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHArDCore2D_1_1TensorizedVectorFamily.html">TensorizedVectorFamily</a>&lt; BasisType2, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>basis2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Quadratures.html#ga4255c52c7d9ac1165c0a37da8970feb6">MonomialCellIntegralsType</a>&#160;</td>
          <td class="paramname"><em>mono_int_map</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Template to compute the Gram Matrix of any pair of tensorized scalar bases. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Cell to which the basis corresponds </td></tr>
    <tr><td class="paramname">basis1</td><td>First basis (rows of the Gram matrix) </td></tr>
    <tr><td class="paramname">basis2</td><td>Second basis (columns of the Gram matrix) </td></tr>
    <tr><td class="paramname">mono_int_map</td><td>Optional list of integrals of monomials up to the sum of max degree of basis1 and basis2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabf23238b30a3a668643d281bb4d1058a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf23238b30a3a668643d281bb4d1058a">&#9670;&nbsp;</a></span>GramMatrix() <span class="overload">[14/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisType1 , typename BasisType2 , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::GramMatrix </td>
          <td>(</td>
          <td class="paramtype">const Cell &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHArDCore2D_1_1TensorizedVectorFamily.html">TensorizedVectorFamily</a>&lt; BasisType1, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>tens_family</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHArDCore2D_1_1CurlBasis.html">CurlBasis</a>&lt; BasisType2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>curl_basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Quadratures.html#ga4255c52c7d9ac1165c0a37da8970feb6">MonomialCellIntegralsType</a>&#160;</td>
          <td class="paramname"><em>mono_int_map</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Template to compute the Gram Matrix of a tensorized scalar basis and a gradient basis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Cell to which the basis corresponds </td></tr>
    <tr><td class="paramname">tens_family</td><td>First basis (rows of the Gram matrix) - gradient basis </td></tr>
    <tr><td class="paramname">curl_basis</td><td>Second basis (columns of the Gram matrix) - tensorized basis </td></tr>
    <tr><td class="paramname">mono_int_map</td><td>Optional list of integrals of monomials up to the sum of max degree of the bases </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3f73d95c30b86a8372fbb8b1e2e0c08a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f73d95c30b86a8372fbb8b1e2e0c08a">&#9670;&nbsp;</a></span>GramMatrix() <span class="overload">[15/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisType1 , typename BasisType2 , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::GramMatrix </td>
          <td>(</td>
          <td class="paramtype">const Cell &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHArDCore2D_1_1TensorizedVectorFamily.html">TensorizedVectorFamily</a>&lt; BasisType1, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>tens_family</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHArDCore2D_1_1GradientBasis.html">GradientBasis</a>&lt; BasisType2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>grad_basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Quadratures.html#ga4255c52c7d9ac1165c0a37da8970feb6">MonomialCellIntegralsType</a>&#160;</td>
          <td class="paramname"><em>mono_int_map</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Template to compute the Gram Matrix of a tensorized scalar basis and a gradient basis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Cell to which the basis corresponds </td></tr>
    <tr><td class="paramname">tens_family</td><td>First basis (rows of the Gram matrix) - gradient basis </td></tr>
    <tr><td class="paramname">grad_basis</td><td>Second basis (columns of the Gram matrix) - tensorized basis </td></tr>
    <tr><td class="paramname">mono_int_map</td><td>Optional list of integrals of monomials up to the sum of max degree of the bases </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga16f1961718e9c2fc7d1145d64adc4bf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16f1961718e9c2fc7d1145d64adc4bf8">&#9670;&nbsp;</a></span>GramMatrix() <span class="overload">[16/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisType1 , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::GramMatrix </td>
          <td>(</td>
          <td class="paramtype">const Cell &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHArDCore2D_1_1TensorizedVectorFamily.html">TensorizedVectorFamily</a>&lt; BasisType1, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>tens_family</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHArDCore2D_1_1RolyComplBasisCell.html">RolyComplBasisCell</a> &amp;&#160;</td>
          <td class="paramname"><em>rolycompl_basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Quadratures.html#ga4255c52c7d9ac1165c0a37da8970feb6">MonomialCellIntegralsType</a>&#160;</td>
          <td class="paramname"><em>mono_int_map</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Template to compute the Gram Matrix of a tensorized scalar basis and a RolyCompl basis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Cell to which the basis corresponds </td></tr>
    <tr><td class="paramname">tens_family</td><td>First basis (tensorized basis) </td></tr>
    <tr><td class="paramname">rolycompl_basis</td><td>Second basis (RolyCompl basis) </td></tr>
    <tr><td class="paramname">mono_int_map</td><td>Optional list of integrals of monomials up to the sum of max degree of basis1 and basis2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabd68df6b58e403a6bd8537d6bbd72ad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd68df6b58e403a6bd8537d6bbd72ad9">&#9670;&nbsp;</a></span>GramMatrix() <span class="overload">[17/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::GramMatrix </td>
          <td>(</td>
          <td class="paramtype">const Edge &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BasisType &amp;&#160;</td>
          <td class="paramname"><em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Quadratures.html#ga1d89d9fdcd5599eefd37c35fbf28bd94">MonomialEdgeIntegralsType</a>&#160;</td>
          <td class="paramname"><em>mono_int_map</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This overload to simplify the call to GramMatrix in case the two bases are the same. </p>

</div>
</div>
<a id="ga34fc04e0390fca0496bf102a704a01cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34fc04e0390fca0496bf102a704a01cf">&#9670;&nbsp;</a></span>GramMatrix() <span class="overload">[18/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisType1 , typename BasisType2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::GramMatrix </td>
          <td>(</td>
          <td class="paramtype">const Edge &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BasisType1 &amp;&#160;</td>
          <td class="paramname"><em>basis1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BasisType2 &amp;&#160;</td>
          <td class="paramname"><em>basis2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Quadratures.html#ga1d89d9fdcd5599eefd37c35fbf28bd94">MonomialEdgeIntegralsType</a>&#160;</td>
          <td class="paramname"><em>mono_int_map</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic template to compute the Gram Matrix of any pair of bases. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">E</td><td>Edge to which the basis corresponds </td></tr>
    <tr><td class="paramname">basis1</td><td>First basis (rows of the Gram matrix) </td></tr>
    <tr><td class="paramname">basis2</td><td>Second basis (columns of the Gram matrix) </td></tr>
    <tr><td class="paramname">mono_int_map</td><td>Optional list of integrals of monomials up to the sum of max degree of basis1 and basis2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5f769fe1855d993dc8c669866176cf33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f769fe1855d993dc8c669866176cf33">&#9670;&nbsp;</a></span>GramMatrix() <span class="overload">[19/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisType1 , typename BasisType2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::GramMatrix </td>
          <td>(</td>
          <td class="paramtype">const Edge &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BasisType1 &amp;&#160;</td>
          <td class="paramname"><em>basis1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHArDCore2D_1_1GradientBasis.html">GradientBasis</a>&lt; BasisType2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>basis2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Quadratures.html#ga1d89d9fdcd5599eefd37c35fbf28bd94">MonomialEdgeIntegralsType</a>&#160;</td>
          <td class="paramname"><em>mono_int_map</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Gram Matrix of a scalar basis and a gradient basis (considering the tangential gradient as a scalar) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">E</td><td>Edge to which the basis corresponds </td></tr>
    <tr><td class="paramname">basis1</td><td>Scalar basis </td></tr>
    <tr><td class="paramname">basis2</td><td>Gradient basis </td></tr>
    <tr><td class="paramname">mono_int_map</td><td>Optional list of integrals of monomials up to the sum of max degree of basis1 and basis2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga87117c05c9d43b8399fe6808319f3ca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87117c05c9d43b8399fe6808319f3ca9">&#9670;&nbsp;</a></span>GramMatrix() <span class="overload">[20/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisType1 , typename BasisType2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::GramMatrix </td>
          <td>(</td>
          <td class="paramtype">const Edge &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHArDCore2D_1_1GradientBasis.html">GradientBasis</a>&lt; BasisType1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>basis1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BasisType2 &amp;&#160;</td>
          <td class="paramname"><em>basis2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Quadratures.html#ga1d89d9fdcd5599eefd37c35fbf28bd94">MonomialEdgeIntegralsType</a>&#160;</td>
          <td class="paramname"><em>mono_int_map</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Gram Matrix of a gradient basis (considering the tangential gradient as a scalar) and a scalar basis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">E</td><td>Edge to which the basis corresponds </td></tr>
    <tr><td class="paramname">basis1</td><td>Gradient basis </td></tr>
    <tr><td class="paramname">basis2</td><td>Scalar basis </td></tr>
    <tr><td class="paramname">mono_int_map</td><td>Optional list of integrals of monomials up to the sum of max degree of basis1 and basis2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6978f567aa9a5cadb0b49bfcc2f6c5bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6978f567aa9a5cadb0b49bfcc2f6c5bf">&#9670;&nbsp;</a></span>GramMatrix() <span class="overload">[21/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::GramMatrix </td>
          <td>(</td>
          <td class="paramtype">const Edge &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHArDCore2D_1_1MonomialScalarBasisEdge.html">MonomialScalarBasisEdge</a> &amp;&#160;</td>
          <td class="paramname"><em>basis1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHArDCore2D_1_1MonomialScalarBasisEdge.html">MonomialScalarBasisEdge</a> &amp;&#160;</td>
          <td class="paramname"><em>basis2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Quadratures.html#ga1d89d9fdcd5599eefd37c35fbf28bd94">MonomialEdgeIntegralsType</a>&#160;</td>
          <td class="paramname"><em>mono_int_map</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Gram Matrix of a pair of local scalar monomial bases. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">E</td><td>Edge to which the basis corresponds </td></tr>
    <tr><td class="paramname">basis1</td><td>First basis </td></tr>
    <tr><td class="paramname">basis2</td><td>Second basis </td></tr>
    <tr><td class="paramname">mono_int_map</td><td>Optional list of integrals of monomials up to the sum of max degree of basis1 and basis2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7ce073e602b788098cdf24efab030ede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ce073e602b788098cdf24efab030ede">&#9670;&nbsp;</a></span>GramMatrixDiv() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisType1 , typename BasisType2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::GramMatrixDiv </td>
          <td>(</td>
          <td class="paramtype">const Cell &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BasisType1 &amp;&#160;</td>
          <td class="paramname"><em>basis1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BasisType2 &amp;&#160;</td>
          <td class="paramname"><em>basis2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Quadratures.html#ga4255c52c7d9ac1165c0a37da8970feb6">MonomialCellIntegralsType</a>&#160;</td>
          <td class="paramname"><em>mono_int_map</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Template to compute the Gram Matrix of the divergence of any basis and any other basis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Cell to which the basis corresponds </td></tr>
    <tr><td class="paramname">basis1</td><td>First basis (vector basis) </td></tr>
    <tr><td class="paramname">basis2</td><td>Second basis (scalar basis) </td></tr>
    <tr><td class="paramname">mono_int_map</td><td>Optional list of integrals of monomials up to the sum of max degree of the bases </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaccf0b34c06ff46478c7453db832aa5f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaccf0b34c06ff46478c7453db832aa5f7">&#9670;&nbsp;</a></span>GramMatrixDiv() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::GramMatrixDiv </td>
          <td>(</td>
          <td class="paramtype">const Cell &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHArDCore2D_1_1RolyComplBasisCell.html">RolyComplBasisCell</a> &amp;&#160;</td>
          <td class="paramname"><em>basis1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHArDCore2D_1_1MonomialScalarBasisCell.html">MonomialScalarBasisCell</a> &amp;&#160;</td>
          <td class="paramname"><em>basis2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Quadratures.html#ga4255c52c7d9ac1165c0a37da8970feb6">MonomialCellIntegralsType</a>&#160;</td>
          <td class="paramname"><em>mono_int_map</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Gram Matrix of a Divergence&lt;RolyCompl&gt; basis and a monomial scalar basis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Cell to which the basis corresponds </td></tr>
    <tr><td class="paramname">basis1</td><td>First basis (RolyCompl basis) </td></tr>
    <tr><td class="paramname">basis2</td><td>Second basis (tensorized basis) </td></tr>
    <tr><td class="paramname">mono_int_map</td><td>Optional list of integrals of monomials up to the sum of max degree of basis1 and basis2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7f61ecdc92b839db14767e7a33f0ac18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f61ecdc92b839db14767e7a33f0ac18">&#9670;&nbsp;</a></span>GramMatrixDiv() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisType1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::GramMatrixDiv </td>
          <td>(</td>
          <td class="paramtype">const Cell &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHArDCore2D_1_1TensorizedVectorFamily.html">TensorizedVectorFamily</a>&lt; BasisType1, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>basis1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHArDCore2D_1_1MonomialScalarBasisCell.html">MonomialScalarBasisCell</a> &amp;&#160;</td>
          <td class="paramname"><em>basis2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Quadratures.html#ga4255c52c7d9ac1165c0a37da8970feb6">MonomialCellIntegralsType</a>&#160;</td>
          <td class="paramname"><em>mono_int_map</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Template to compute the Gram Matrix of a Divergence&lt;Tensorized&gt; basis and a monomial scalar basis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Cell to which the basis corresponds </td></tr>
    <tr><td class="paramname">basis1</td><td>First basis (divergence basis) </td></tr>
    <tr><td class="paramname">basis2</td><td>Second basis (monomial scalar basis) </td></tr>
    <tr><td class="paramname">mono_int_map</td><td>Optional list of integrals of monomials up to the sum of max degree of basis1 and basis2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8a6efbbf6ebaedd4e582f4ee965ec41d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a6efbbf6ebaedd4e582f4ee965ec41d">&#9670;&nbsp;</a></span>IntegrateCellMonomials()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Quadratures.html#ga4255c52c7d9ac1165c0a37da8970feb6">MonomialCellIntegralsType</a> HArDCore2D::IntegrateCellMonomials </td>
          <td>(</td>
          <td class="paramtype">const Cell &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>maxdeg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute all integrals on a cell of monomials up to a total degree, using vertex values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Cell </td></tr>
    <tr><td class="paramname">maxdeg</td><td>Maximal total degree </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga64ad96ee99f7b62a7ef1757b12701323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64ad96ee99f7b62a7ef1757b12701323">&#9670;&nbsp;</a></span>IntegrateEdgeMonomials()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Quadratures.html#ga1d89d9fdcd5599eefd37c35fbf28bd94">MonomialEdgeIntegralsType</a> HArDCore2D::IntegrateEdgeMonomials </td>
          <td>(</td>
          <td class="paramtype">const Edge &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>maxdeg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute all integrals of edge monomials up to a total degree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">E</td><td>Edge </td></tr>
    <tr><td class="paramname">maxdeg</td><td>Maximal total degree </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4df4c78f50b0116cb68151073a45e08a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4df4c78f50b0116cb68151073a45e08a">&#9670;&nbsp;</a></span>LegendreGauss()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LegendreGauss::LegendreGauss </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>doe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga1251635135ab00a28e128a058288e440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1251635135ab00a28e128a058288e440">&#9670;&nbsp;</a></span>npts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t LegendreGauss::npts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaf245dd9ab99a15742641d81f5508041a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf245dd9ab99a15742641d81f5508041a">&#9670;&nbsp;</a></span>nq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t QuadRuleEdge::nq </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga7acbdfebfab831a76a7f71f558808e3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7acbdfebfab831a76a7f71f558808e3f">&#9670;&nbsp;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t HArDCore2D::VecHash::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Basis.html#ga2bc880baa1a6163014c7f37345bf8ac6">VectorZd</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gae76e5c50d31061d72d153133718428bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae76e5c50d31061d72d153133718428bb">&#9670;&nbsp;</a></span>QuadratureNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HArDCore2D::QuadratureNode::QuadratureNode </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gabb254b22a706f3781b2b8a7b3fafa288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb254b22a706f3781b2b8a7b3fafa288">&#9670;&nbsp;</a></span>QuadRuleEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QuadRuleEdge::QuadRuleEdge </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>doe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>warn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga56ca5d37f1c93f74aba256e310392d00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56ca5d37f1c93f74aba256e310392d00">&#9670;&nbsp;</a></span>setup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QuadRuleEdge::setup </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xV</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yV</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaa60072df54f7acc9bad7362e4d6f6f72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa60072df54f7acc9bad7362e4d6f6f72">&#9670;&nbsp;</a></span>sub_rule_01()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LegendreGauss::sub_rule_01 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga3b20f2cc13f96879fe731e3411e118cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b20f2cc13f96879fe731e3411e118cf">&#9670;&nbsp;</a></span>sub_rule_02()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LegendreGauss::sub_rule_02 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga0ee58d8688bfaaa7952cd7f70e06ad05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ee58d8688bfaaa7952cd7f70e06ad05">&#9670;&nbsp;</a></span>sub_rule_03()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LegendreGauss::sub_rule_03 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga55751cb4eed2cd44b12fe7bcc505097a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55751cb4eed2cd44b12fe7bcc505097a">&#9670;&nbsp;</a></span>sub_rule_04()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LegendreGauss::sub_rule_04 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaa4e7cbaed5cea19a7490501e67bf728b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4e7cbaed5cea19a7490501e67bf728b">&#9670;&nbsp;</a></span>sub_rule_05()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LegendreGauss::sub_rule_05 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaff68078ed4cdc77372609b56c3fcfc2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff68078ed4cdc77372609b56c3fcfc2a">&#9670;&nbsp;</a></span>sub_rule_06()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LegendreGauss::sub_rule_06 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga70452a921cb1f1eb6e30d7436102ae01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70452a921cb1f1eb6e30d7436102ae01">&#9670;&nbsp;</a></span>sub_rule_07()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LegendreGauss::sub_rule_07 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga50b4238c7cade3272efe46641e1d2d3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50b4238c7cade3272efe46641e1d2d3f">&#9670;&nbsp;</a></span>sub_rule_08()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LegendreGauss::sub_rule_08 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gae6a8077dd8cf9fc76ed1234b93691049"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6a8077dd8cf9fc76ed1234b93691049">&#9670;&nbsp;</a></span>sub_rule_09()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LegendreGauss::sub_rule_09 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaad37934da18110fd078f1950a575fd3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad37934da18110fd078f1950a575fd3d">&#9670;&nbsp;</a></span>sub_rule_10()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LegendreGauss::sub_rule_10 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga6b7095506bd1d218c28f5778c6dea545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b7095506bd1d218c28f5778c6dea545">&#9670;&nbsp;</a></span>sub_rule_11()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LegendreGauss::sub_rule_11 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaa10e032f4ea04323773b23177b4124ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa10e032f4ea04323773b23177b4124ee">&#9670;&nbsp;</a></span>tq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double LegendreGauss::tq </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga73858a4ddac05720e2ccb5001fc6ef97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73858a4ddac05720e2ccb5001fc6ef97">&#9670;&nbsp;</a></span>transformGM() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::transformGM </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHArDCore2D_1_1Family.html">Family</a>&lt; BasisType &gt; &amp;&#160;</td>
          <td class="paramname"><em>family_basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>RC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>anc_GM</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transforms a Gram Matrix from an ancestor to a family basis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">family_basis</td><td><a class="el" href="classHArDCore2D_1_1Family.html">Family</a> </td></tr>
    <tr><td class="paramname">RC</td><td>R if transformation applied on rows (left), C if applied on columns (right) </td></tr>
    <tr><td class="paramname">anc_GM</td><td>Gram matrix of the ancestor basis </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8187bfc7c4a27405f770a77bb8831535"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8187bfc7c4a27405f770a77bb8831535">&#9670;&nbsp;</a></span>transformGM() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::transformGM </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHArDCore2D_1_1RestrictedBasis.html">RestrictedBasis</a>&lt; BasisType &gt; &amp;&#160;</td>
          <td class="paramname"><em>restr_basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>RC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>anc_GM</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transforms a Gram Matrix from an ancestor to a restricted basis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">restr_basis</td><td>Restricted basis </td></tr>
    <tr><td class="paramname">RC</td><td>R if transformation applied on rows (left), C if applied on columns (right) </td></tr>
    <tr><td class="paramname">anc_GM</td><td>Gram matrix of the ancestor basis </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5426168676064ac8913c7d2c2431270a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5426168676064ac8913c7d2c2431270a">&#9670;&nbsp;</a></span>transformGM() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::transformGM </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHArDCore2D_1_1ShiftedBasis.html">ShiftedBasis</a>&lt; BasisType &gt; &amp;&#160;</td>
          <td class="paramname"><em>shifted_basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>RC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>anc_GM</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transforms a Gram Matrix from an ancestor to a shifted basis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shifted_basis</td><td>Shifted basis </td></tr>
    <tr><td class="paramname">RC</td><td>R if transformation applied on rows (left), C if applied on columns (right) </td></tr>
    <tr><td class="paramname">anc_GM</td><td>Gram matrix of the ancestor basis </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga50e8f7086d44b7ecff671732ec7a686b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50e8f7086d44b7ecff671732ec7a686b">&#9670;&nbsp;</a></span>useAncestor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool HArDCore2D::useAncestor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the ancestor of a basis will be used to compute a Gram matrix for this basis. </p>

</div>
</div>
<a id="ga27f8f3696a0be686ed1606dda2425da6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27f8f3696a0be686ed1606dda2425da6">&#9670;&nbsp;</a></span>vector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector2d HArDCore2D::QuadratureNode::vector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the quadrature point as an Eigen vector. </p>

</div>
</div>
<a id="ga3fc5a686c8018dbea8ec3a120ad6d9bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3fc5a686c8018dbea8ec3a120ad6d9bc">&#9670;&nbsp;</a></span>wq() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double QuadRuleEdge::wq </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga2800eb7a7c2648b1edb77231ef42608a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2800eb7a7c2648b1edb77231ef42608a">&#9670;&nbsp;</a></span>wq() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double LegendreGauss::wq </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga1b03cf6a6800470a027f570d44338a1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b03cf6a6800470a027f570d44338a1f">&#9670;&nbsp;</a></span>xq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double QuadRuleEdge::xq </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gac272eee335dc95a46787e1a054b38cb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac272eee335dc95a46787e1a054b38cb7">&#9670;&nbsp;</a></span>yq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double QuadRuleEdge::yq </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga4cab982a50db6cc4f4ff1d7ed71deb09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4cab982a50db6cc4f4ff1d7ed71deb09">&#9670;&nbsp;</a></span>~LegendreGauss()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LegendreGauss::~LegendreGauss </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga4b5c5c3ca8408bc40a5c150f48ee2ca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b5c5c3ca8408bc40a5c150f48ee2ca8">&#9670;&nbsp;</a></span>~QuadRuleEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QuadRuleEdge::~QuadRuleEdge </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga5ff899e851df60680e721740e4176fc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ff899e851df60680e721740e4176fc0">&#9670;&nbsp;</a></span>w</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double HArDCore2D::QuadratureNode::w</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga628eb81f57259847bbc6250bc2fc7a47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga628eb81f57259847bbc6250bc2fc7a47">&#9670;&nbsp;</a></span>x</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double HArDCore2D::QuadratureNode::x</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gabd7b50c9a348283e18d94c9e4dba8982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd7b50c9a348283e18d94c9e4dba8982">&#9670;&nbsp;</a></span>y</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double HArDCore2D::QuadratureNode::y</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
